{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nimport { Constants } from \"../constants\";\nimport { Events } from \"../events\";\nimport { Component } from \"../widgets/component\";\nimport { CheckboxSelectionComponent } from \"./checkboxSelectionComponent\";\nimport { CellRangeType, SelectionHandleType } from \"../interfaces/iRangeController\";\nimport { RowDragComp } from \"./rowDragComp\";\nimport { PopupEditorWrapper } from \"./cellEditors/popupEditorWrapper\";\nimport { _ } from \"../utils\";\nimport { DndSourceComp } from \"./dndSourceComp\";\nimport { TooltipFeature } from \"../widgets/tooltipFeature\";\n\nvar CellComp =\n/** @class */\nfunction (_super) {\n  __extends(CellComp, _super);\n\n  function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell, printLayout) {\n    var _this = _super.call(this) || this;\n\n    _this.hasChartRange = false;\n    _this.editingCell = false;\n    _this.suppressRefreshCell = false;\n    _this.scope = null; // every time we go into edit mode, or back again, this gets incremented.\n    // it's the components way of dealing with the async nature of framework components,\n    // so if a framework component takes a while to be created, we know if the object\n    // is still relevant when creating is finished. eg we could click edit / un-edit 20\n    // times before the first React edit component comes back - we should discard\n    // the first 19.\n\n    _this.cellEditorVersion = 0;\n    _this.cellRendererVersion = 0;\n    _this.scope = scope;\n    _this.beans = beans;\n    _this.column = column;\n    _this.rowNode = rowNode;\n    _this.rowComp = rowComp;\n    _this.autoHeightCell = autoHeightCell;\n    _this.printLayout = printLayout;\n\n    _this.createGridCellVo();\n\n    _this.rangeSelectionEnabled = _this.beans.rangeController && beans.gridOptionsWrapper.isEnableRangeSelection();\n    _this.cellFocused = _this.beans.focusController.isCellFocused(_this.cellPosition);\n    _this.firstRightPinned = _this.column.isFirstRightPinned();\n    _this.lastLeftPinned = _this.column.isLastLeftPinned();\n\n    if (_this.rangeSelectionEnabled && _this.beans.rangeController) {\n      var rangeController = _this.beans.rangeController;\n      _this.rangeCount = rangeController.getCellRangeCount(_this.cellPosition);\n      _this.hasChartRange = _this.getHasChartRange();\n    }\n\n    _this.getValueAndFormat();\n\n    _this.setUsingWrapper();\n\n    _this.chooseCellRenderer();\n\n    _this.setupColSpan();\n\n    _this.rowSpan = _this.column.getRowSpan(_this.rowNode);\n    return _this;\n  }\n\n  CellComp.prototype.getCreateTemplate = function () {\n    var unselectable = !this.beans.gridOptionsWrapper.isEnableCellTextSelection() ? 'unselectable=\"on\"' : '';\n    var templateParts = [];\n    var col = this.column;\n    var width = this.getCellWidth();\n    var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n    var valueToRender = this.getInitialValueToRender();\n    var valueSanitised = _.get(this.column, 'colDef.template', null) ? valueToRender : _.escape(valueToRender);\n    this.tooltip = this.getToolTip();\n\n    var tooltipSanitised = _.escape(this.tooltip);\n\n    var colIdSanitised = _.escape(col.getId());\n\n    var wrapperStartTemplate = '';\n    var wrapperEndTemplate = '';\n    var stylesFromColDef = this.preProcessStylesFromColDef();\n    var cssClasses = this.getInitialCssClasses();\n    var stylesForRowSpanning = this.getStylesForRowSpanning();\n\n    var colIdxSanitised = _.escape(this.getAriaColumnIndex());\n\n    if (this.usingWrapper) {\n      wrapperStartTemplate = \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\" role=\\\"presentation\\\">\\n                <span ref=\\\"eCellValue\\\" role=\\\"gridcell\\\" aria-colindex=\\\"\" + colIdxSanitised + \"\\\" class=\\\"ag-cell-value\\\" \" + unselectable + \">\";\n      wrapperEndTemplate = '</span></div>';\n    }\n\n    templateParts.push(\"<div\");\n    templateParts.push(\" tabindex=\\\"-1\\\"\");\n    templateParts.push(\" \" + unselectable); // THIS IS FOR IE ONLY so text selection doesn't bubble outside of the grid\n\n    templateParts.push(\" role=\\\"\" + (this.usingWrapper ? 'presentation' : 'gridcell') + \"\\\"\");\n\n    if (!this.usingWrapper) {\n      templateParts.push(\" aria-colindex=\" + colIdxSanitised);\n    }\n\n    templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\n    templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\n    templateParts.push(\" class=\\\"\" + _.escape(cssClasses.join(' ')) + \"\\\"\");\n\n    if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips() && _.exists(tooltipSanitised)) {\n      templateParts.push(\"title=\\\"\" + tooltipSanitised + \"\\\"\");\n    }\n\n    templateParts.push(\" style=\\\"width: \" + Number(width) + \"px; left: \" + Number(left) + \"px; \" + _.escape(stylesFromColDef) + \" \" + _.escape(stylesForRowSpanning) + \"\\\" >\");\n    templateParts.push(wrapperStartTemplate);\n\n    if (_.exists(valueSanitised, true)) {\n      templateParts.push(valueSanitised);\n    }\n\n    templateParts.push(wrapperEndTemplate);\n    templateParts.push(\"</div>\");\n    return templateParts.join('');\n  };\n\n  CellComp.prototype.getStylesForRowSpanning = function () {\n    if (this.rowSpan === 1) {\n      return '';\n    }\n\n    var singleRowHeight = this.beans.gridOptionsWrapper.getRowHeightAsNumber();\n    var totalRowHeight = singleRowHeight * this.rowSpan;\n    return \"height: \" + totalRowHeight + \"px; z-index: 1;\";\n  };\n\n  CellComp.prototype.afterAttached = function () {\n    var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\n    var eGui = this.eParentRow.querySelector(querySelector);\n    this.setGui(eGui); // all of these have dependencies on the eGui, so only do them after eGui is set\n\n    this.addDomData();\n    this.populateTemplate();\n    this.createCellRendererInstance(true);\n    this.angular1Compile();\n    this.refreshHandle();\n\n    if (_.exists(this.tooltip) && !this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n      this.createManagedBean(new TooltipFeature(this, 'cell'), this.beans.context);\n    }\n  };\n\n  CellComp.prototype.onColumnHover = function () {\n    var isHovered = this.beans.columnHoverService.isHovered(this.column);\n\n    _.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\n  };\n\n  CellComp.prototype.onCellChanged = function (event) {\n    var eventImpactsThisCell = event.column === this.column;\n\n    if (eventImpactsThisCell) {\n      this.refreshCell({});\n    }\n  };\n\n  CellComp.prototype.getCellLeft = function () {\n    var mostLeftCol;\n\n    if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n      mostLeftCol = _.last(this.colsSpanning);\n    } else {\n      mostLeftCol = this.column;\n    }\n\n    return mostLeftCol.getLeft();\n  };\n\n  CellComp.prototype.getCellWidth = function () {\n    if (!this.colsSpanning) {\n      return this.column.getActualWidth();\n    }\n\n    return this.colsSpanning.reduce(function (width, col) {\n      return width + col.getActualWidth();\n    }, 0);\n  };\n\n  CellComp.prototype.onFlashCells = function (event) {\n    var cellId = this.beans.cellPositionUtils.createId(this.cellPosition);\n    var shouldFlash = event.cells[cellId];\n\n    if (shouldFlash) {\n      this.animateCell('highlight');\n    }\n  };\n\n  CellComp.prototype.setupColSpan = function () {\n    // if no col span is active, then we don't set it up, as it would be wasteful of CPU\n    if (_.missing(this.getComponentHolder().colSpan)) {\n      return;\n    } // because we are col spanning, a reorder of the cols can change what cols we are spanning over\n\n\n    this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this)); // because we are spanning over multiple cols, we check for width any time any cols width changes.\n    // this is expensive - really we should be explicitly checking only the cols we are spanning over\n    // instead of every col, however it would be tricky code to track the cols we are spanning over, so\n    // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.\n\n    this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n    this.colsSpanning = this.getColSpanningList();\n  };\n\n  CellComp.prototype.getColSpanningList = function () {\n    var colSpan = this.column.getColSpan(this.rowNode);\n    var colsSpanning = []; // if just one col, the col span is just the column we are in\n\n    if (colSpan === 1) {\n      colsSpanning.push(this.column);\n    } else {\n      var pointer = this.column;\n      var pinned = this.column.getPinned();\n\n      for (var i = 0; pointer && i < colSpan; i++) {\n        colsSpanning.push(pointer);\n        pointer = this.beans.columnController.getDisplayedColAfter(pointer);\n\n        if (!pointer || _.missing(pointer)) {\n          break;\n        } // we do not allow col spanning to span outside of pinned areas\n\n\n        if (pinned !== pointer.getPinned()) {\n          break;\n        }\n      }\n    }\n\n    return colsSpanning;\n  };\n\n  CellComp.prototype.onDisplayColumnsChanged = function () {\n    var colsSpanning = this.getColSpanningList();\n\n    if (!_.areEqual(this.colsSpanning, colsSpanning)) {\n      this.colsSpanning = colsSpanning;\n      this.onWidthChanged();\n      this.onLeftChanged(); // left changes when doing RTL\n    }\n  };\n\n  CellComp.prototype.getAriaColumnIndex = function () {\n    var allColumns = this.beans.columnController.getAllDisplayedColumns();\n    return (allColumns.indexOf(this.column) + 1).toString();\n  };\n\n  CellComp.prototype.refreshAriaIndex = function () {\n    var colIdx = this.getAriaColumnIndex();\n    var el = this.usingWrapper ? this.eCellValue : this.getGui();\n    el.setAttribute('aria-colindex', colIdx);\n  };\n\n  CellComp.prototype.getInitialCssClasses = function () {\n    var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"]; // if we are putting the cell into a dummy container, to work out it's height,\n    // then we don't put the height css in, as we want cell to fit height in that case.\n\n    if (!this.autoHeightCell) {\n      cssClasses.push('ag-cell-auto-height');\n    }\n\n    var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n    if (doingFocusCss && this.cellFocused) {\n      // otherwise the class depends on the focus state\n      cssClasses.push('ag-cell-focus');\n    }\n\n    if (this.firstRightPinned) {\n      cssClasses.push('ag-cell-first-right-pinned');\n    }\n\n    if (this.lastLeftPinned) {\n      cssClasses.push('ag-cell-last-left-pinned');\n    }\n\n    if (this.beans.columnHoverService.isHovered(this.column)) {\n      cssClasses.push('ag-column-hover');\n    }\n\n    _.pushAll(cssClasses, this.preProcessClassesFromColDef());\n\n    _.pushAll(cssClasses, this.preProcessCellClassRules());\n\n    _.pushAll(cssClasses, this.getInitialRangeClasses()); // if using the wrapper, this class goes on the wrapper instead\n\n\n    if (!this.usingWrapper) {\n      cssClasses.push('ag-cell-value');\n    }\n\n    return cssClasses;\n  };\n\n  CellComp.prototype.getInitialValueToRender = function () {\n    // if using a cellRenderer, then render the html from the cell renderer if it exists\n    if (this.usingCellRenderer) {\n      if (typeof this.cellRendererGui === 'string') {\n        return this.cellRendererGui;\n      }\n\n      return '';\n    }\n\n    var colDef = this.getComponentHolder();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      return colDef.template;\n    }\n\n    if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n      return template || '';\n    }\n\n    return this.getValueToUse();\n  };\n\n  CellComp.prototype.getRenderedRow = function () {\n    return this.rowComp;\n  };\n\n  CellComp.prototype.isSuppressNavigable = function () {\n    return this.column.isSuppressNavigable(this.rowNode);\n  };\n\n  CellComp.prototype.getCellRenderer = function () {\n    return this.cellRenderer;\n  };\n\n  CellComp.prototype.getCellEditor = function () {\n    return this.cellEditor;\n  }; // + stop editing {forceRefresh: true, suppressFlash: true}\n  // + event cellChanged {}\n  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\n  // + rowComp: event dataChanged {animate: update, newData: !update}\n  // + rowComp: api refreshCells() {animate: true/false}\n  // + rowRenderer: api softRefreshView() {}\n\n\n  CellComp.prototype.refreshCell = function (params) {\n    // if we are in the middle of 'stopEditing', then we don't refresh here, as refresh gets called explicitly\n    if (this.suppressRefreshCell || this.editingCell) {\n      return;\n    }\n\n    var colDef = this.getComponentHolder();\n    var newData = params && params.newData;\n    var suppressFlash = params && params.suppressFlash || colDef.suppressCellFlash;\n    var forceRefresh = params && params.forceRefresh;\n    var oldValue = this.value; // get latest value without invoking the value formatter as we may not be updating the cell\n\n    this.value = this.getValue(); // for simple values only (not objects), see if the value is the same, and if it is, skip the refresh.\n    // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\n    // if was before the edit.\n\n    var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\n    var dataNeedsUpdating = forceRefresh || valuesDifferent;\n\n    if (dataNeedsUpdating) {\n      // now invoke the value formatter as we are going to update cell\n      this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value); // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\n      // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\n      // then we are not showing a movement in the stock price, rather we are showing different stock.\n\n      var cellRendererRefreshed = newData ? false : this.attemptCellRendererRefresh(); // we do the replace if not doing refresh, or if refresh was unsuccessful.\n      // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\n      // wrapper has the refresh method, but the underlying component doesn't\n\n      if (!cellRendererRefreshed) {\n        this.replaceContentsAfterRefresh();\n      } // we don't want to flash the cells when processing a filter change, as otherwise the UI would\n      // be to busy. see comment in FilterManager with regards processingFilterChange\n\n\n      var processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();\n      var flashCell = !suppressFlash && !processingFilterChange && (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || colDef.enableCellChangeFlash);\n\n      if (flashCell) {\n        this.flashCell();\n      } // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\n\n\n      this.postProcessStylesFromColDef();\n      this.postProcessClassesFromColDef();\n    } // we can't readily determine if the data in an angularjs template has changed, so here we just update\n    // and recompile (if applicable)\n\n\n    this.updateAngular1ScopeAndCompile();\n    this.refreshToolTip(); // we do cellClassRules even if the value has not changed, so that users who have rules that\n    // look at other parts of the row (where the other part of the row might of changed) will work.\n\n    this.postProcessCellClassRules();\n  }; // user can also call this via API\n\n\n  CellComp.prototype.flashCell = function (delays) {\n    var flashDelay = delays && delays.flashDelay;\n    var fadeDelay = delays && delays.fadeDelay;\n    this.animateCell('data-changed', flashDelay, fadeDelay);\n  };\n\n  CellComp.prototype.animateCell = function (cssName, flashDelay, fadeDelay) {\n    var fullName = \"ag-cell-\" + cssName;\n    var animationFullName = \"ag-cell-\" + cssName + \"-animation\";\n    var element = this.getGui();\n    var gridOptionsWrapper = this.beans.gridOptionsWrapper;\n\n    if (!flashDelay) {\n      flashDelay = gridOptionsWrapper.getCellFlashDelay();\n    }\n\n    if (!fadeDelay) {\n      fadeDelay = gridOptionsWrapper.getCellFadeDelay();\n    } // we want to highlight the cells, without any animation\n\n\n    _.addCssClass(element, fullName);\n\n    _.removeCssClass(element, animationFullName); // then once that is applied, we remove the highlight with animation\n\n\n    window.setTimeout(function () {\n      _.removeCssClass(element, fullName);\n\n      _.addCssClass(element, animationFullName);\n\n      element.style.transition = \"background-color \" + fadeDelay + \"ms\";\n      window.setTimeout(function () {\n        // and then to leave things as we got them, we remove the animation\n        _.removeCssClass(element, animationFullName);\n\n        element.style.transition = null;\n      }, fadeDelay);\n    }, flashDelay);\n  };\n\n  CellComp.prototype.replaceContentsAfterRefresh = function () {\n    // otherwise we rip out the cell and replace it\n    _.clearElement(this.eParentOfValue); // remove old renderer component if it exists\n\n\n    this.cellRenderer = this.beans.context.destroyBean(this.cellRenderer);\n    this.cellRendererGui = null; // populate\n\n    this.putDataIntoCellAfterRefresh();\n    this.updateAngular1ScopeAndCompile();\n  };\n\n  CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n      this.scope.data = __assign({}, this.rowNode.data);\n      this.angular1Compile();\n    }\n  };\n\n  CellComp.prototype.angular1Compile = function () {\n    // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\n    if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\n      var eGui = this.getGui(); // only compile the node if it hasn't already been done\n      // this prevents \"orphaned\" node leaks\n\n      if (!eGui.classList.contains('ng-scope') || eGui.childElementCount === 0) {\n        var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\n        this.addDestroyFunc(function () {\n          return compiledElement_1.remove();\n        });\n      }\n    }\n  };\n\n  CellComp.prototype.postProcessStylesFromColDef = function () {\n    var stylesToUse = this.processStylesFromColDef();\n\n    if (stylesToUse) {\n      _.addStylesToElement(this.getGui(), stylesToUse);\n    }\n  };\n\n  CellComp.prototype.preProcessStylesFromColDef = function () {\n    return _.cssStyleObjectToMarkup(this.processStylesFromColDef());\n  };\n\n  CellComp.prototype.processStylesFromColDef = function () {\n    var colDef = this.getComponentHolder();\n\n    if (colDef.cellStyle) {\n      var cssToUse = void 0;\n\n      if (typeof colDef.cellStyle === 'function') {\n        var cellStyleParams = {\n          value: this.value,\n          data: this.rowNode.data,\n          node: this.rowNode,\n          colDef: colDef,\n          column: this.column,\n          $scope: this.scope,\n          context: this.beans.gridOptionsWrapper.getContext(),\n          api: this.beans.gridOptionsWrapper.getApi()\n        };\n        var cellStyleFunc = colDef.cellStyle;\n        cssToUse = cellStyleFunc(cellStyleParams);\n      } else {\n        cssToUse = colDef.cellStyle;\n      }\n\n      return cssToUse;\n    }\n  };\n\n  CellComp.prototype.postProcessClassesFromColDef = function () {\n    var _this = this;\n\n    this.processClassesFromColDef(function (className) {\n      return _.addCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessClassesFromColDef = function () {\n    var res = [];\n    this.processClassesFromColDef(function (className) {\n      return res.push(className);\n    });\n    return res;\n  };\n\n  CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\n    var colDef = this.getComponentHolder();\n    this.beans.stylingService.processStaticCellClasses(colDef, {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: colDef,\n      rowIndex: this.rowNode.rowIndex,\n      $scope: this.scope,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass);\n  };\n\n  CellComp.prototype.putDataIntoCellAfterRefresh = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.getComponentHolder();\n\n    if (colDef.template) {\n      // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n      // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n      this.eParentOfValue.innerHTML = colDef.template;\n    } else if (colDef.templateUrl) {\n      // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n      // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n      // not do these, but would follow a pattern that was friendly towards components, not templates.\n      var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n\n      if (template) {\n        this.eParentOfValue.innerHTML = template;\n      }\n    } else {\n      // we can switch from using a cell renderer back to the default if a user\n      // is using cellRendererSelect\n      this.chooseCellRenderer();\n\n      if (this.usingCellRenderer) {\n        this.createCellRendererInstance();\n      } else {\n        var valueToUse = this.getValueToUse();\n\n        if (valueToUse != null) {\n          this.eParentOfValue.innerHTML = _.escape(valueToUse);\n        }\n      }\n    }\n  };\n\n  CellComp.prototype.attemptCellRendererRefresh = function () {\n    if (_.missing(this.cellRenderer) || !this.cellRenderer || _.missing(this.cellRenderer.refresh)) {\n      return false;\n    } // if the cell renderer has a refresh method, we call this instead of doing a refresh\n\n\n    var params = this.createCellRendererParams(); // take any custom params off of the user\n\n    var finalParams = this.beans.userComponentFactory.createFinalParams(this.getComponentHolder(), this.cellRendererType, params);\n    var result = this.cellRenderer.refresh(finalParams); // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n    // returned nothing, if the method existed, we assumed it refreshed. so for\n    // backwards compatibility, we assume if method exists and returns nothing,\n    // that it was successful.\n\n    return result === true || result === undefined;\n  };\n\n  CellComp.prototype.refreshToolTip = function () {\n    var newTooltip = this.getToolTip();\n\n    if (this.tooltip === newTooltip) {\n      return;\n    }\n\n    var hasNewTooltip = _.exists(newTooltip);\n\n    if (hasNewTooltip && this.tooltip === newTooltip.toString()) {\n      return;\n    }\n\n    var hadTooltip = _.exists(this.tooltip);\n\n    this.tooltip = newTooltip;\n\n    if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n      if (hasNewTooltip) {\n        this.eParentOfValue.setAttribute('title', this.tooltip);\n      } else {\n        this.eParentOfValue.removeAttribute('title');\n      }\n    }\n  };\n\n  CellComp.prototype.valuesAreEqual = function (val1, val2) {\n    // if the user provided an equals method, use that, otherwise do simple comparison\n    var colDef = this.getComponentHolder();\n    var equalsMethod = colDef ? colDef.equals : null;\n    return equalsMethod ? equalsMethod(val1, val2) : val1 === val2;\n  };\n\n  CellComp.prototype.getToolTip = function () {\n    var colDef = this.getComponentHolder();\n    var data = this.rowNode.data;\n\n    if (colDef.tooltipField && _.exists(data)) {\n      return _.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\n    }\n\n    var valueGetter = colDef.tooltipValueGetter || colDef.tooltip;\n\n    if (valueGetter) {\n      return valueGetter({\n        api: this.beans.gridOptionsWrapper.getApi(),\n        columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n        colDef: colDef,\n        column: this.getColumn(),\n        context: this.beans.gridOptionsWrapper.getContext(),\n        value: this.value,\n        valueFormatted: this.valueFormatted,\n        rowIndex: this.cellPosition.rowIndex,\n        node: this.rowNode,\n        data: this.rowNode.data\n      });\n    }\n\n    return null;\n  };\n\n  CellComp.prototype.getTooltipText = function (escape) {\n    if (escape === void 0) {\n      escape = true;\n    }\n\n    return escape ? _.escape(this.tooltip) : this.tooltip;\n  };\n\n  CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\n    var colDef = this.getComponentHolder();\n    this.beans.stylingService.processClassRules(colDef.cellClassRules, {\n      value: this.value,\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: colDef,\n      rowIndex: this.cellPosition.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      $scope: this.scope,\n      context: this.beans.gridOptionsWrapper.getContext()\n    }, onApplicableClass, onNotApplicableClass);\n  };\n\n  CellComp.prototype.postProcessCellClassRules = function () {\n    var _this = this;\n\n    this.processCellClassRules(function (className) {\n      return _.addCssClass(_this.getGui(), className);\n    }, function (className) {\n      return _.removeCssClass(_this.getGui(), className);\n    });\n  };\n\n  CellComp.prototype.preProcessCellClassRules = function () {\n    var res = [];\n    this.processCellClassRules(function (className) {\n      return res.push(className);\n    }, function (_) {// not catered for, if creating, no need\n      // to remove class as it was never there\n    });\n    return res;\n  }; // a wrapper is used when we are putting a selection checkbox in the cell with the value\n\n\n  CellComp.prototype.setUsingWrapper = function () {\n    var colDef = this.getComponentHolder(); // never allow selection or dragging on pinned rows\n\n    if (this.rowNode.rowPinned) {\n      this.usingWrapper = false;\n      this.includeSelectionComponent = false;\n      this.includeRowDraggingComponent = false;\n      this.includeDndSourceComponent = false;\n      return;\n    }\n\n    var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\n    var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\n    var dndSourceIsFunc = typeof colDef.dndSource === 'function';\n    this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\n    this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\n    this.includeDndSourceComponent = dndSourceIsFunc || colDef.dndSource === true;\n    var enableTextSelection = this.beans.gridOptionsWrapper.isEnableCellTextSelection();\n    this.usingWrapper = enableTextSelection || this.includeRowDraggingComponent || this.includeSelectionComponent || this.includeDndSourceComponent;\n  };\n\n  CellComp.prototype.chooseCellRenderer = function () {\n    // template gets preference, then cellRenderer, then do it ourselves\n    var colDef = this.getComponentHolder(); // templates are for ng1, ideally we wouldn't have these, they are ng1 support\n    // inside the core which is bad\n\n    if (colDef.template || colDef.templateUrl) {\n      this.usingCellRenderer = false;\n      return;\n    }\n\n    var params = this.createCellRendererParams();\n    var cellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'cellRenderer', params);\n    var pinnedRowCellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'pinnedRowCellRenderer', params);\n\n    if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\n      this.cellRendererType = CellComp.CELL_RENDERER_TYPE_PINNED;\n      this.usingCellRenderer = true;\n    } else if (cellRenderer) {\n      this.cellRendererType = CellComp.CELL_RENDERER_TYPE_NORMAL;\n      this.usingCellRenderer = true;\n    } else {\n      this.usingCellRenderer = false;\n    }\n  };\n\n  CellComp.prototype.createCellRendererInstance = function (useTaskService) {\n    var _this = this;\n\n    if (useTaskService === void 0) {\n      useTaskService = false;\n    }\n\n    if (!this.usingCellRenderer) {\n      return;\n    } // never use task service if angularCompileRows=true, as that assume the cell renderers\n    // are finished when the row is created. also we never use it if animation frame service\n    // is turned off.\n    // and lastly we never use it if doing auto-height, as the auto-height service checks the\n    // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n\n\n    var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n    var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n\n    if (angularCompileRows || suppressAnimationFrame || this.autoHeightCell) {\n      useTaskService = false;\n    }\n\n    var params = this.createCellRendererParams();\n    this.cellRendererVersion++;\n    var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\n    var cellRendererTypeNormal = this.cellRendererType === CellComp.CELL_RENDERER_TYPE_NORMAL;\n\n    this.createCellRendererFunc = function () {\n      _this.createCellRendererFunc = null; // this can return null in the event that the user has switched from a renderer component to nothing, for example\n      // when using a cellRendererSelect to return a component or null depending on row data etc\n\n      var componentPromise = _this.beans.userComponentFactory.newCellRenderer(_this.getComponentHolder(), params, !cellRendererTypeNormal);\n\n      if (componentPromise) {\n        componentPromise.then(callback);\n      }\n    };\n\n    if (useTaskService) {\n      this.beans.taskQueue.createTask(this.createCellRendererFunc, this.rowNode.rowIndex, 'createTasksP2');\n    } else {\n      this.createCellRendererFunc();\n    }\n  };\n\n  CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\n    var cellRendererNotRequired = !this.isAlive() || cellRendererVersion !== this.cellRendererVersion;\n\n    if (cellRendererNotRequired) {\n      this.beans.context.destroyBean(cellRenderer);\n      return;\n    }\n\n    this.cellRenderer = cellRenderer;\n    this.cellRendererGui = this.cellRenderer.getGui();\n\n    if (_.missing(this.cellRendererGui)) {\n      return;\n    } // if async components, then it's possible the user started editing since this call was made\n\n\n    if (!this.editingCell) {\n      this.eParentOfValue.appendChild(this.cellRendererGui);\n    }\n  };\n\n  CellComp.prototype.createCellRendererParams = function () {\n    var _this = this;\n\n    return {\n      value: this.value,\n      valueFormatted: this.valueFormatted,\n      getValue: this.getValue.bind(this),\n      setValue: function setValue(value) {\n        return _this.beans.valueService.setValue(_this.rowNode, _this.column, value);\n      },\n      formatValue: this.formatValue.bind(this),\n      data: this.rowNode.data,\n      node: this.rowNode,\n      colDef: this.getComponentHolder(),\n      column: this.column,\n      $scope: this.scope,\n      rowIndex: this.cellPosition.rowIndex,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      refreshCell: this.refreshCell.bind(this),\n      eGridCell: this.getGui(),\n      eParentOfValue: this.eParentOfValue,\n      // these bits are not documented anywhere, so we could drop them?\n      // it was in the olden days to allow user to register for when rendered\n      // row was removed (the row comp was removed), however now that the user\n      // can provide components for cells, the destroy method gets call when this\n      // happens so no longer need to fire event.\n      addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\n      addRenderedRowListener: function addRenderedRowListener(eventType, listener) {\n        console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\n\n        if (_this.rowComp) {\n          _this.rowComp.addEventListener(eventType, listener);\n        }\n      }\n    };\n  };\n\n  CellComp.prototype.formatValue = function (value) {\n    var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\n    return valueFormatted != null ? valueFormatted : value;\n  };\n\n  CellComp.prototype.getValueToUse = function () {\n    return this.valueFormatted != null ? this.valueFormatted : this.value;\n  };\n\n  CellComp.prototype.getValueAndFormat = function () {\n    this.value = this.getValue();\n    this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n  };\n\n  CellComp.prototype.getValue = function () {\n    // if we don't check this, then the grid will render leaf groups as open even if we are not\n    // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\n    // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\n    // them via the API, or user user expanded them in the UI before turning on pivot mode\n    var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\n    var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup; // are we showing group footers\n\n    var groupFootersEnabled = this.beans.gridOptionsWrapper.isGroupIncludeFooter(); // if doing footers, we normally don't show agg data at group level when group is open\n\n    var groupAlwaysShowAggData = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader(); // if doing grouping and footers, we don't want to include the agg value\n    // in the header when the group is open\n\n    var ignoreAggData = isOpenGroup && groupFootersEnabled && !groupAlwaysShowAggData;\n    return this.beans.valueService.getValue(this.column, this.rowNode, false, ignoreAggData);\n  };\n\n  CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\n    if (_.isStopPropagationForAgGrid(mouseEvent)) {\n      return;\n    }\n\n    switch (eventName) {\n      case 'click':\n        this.onCellClicked(mouseEvent);\n        break;\n\n      case 'mousedown':\n        this.onMouseDown(mouseEvent);\n        break;\n\n      case 'dblclick':\n        this.onCellDoubleClicked(mouseEvent);\n        break;\n\n      case 'mouseout':\n        this.onMouseOut(mouseEvent);\n        break;\n\n      case 'mouseover':\n        this.onMouseOver(mouseEvent);\n        break;\n    }\n  };\n\n  CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\n    var colDef = this.getComponentHolder();\n    var cellContextMenuEvent = this.createEvent(event, Events.EVENT_CELL_CONTEXT_MENU);\n    this.beans.eventService.dispatchEvent(cellContextMenuEvent);\n\n    if (colDef.onCellContextMenu) {\n      // to make the callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellContextMenu(cellContextMenuEvent);\n      }, 0);\n    }\n  };\n\n  CellComp.prototype.createEvent = function (domEvent, eventType) {\n    var event = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      value: this.value,\n      column: this.column,\n      colDef: this.getComponentHolder(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      api: this.beans.gridApi,\n      columnApi: this.beans.columnApi,\n      rowPinned: this.rowNode.rowPinned,\n      event: domEvent,\n      type: eventType,\n      rowIndex: this.rowNode.rowIndex\n    }; // because we are hacking in $scope for angular 1, we have to de-reference\n\n    if (this.scope) {\n      event.$scope = this.scope;\n    }\n\n    return event;\n  };\n\n  CellComp.prototype.onMouseOut = function (mouseEvent) {\n    var cellMouseOutEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OUT);\n    this.beans.eventService.dispatchEvent(cellMouseOutEvent);\n    this.beans.columnHoverService.clearMouseOver();\n  };\n\n  CellComp.prototype.onMouseOver = function (mouseEvent) {\n    var cellMouseOverEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OVER);\n    this.beans.eventService.dispatchEvent(cellMouseOverEvent);\n    this.beans.columnHoverService.setMouseOver([this.column]);\n  };\n\n  CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\n    var colDef = this.getComponentHolder(); // always dispatch event to eventService\n\n    var cellDoubleClickedEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_DOUBLE_CLICKED);\n    this.beans.eventService.dispatchEvent(cellDoubleClickedEvent); // check if colDef also wants to handle event\n\n    if (typeof colDef.onCellDoubleClicked === 'function') {\n      // to make the callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellDoubleClicked(cellDoubleClickedEvent);\n      }, 0);\n    }\n\n    var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit() && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnDoubleClick) {\n      this.startRowOrCellEdit();\n    }\n  }; // called by rowRenderer when user navigates via tab key\n\n\n  CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.startRowEditing(keyPress, charPress, this);\n    } else {\n      this.startEditingIfEnabled(keyPress, charPress, true);\n    }\n  };\n\n  CellComp.prototype.isCellEditable = function () {\n    return this.column.isCellEditable(this.rowNode);\n  }; // either called internally if single cell editing, or called by rowRenderer if row editing\n\n\n  CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\n    if (keyPress === void 0) {\n      keyPress = null;\n    }\n\n    if (charPress === void 0) {\n      charPress = null;\n    }\n\n    if (cellStartedEdit === void 0) {\n      cellStartedEdit = false;\n    } // don't do it if not editable\n\n\n    if (!this.isCellEditable()) {\n      return;\n    } // don't do it if already editing\n\n\n    if (this.editingCell) {\n      return;\n    }\n\n    this.editingCell = true;\n    this.cellEditorVersion++;\n    var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\n    var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\n    this.createCellEditor(params).then(callback); // if we don't do this, and editor component is async, then there will be a period\n    // when the component isn't present and keyboard navigation won't work - so example\n    // of user hitting tab quickly (more quickly than renderers getting created) won't work\n\n    var cellEditorAsync = _.missing(this.cellEditor);\n\n    if (cellEditorAsync && cellStartedEdit) {\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.createCellEditor = function (params) {\n    var _this = this;\n\n    var cellEditorPromise = this.beans.userComponentFactory.newCellEditor(this.column.getColDef(), params);\n    return cellEditorPromise.then(function (cellEditor) {\n      var isPopup = cellEditor.isPopup && cellEditor.isPopup();\n\n      if (!isPopup) {\n        return cellEditor;\n      }\n\n      if (_this.beans.gridOptionsWrapper.isFullRowEdit()) {\n        console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' + '- either turn off fullRowEdit, or stop using popup editors.');\n      } // if a popup, then we wrap in a popup editor and return the popup\n\n\n      var popupEditorWrapper = new PopupEditorWrapper(cellEditor);\n\n      _this.beans.context.createBean(popupEditorWrapper);\n\n      popupEditorWrapper.init(params);\n      return popupEditorWrapper;\n    });\n  };\n\n  CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\n    // if editingCell=false, means user cancelled the editor before component was ready.\n    // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n    //   is the first editor which is now stale.\n    var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\n    var cellEditorNotNeeded = versionMismatch || !this.editingCell;\n\n    if (cellEditorNotNeeded) {\n      this.beans.context.destroyBean(cellEditor);\n      return;\n    }\n\n    var editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();\n\n    if (editingCancelledByUserComp) {\n      this.beans.context.destroyBean(cellEditor);\n      this.editingCell = false;\n      return;\n    }\n\n    if (!cellEditor.getGui) {\n      console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\"); // no getGui, for React guys, see if they attached a react component directly\n\n      if (cellEditor.render) {\n        console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\n      }\n\n      this.beans.context.destroyBean(cellEditor);\n      this.editingCell = false;\n      return;\n    }\n\n    this.cellEditor = cellEditor;\n    this.cellEditorInPopup = cellEditor.isPopup !== undefined && cellEditor.isPopup();\n    this.setInlineEditingClass();\n\n    if (this.cellEditorInPopup) {\n      this.addPopupCellEditor();\n    } else {\n      this.addInCellEditor();\n    }\n\n    if (cellEditor.afterGuiAttached) {\n      cellEditor.afterGuiAttached();\n    }\n\n    var event = this.createEvent(null, Events.EVENT_CELL_EDITING_STARTED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.prototype.addInCellEditor = function () {\n    _.clearElement(this.getGui());\n\n    if (this.cellEditor) {\n      this.getGui().appendChild(this.cellEditor.getGui());\n    }\n\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.addPopupCellEditor = function () {\n    var _this = this;\n\n    var ePopupGui = this.cellEditor ? this.cellEditor.getGui() : null;\n    var useModelPopup = this.beans.gridOptionsWrapper.isStopEditingWhenGridLosesFocus();\n    this.hideEditorPopup = this.beans.popupService.addPopup(useModelPopup, ePopupGui, true, // callback for when popup disappears\n    function () {\n      _this.onPopupEditorClosed();\n    });\n    var params = {\n      column: this.column,\n      rowNode: this.rowNode,\n      type: 'popupCellEditor',\n      eventSource: this.getGui(),\n      ePopup: ePopupGui,\n      keepWithinBounds: true\n    };\n    var position = this.cellEditor && this.cellEditor.getPopupPosition ? this.cellEditor.getPopupPosition() : 'over';\n\n    if (position === 'under') {\n      this.beans.popupService.positionPopupUnderComponent(params);\n    } else {\n      this.beans.popupService.positionPopupOverComponent(params);\n    }\n\n    this.angular1Compile();\n  };\n\n  CellComp.prototype.onPopupEditorClosed = function () {\n    // we only call stopEditing if we are editing, as\n    // it's possible the popup called 'stop editing'\n    // before this, eg if 'enter key' was pressed on\n    // the editor.\n    if (this.editingCell) {\n      // note: this only happens when use clicks outside of the grid. if use clicks on another\n      // cell, then the editing will have already stopped on this cell\n      this.stopRowOrCellEdit(); // we only focus cell again if this cell is still focused. it is possible\n      // it is not focused if the user cancelled the edit by clicking on another\n      // cell outside of this one\n\n      if (this.beans.focusController.isCellFocused(this.cellPosition)) {\n        this.focusCell(true);\n      }\n    }\n  }; // if we are editing inline, then we don't have the padding in the cell (set in the themes)\n  // to allow the text editor full access to the entire cell\n\n\n  CellComp.prototype.setInlineEditingClass = function () {\n    if (!this.isAlive()) {\n      return;\n    } // ag-cell-inline-editing - appears when user is inline editing\n    // ag-cell-not-inline-editing - appears when user is no inline editing\n    // ag-cell-popup-editing - appears when user is editing cell in popup (appears on the cell, not on the popup)\n    // note: one of {ag-cell-inline-editing, ag-cell-not-inline-editing} is always present, they toggle.\n    //       however {ag-cell-popup-editing} shows when popup, so you have both {ag-cell-popup-editing}\n    //       and {ag-cell-not-inline-editing} showing at the same time.\n\n\n    var editingInline = this.editingCell && !this.cellEditorInPopup;\n    var popupEditorShowing = this.editingCell && this.cellEditorInPopup;\n\n    _.addOrRemoveCssClass(this.getGui(), \"ag-cell-inline-editing\", editingInline);\n\n    _.addOrRemoveCssClass(this.getGui(), \"ag-cell-not-inline-editing\", !editingInline);\n\n    _.addOrRemoveCssClass(this.getGui(), \"ag-cell-popup-editing\", popupEditorShowing);\n\n    _.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-inline-editing\", editingInline);\n\n    _.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-not-inline-editing\", !editingInline);\n  };\n\n  CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\n    return {\n      value: this.getValue(),\n      keyPress: keyPress,\n      charPress: charPress,\n      column: this.column,\n      colDef: this.column.getColDef(),\n      rowIndex: this.cellPosition.rowIndex,\n      node: this.rowNode,\n      data: this.rowNode.data,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      cellStartedEdit: cellStartedEdit,\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext(),\n      $scope: this.scope,\n      onKeyDown: this.onKeyDown.bind(this),\n      stopEditing: this.stopEditingAndFocus.bind(this),\n      eGridCell: this.getGui(),\n      parseValue: this.parseValue.bind(this),\n      formatValue: this.formatValue.bind(this)\n    };\n  }; // cell editors call this, when they want to stop for reasons other\n  // than what we pick up on. eg selecting from a dropdown ends editing.\n\n\n  CellComp.prototype.stopEditingAndFocus = function (suppressNavigateAfterEdit) {\n    if (suppressNavigateAfterEdit === void 0) {\n      suppressNavigateAfterEdit = false;\n    }\n\n    this.stopRowOrCellEdit();\n    this.focusCell(true);\n\n    if (!suppressNavigateAfterEdit) {\n      this.navigateAfterEdit();\n    }\n  };\n\n  CellComp.prototype.parseValue = function (newValue) {\n    var colDef = this.getComponentHolder();\n    var params = {\n      node: this.rowNode,\n      data: this.rowNode.data,\n      oldValue: this.value,\n      newValue: newValue,\n      colDef: colDef,\n      column: this.column,\n      api: this.beans.gridOptionsWrapper.getApi(),\n      columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n      context: this.beans.gridOptionsWrapper.getContext()\n    };\n    var valueParser = colDef.valueParser;\n    return _.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\n  };\n\n  CellComp.prototype.focusCell = function (forceBrowserFocus) {\n    if (forceBrowserFocus === void 0) {\n      forceBrowserFocus = false;\n    }\n\n    this.beans.focusController.setFocusedCell(this.cellPosition.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\n  };\n\n  CellComp.prototype.setFocusInOnEditor = function () {\n    if (this.editingCell) {\n      if (this.cellEditor && this.cellEditor.focusIn) {\n        // if the editor is present, then we just focus it\n        this.cellEditor.focusIn();\n      } else {\n        // if the editor is not present, it means async cell editor (eg React fibre)\n        // and we are trying to set focus before the cell editor is present, so we\n        // focus the cell instead\n        this.focusCell(true);\n      }\n    }\n  };\n\n  CellComp.prototype.isEditing = function () {\n    return this.editingCell;\n  };\n\n  CellComp.prototype.onKeyDown = function (event) {\n    var key = event.which || event.keyCode;\n\n    switch (key) {\n      case Constants.KEY_ENTER:\n        this.onEnterKeyDown(event);\n        break;\n\n      case Constants.KEY_F2:\n        this.onF2KeyDown();\n        break;\n\n      case Constants.KEY_ESCAPE:\n        this.onEscapeKeyDown();\n        break;\n\n      case Constants.KEY_TAB:\n        this.onTabKeyDown(event);\n        break;\n\n      case Constants.KEY_BACKSPACE:\n      case Constants.KEY_DELETE:\n        this.onBackspaceOrDeleteKeyPressed(key);\n        break;\n\n      case Constants.KEY_DOWN:\n      case Constants.KEY_UP:\n      case Constants.KEY_RIGHT:\n      case Constants.KEY_LEFT:\n        this.onNavigationKeyPressed(event, key);\n        break;\n    }\n  };\n\n  CellComp.prototype.setFocusOutOnEditor = function () {\n    if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\n      this.cellEditor.focusOut();\n    }\n  };\n\n  CellComp.prototype.onNavigationKeyPressed = function (event, key) {\n    if (this.editingCell) {\n      return;\n    }\n\n    if (event.shiftKey && this.rangeSelectionEnabled) {\n      this.onShiftRangeSelect(key);\n    } else {\n      this.beans.rowRenderer.navigateToNextCell(event, key, this.cellPosition, true);\n    } // if we don't prevent default, the grid will scroll with the navigation keys\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onShiftRangeSelect = function (key) {\n    if (!this.beans.rangeController) {\n      return;\n    }\n\n    var endCell = this.beans.rangeController.extendLatestRangeInDirection(key);\n\n    if (endCell) {\n      this.beans.rowRenderer.ensureCellVisible(endCell);\n    }\n  };\n\n  CellComp.prototype.onTabKeyDown = function (event) {\n    this.beans.rowRenderer.onTabKeyDown(this, event);\n  };\n\n  CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(key);\n    }\n  };\n\n  CellComp.prototype.onEnterKeyDown = function (e) {\n    if (this.editingCell || this.rowComp.isEditing()) {\n      this.stopEditingAndFocus();\n    } else {\n      if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\n        this.beans.rowRenderer.navigateToNextCell(null, Constants.KEY_DOWN, this.cellPosition, false);\n      } else {\n        e.preventDefault();\n        this.startRowOrCellEdit(Constants.KEY_ENTER);\n      }\n    }\n  };\n\n  CellComp.prototype.navigateAfterEdit = function () {\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (fullRowEdit) {\n      return;\n    }\n\n    var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\n\n    if (enterMovesDownAfterEdit) {\n      this.beans.rowRenderer.navigateToNextCell(null, Constants.KEY_DOWN, this.cellPosition, false);\n    }\n  };\n\n  CellComp.prototype.onF2KeyDown = function () {\n    if (!this.editingCell) {\n      this.startRowOrCellEdit(Constants.KEY_F2);\n    }\n  };\n\n  CellComp.prototype.onEscapeKeyDown = function () {\n    if (this.editingCell) {\n      this.stopRowOrCellEdit(true);\n      this.focusCell(true);\n    }\n  };\n\n  CellComp.prototype.onKeyPress = function (event) {\n    // check this, in case focus is on a (for example) a text field inside the cell,\n    // in which cse we should not be listening for these key pressed\n    var eventTarget = _.getTarget(event);\n\n    var eventOnChildComponent = eventTarget !== this.getGui();\n\n    if (eventOnChildComponent || this.editingCell) {\n      return;\n    }\n\n    var pressedChar = String.fromCharCode(event.charCode);\n\n    if (pressedChar === ' ') {\n      this.onSpaceKeyPressed(event);\n    } else if (_.isEventFromPrintableCharacter(event)) {\n      this.startRowOrCellEdit(null, pressedChar); // if we don't prevent default, then the keypress also gets applied to the text field\n      // (at least when doing the default editor), but we need to allow the editor to decide\n      // what it wants to do. we only do this IF editing was started - otherwise it messes\n      // up when the use is not doing editing, but using rendering with text fields in cellRenderer\n      // (as it would block the the user from typing into text fields).\n\n      event.preventDefault();\n    }\n  };\n\n  CellComp.prototype.onSpaceKeyPressed = function (event) {\n    var gridOptionsWrapper = this.beans.gridOptionsWrapper;\n\n    if (!this.editingCell && gridOptionsWrapper.isRowSelection()) {\n      var newSelection = !this.rowNode.isSelected();\n\n      if (newSelection || gridOptionsWrapper.isRowDeselection()) {\n        this.rowNode.setSelected(newSelection);\n      }\n    } // prevent default as space key, by default, moves browser scroll down\n\n\n    event.preventDefault();\n  };\n\n  CellComp.prototype.onMouseDown = function (mouseEvent) {\n    var ctrlKey = mouseEvent.ctrlKey,\n        metaKey = mouseEvent.metaKey,\n        shiftKey = mouseEvent.shiftKey;\n    var target = mouseEvent.target;\n    var _a = this.beans,\n        eventService = _a.eventService,\n        rangeController = _a.rangeController; // do not change the range for right-clicks inside an existing range\n\n    if (this.isRightClickInExistingRange(mouseEvent)) {\n      return;\n    }\n\n    if (!shiftKey || rangeController && !rangeController.getCellRanges().length) {\n      // We only need to pass true to focusCell when the browser is IE/Edge and we are trying\n      // to focus the cell itself. This should never be true if the mousedown was triggered\n      // due to a click on a cell editor for example.\n      var forceBrowserFocus = (_.isBrowserIE() || _.isBrowserEdge()) && !this.editingCell;\n      this.focusCell(forceBrowserFocus);\n    } else {\n      // if a range is being changed, we need to make sure the focused cell does not change.\n      mouseEvent.preventDefault();\n    } // if we are clicking on a checkbox, we need to make sure the cell wrapping that checkbox\n    // is focused but we don't want to change the range selection, so return here.\n\n\n    if (this.containsWidget(target)) {\n      return;\n    }\n\n    if (rangeController) {\n      var thisCell = this.cellPosition;\n\n      if (shiftKey) {\n        rangeController.extendLatestRangeToCell(thisCell);\n      } else {\n        var ctrlKeyPressed = ctrlKey || metaKey;\n        rangeController.setRangeToCell(thisCell, ctrlKeyPressed);\n      }\n    }\n\n    eventService.dispatchEvent(this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_DOWN));\n  };\n\n  CellComp.prototype.isRightClickInExistingRange = function (mouseEvent) {\n    var rangeController = this.beans.rangeController;\n\n    if (rangeController) {\n      var cellInRange = rangeController.isCellInAnyRange(this.getCellPosition());\n\n      if (cellInRange && mouseEvent.button === 2) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  CellComp.prototype.containsWidget = function (target) {\n    return _.isElementChildOfClass(target, 'ag-selection-checkbox', 3);\n  }; // returns true if on iPad and this is second 'click' event in 200ms\n\n\n  CellComp.prototype.isDoubleClickOnIPad = function () {\n    if (!_.isIOSUserAgent() || _.isEventSupported('dblclick')) {\n      return false;\n    }\n\n    var nowMillis = new Date().getTime();\n    var res = nowMillis - this.lastIPadMouseClickEvent < 200;\n    this.lastIPadMouseClickEvent = nowMillis;\n    return res;\n  };\n\n  CellComp.prototype.onCellClicked = function (mouseEvent) {\n    // iPad doesn't have double click - so we need to mimic it to enable editing for iPad.\n    if (this.isDoubleClickOnIPad()) {\n      this.onCellDoubleClicked(mouseEvent);\n      mouseEvent.preventDefault(); // if we don't do this, then iPad zooms in\n\n      return;\n    }\n\n    var _a = this.beans,\n        eventService = _a.eventService,\n        gridOptionsWrapper = _a.gridOptionsWrapper;\n    var cellClickedEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_CLICKED);\n    eventService.dispatchEvent(cellClickedEvent);\n    var colDef = this.getComponentHolder();\n\n    if (colDef.onCellClicked) {\n      // to make callback async, do in a timeout\n      window.setTimeout(function () {\n        return colDef.onCellClicked(cellClickedEvent);\n      }, 0);\n    }\n\n    var editOnSingleClick = (gridOptionsWrapper.isSingleClickEdit() || colDef.singleClickEdit) && !gridOptionsWrapper.isSuppressClickEdit();\n\n    if (editOnSingleClick) {\n      this.startRowOrCellEdit();\n    }\n  };\n\n  CellComp.prototype.createGridCellVo = function () {\n    this.cellPosition = {\n      rowIndex: this.rowNode.rowIndex,\n      rowPinned: this.rowNode.rowPinned,\n      column: this.column\n    };\n  };\n\n  CellComp.prototype.getCellPosition = function () {\n    return this.cellPosition;\n  };\n\n  CellComp.prototype.getParentRow = function () {\n    return this.eParentRow;\n  };\n\n  CellComp.prototype.setParentRow = function (eParentRow) {\n    this.eParentRow = eParentRow;\n  };\n\n  CellComp.prototype.getColumn = function () {\n    return this.column;\n  };\n\n  CellComp.prototype.getComponentHolder = function () {\n    return this.column.getColDef();\n  };\n\n  CellComp.prototype.detach = function () {\n    this.eParentRow.removeChild(this.getGui());\n  }; // if the row is also getting destroyed, then we don't need to remove from dom,\n  // as the row will also get removed, so no need to take out the cells from the row\n  // if the row is going (removing is an expensive operation, so only need to remove\n  // the top part)\n  //\n  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.\n\n\n  CellComp.prototype.destroy = function () {\n    if (this.createCellRendererFunc) {\n      this.beans.taskQueue.cancelTask(this.createCellRendererFunc);\n    }\n\n    this.stopEditing();\n    this.cellRenderer = this.beans.context.destroyBean(this.cellRenderer);\n    this.beans.context.destroyBean(this.selectionHandle);\n\n    _super.prototype.destroy.call(this);\n  };\n\n  CellComp.prototype.onLeftChanged = function () {\n    var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n    this.getGui().style.left = left + 'px';\n    this.refreshAriaIndex();\n  };\n\n  CellComp.prototype.modifyLeftForPrintLayout = function (leftPosition) {\n    if (!this.printLayout || this.column.getPinned() === Constants.PINNED_LEFT) {\n      return leftPosition;\n    }\n\n    if (this.column.getPinned() === Constants.PINNED_RIGHT) {\n      var leftWidth_1 = this.beans.columnController.getPinnedLeftContainerWidth();\n      var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n      return leftWidth_1 + bodyWidth + leftPosition;\n    } // is in body\n\n\n    var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n    return leftWidth + leftPosition;\n  };\n\n  CellComp.prototype.onWidthChanged = function () {\n    var width = this.getCellWidth();\n    this.getGui().style.width = width + 'px';\n  };\n\n  CellComp.prototype.getRangeBorders = function () {\n    var _this = this;\n\n    var isRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n    var top = false;\n    var right = false;\n    var bottom = false;\n    var left = false;\n    var thisCol = this.cellPosition.column;\n    var _a = this.beans,\n        rangeController = _a.rangeController,\n        columnController = _a.columnController;\n    var leftCol;\n    var rightCol;\n\n    if (isRtl) {\n      leftCol = columnController.getDisplayedColAfter(thisCol);\n      rightCol = columnController.getDisplayedColBefore(thisCol);\n    } else {\n      leftCol = columnController.getDisplayedColBefore(thisCol);\n      rightCol = columnController.getDisplayedColAfter(thisCol);\n    }\n\n    var ranges = rangeController.getCellRanges().filter(function (range) {\n      return rangeController.isCellInSpecificRange(_this.cellPosition, range);\n    }); // this means we are the first column in the grid\n\n    if (!leftCol) {\n      left = true;\n    } // this means we are the last column in the grid\n\n\n    if (!rightCol) {\n      right = true;\n    }\n\n    for (var i = 0; i < ranges.length; i++) {\n      if (top && right && bottom && left) {\n        break;\n      }\n\n      var range = ranges[i];\n      var startRow = rangeController.getRangeStartRow(range);\n      var endRow = rangeController.getRangeEndRow(range);\n\n      if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellPosition)) {\n        top = true;\n      }\n\n      if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellPosition)) {\n        bottom = true;\n      }\n\n      if (!left && range.columns.indexOf(leftCol) < 0) {\n        left = true;\n      }\n\n      if (!right && range.columns.indexOf(rightCol) < 0) {\n        right = true;\n      }\n    }\n\n    return {\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left\n    };\n  };\n\n  CellComp.prototype.getInitialRangeClasses = function () {\n    var classes = [];\n\n    if (!this.rangeSelectionEnabled || !this.rangeCount) {\n      return classes;\n    }\n\n    classes.push('ag-cell-range-selected');\n\n    if (this.hasChartRange) {\n      classes.push('ag-cell-range-chart');\n    }\n\n    var count = Math.min(this.rangeCount, 4);\n    classes.push(\"ag-cell-range-selected-\" + count);\n\n    if (this.isSingleCell()) {\n      classes.push('ag-cell-range-single-cell');\n    }\n\n    if (this.rangeCount > 0) {\n      var borders = this.getRangeBorders();\n\n      if (borders.top) {\n        classes.push('ag-cell-range-top');\n      }\n\n      if (borders.right) {\n        classes.push('ag-cell-range-right');\n      }\n\n      if (borders.bottom) {\n        classes.push('ag-cell-range-bottom');\n      }\n\n      if (borders.left) {\n        classes.push('ag-cell-range-left');\n      }\n    }\n\n    if (!!this.selectionHandle) {\n      classes.push('ag-cell-range-handle');\n    }\n\n    return classes;\n  };\n\n  CellComp.prototype.onRowIndexChanged = function () {\n    // when index changes, this influences items that need the index, so we update the\n    // grid cell so they are working off the new index.\n    this.createGridCellVo(); // when the index of the row changes, ie means the cell may have lost or gained focus\n\n    this.onCellFocused(); // check range selection\n\n    this.onRangeSelectionChanged();\n  };\n\n  CellComp.prototype.onRangeSelectionChanged = function () {\n    var rangeController = this.beans.rangeController;\n\n    if (!rangeController) {\n      return;\n    }\n\n    var _a = this,\n        cellPosition = _a.cellPosition,\n        rangeCount = _a.rangeCount;\n\n    var newRangeCount = rangeController.getCellRangeCount(cellPosition);\n    var element = this.getGui();\n\n    if (rangeCount !== newRangeCount) {\n      _.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\n\n      _.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\n\n      _.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\n\n      _.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\n\n      _.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\n\n      this.rangeCount = newRangeCount;\n    }\n\n    var hasChartRange = this.getHasChartRange();\n\n    if (hasChartRange !== this.hasChartRange) {\n      this.hasChartRange = hasChartRange;\n\n      _.addOrRemoveCssClass(element, 'ag-cell-range-chart', this.hasChartRange);\n    }\n\n    this.updateRangeBorders();\n\n    _.addOrRemoveCssClass(element, 'ag-cell-range-single-cell', this.isSingleCell());\n\n    this.refreshHandle();\n  };\n\n  CellComp.prototype.getHasChartRange = function () {\n    var rangeController = this.beans.rangeController;\n\n    if (!this.rangeCount || !rangeController) {\n      return false;\n    }\n\n    var cellRanges = rangeController.getCellRanges();\n    return cellRanges.length > 0 && cellRanges.every(function (range) {\n      return _.includes([CellRangeType.DIMENSION, CellRangeType.VALUE], range.type);\n    });\n  };\n\n  CellComp.prototype.shouldHaveSelectionHandle = function () {\n    var _a = this.beans,\n        gridOptionsWrapper = _a.gridOptionsWrapper,\n        rangeController = _a.rangeController;\n    var cellRanges = rangeController.getCellRanges();\n    var rangesLen = cellRanges.length;\n\n    if (this.rangeCount < 1 || rangesLen < 1) {\n      return false;\n    }\n\n    var cellRange = _.last(cellRanges);\n\n    var cellPosition = this.getCellPosition();\n    var fillHandleIsAvailable = rangesLen === 1 && (gridOptionsWrapper.isEnableFillHandle() || gridOptionsWrapper.isEnableRangeHandle()) && !this.editingCell;\n\n    if (this.hasChartRange) {\n      var hasCategoryRange = cellRanges[0].type === CellRangeType.DIMENSION;\n      var isCategoryCell = hasCategoryRange && rangeController.isCellInSpecificRange(cellPosition, cellRanges[0]);\n\n      _.addOrRemoveCssClass(this.getGui(), 'ag-cell-range-chart-category', isCategoryCell);\n\n      fillHandleIsAvailable = cellRange.type === CellRangeType.VALUE;\n    }\n\n    return fillHandleIsAvailable && cellRange.endRow != null && rangeController.isContiguousRange(cellRange) && rangeController.isBottomRightCell(cellRange, cellPosition);\n  };\n\n  CellComp.prototype.addSelectionHandle = function () {\n    var _a = this.beans,\n        gridOptionsWrapper = _a.gridOptionsWrapper,\n        context = _a.context,\n        rangeController = _a.rangeController;\n\n    var cellRangeType = _.last(rangeController.getCellRanges()).type;\n\n    var selectionHandleFill = gridOptionsWrapper.isEnableFillHandle() && _.missing(cellRangeType);\n\n    var type = selectionHandleFill ? SelectionHandleType.FILL : SelectionHandleType.RANGE;\n\n    if (this.selectionHandle && this.selectionHandle.getType() !== type) {\n      this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);\n    }\n\n    if (!this.selectionHandle) {\n      this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(type);\n    }\n\n    this.selectionHandle.refresh(this);\n  };\n\n  CellComp.prototype.updateRangeBordersIfRangeCount = function () {\n    // we only need to update range borders if we are in a range\n    if (this.rangeCount > 0) {\n      this.updateRangeBorders();\n      this.refreshHandle();\n    }\n  };\n\n  CellComp.prototype.refreshHandle = function () {\n    if (!this.beans.rangeController) {\n      return;\n    }\n\n    var shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();\n\n    if (this.selectionHandle && !shouldHaveSelectionHandle) {\n      this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);\n    }\n\n    if (shouldHaveSelectionHandle) {\n      this.addSelectionHandle();\n    }\n\n    _.addOrRemoveCssClass(this.getGui(), 'ag-cell-range-handle', !!this.selectionHandle);\n  };\n\n  CellComp.prototype.updateRangeBorders = function () {\n    var rangeBorders = this.getRangeBorders();\n    var isSingleCell = this.isSingleCell();\n    var isTop = !isSingleCell && rangeBorders.top;\n    var isRight = !isSingleCell && rangeBorders.right;\n    var isBottom = !isSingleCell && rangeBorders.bottom;\n    var isLeft = !isSingleCell && rangeBorders.left;\n    var element = this.getGui();\n\n    _.addOrRemoveCssClass(element, 'ag-cell-range-top', isTop);\n\n    _.addOrRemoveCssClass(element, 'ag-cell-range-right', isRight);\n\n    _.addOrRemoveCssClass(element, 'ag-cell-range-bottom', isBottom);\n\n    _.addOrRemoveCssClass(element, 'ag-cell-range-left', isLeft);\n  };\n\n  CellComp.prototype.onFirstRightPinnedChanged = function () {\n    var firstRightPinned = this.column.isFirstRightPinned();\n\n    if (this.firstRightPinned !== firstRightPinned) {\n      this.firstRightPinned = firstRightPinned;\n\n      _.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\n    }\n  };\n\n  CellComp.prototype.onLastLeftPinnedChanged = function () {\n    var lastLeftPinned = this.column.isLastLeftPinned();\n\n    if (this.lastLeftPinned !== lastLeftPinned) {\n      this.lastLeftPinned = lastLeftPinned;\n\n      _.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\n    }\n  };\n\n  CellComp.prototype.populateTemplate = function () {\n    if (this.usingWrapper) {\n      this.eParentOfValue = this.getRefElement('eCellValue');\n      this.eCellWrapper = this.getRefElement('eCellWrapper');\n      this.eCellValue = this.getRefElement('eCellValue');\n\n      if (this.includeRowDraggingComponent) {\n        this.addRowDragging();\n      }\n\n      if (this.includeDndSourceComponent) {\n        this.addDndSource();\n      }\n\n      if (this.includeSelectionComponent) {\n        this.addSelectionCheckbox();\n      }\n    } else {\n      this.eParentOfValue = this.getGui();\n    }\n  };\n\n  CellComp.prototype.getFrameworkOverrides = function () {\n    return this.beans.frameworkOverrides;\n  };\n\n  CellComp.prototype.addRowDragging = function () {\n    var pagination = this.beans.gridOptionsWrapper.isPagination();\n    var rowDragManaged = this.beans.gridOptionsWrapper.isRowDragManaged();\n    var clientSideRowModelActive = this.beans.gridOptionsWrapper.isRowModelDefault();\n\n    if (rowDragManaged) {\n      // row dragging only available in default row model\n      if (!clientSideRowModelActive) {\n        _.doOnce(function () {\n          return console.warn('ag-Grid: managed row dragging is only allowed in the Client Side Row Model');\n        }, 'CellComp.addRowDragging');\n\n        return;\n      }\n\n      if (pagination) {\n        _.doOnce(function () {\n          return console.warn('ag-Grid: managed row dragging is not possible when doing pagination');\n        }, 'CellComp.addRowDragging');\n\n        return;\n      }\n    }\n\n    var rowDraggingComp = new RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\n    this.createManagedBean(rowDraggingComp, this.beans.context); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addDndSource = function () {\n    var dndSourceComp = new DndSourceComp(this.rowNode, this.column, this.getValueToUse(), this.beans, this.getGui());\n    this.createManagedBean(dndSourceComp, this.beans.context); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(dndSourceComp.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addSelectionCheckbox = function () {\n    var _this = this;\n\n    var cbSelectionComponent = new CheckboxSelectionComponent();\n    this.beans.context.createBean(cbSelectionComponent);\n    var visibleFunc = this.getComponentHolder().checkboxSelection;\n    visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n    cbSelectionComponent.init({\n      rowNode: this.rowNode,\n      column: this.column,\n      visibleFunc: visibleFunc\n    });\n    this.addDestroyFunc(function () {\n      return _this.beans.context.destroyBean(cbSelectionComponent);\n    }); // put the checkbox in before the value\n\n    this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\n  };\n\n  CellComp.prototype.addDomData = function () {\n    var _this = this;\n\n    var element = this.getGui();\n    this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\n    this.addDestroyFunc(function () {\n      return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null);\n    });\n  };\n\n  CellComp.prototype.isSingleCell = function () {\n    var rangeController = this.beans.rangeController;\n    return this.rangeCount === 1 && rangeController && !rangeController.isMoreThanOneCell();\n  };\n\n  CellComp.prototype.onCellFocused = function (event) {\n    var cellFocused = this.beans.focusController.isCellFocused(this.cellPosition); // see if we need to change the classes on this cell\n\n    if (cellFocused !== this.cellFocused) {\n      // if we are not doing cell selection, then the focus class does not change\n      var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n\n      if (doingFocusCss) {\n        _.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\n      }\n\n      this.cellFocused = cellFocused;\n    } // see if we need to force browser focus - this can happen if focus is programmatically set\n\n\n    if (cellFocused && event && event.forceBrowserFocus) {\n      var focusEl = this.getFocusableElement();\n      focusEl.focus(); // Fix for AG-3465 \"IE11 - After editing cell's content, selection doesn't go one cell below on enter\"\n      // IE can fail to focus the cell after the first call to focus(), and needs a second call\n\n      if (!document.activeElement || document.activeElement === document.body) {\n        focusEl.focus();\n      }\n    } // if another cell was focused, and we are editing, then stop editing\n\n\n    var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n\n    if (!cellFocused && !fullRowEdit && this.editingCell) {\n      this.stopRowOrCellEdit();\n    }\n  }; // pass in 'true' to cancel the editing.\n\n\n  CellComp.prototype.stopRowOrCellEdit = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n      this.rowComp.stopRowEditing(cancel);\n    } else {\n      this.stopEditing(cancel);\n    }\n  };\n\n  CellComp.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    if (!this.editingCell) {\n      return;\n    } // if no cell editor, this means due to async, that the cell editor never got initialised,\n    // so we just carry on regardless as if the editing was never started.\n\n\n    if (!this.cellEditor) {\n      this.editingCell = false;\n      return;\n    }\n\n    var oldValue = this.getValue();\n    var newValueExists = false;\n    var newValue;\n\n    if (!cancel) {\n      // also have another option here to cancel after editing, so for example user could have a popup editor and\n      // it is closed by user clicking outside the editor. then the editor will close automatically (with false\n      // passed above) and we need to see if the editor wants to accept the new value.\n      var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\n\n      if (!userWantsToCancel) {\n        newValue = this.cellEditor.getValue();\n        newValueExists = true;\n      }\n    } // it is important we set this after setValue() above, as otherwise the cell will flash\n    // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\n    // thus it will skip the refresh on this cell until the end of this method where we call\n    // refresh directly and we suppress the flash.\n\n\n    this.editingCell = false; // important to clear this out - as parts of the code will check for\n    // this to see if an async cellEditor has yet to be created\n\n    this.cellEditor = this.beans.context.destroyBean(this.cellEditor);\n    this.cellEditor = null;\n\n    if (this.cellEditorInPopup && this.hideEditorPopup) {\n      this.hideEditorPopup();\n      this.hideEditorPopup = null;\n    } else {\n      _.clearElement(this.getGui()); // put the cell back the way it was before editing\n\n\n      if (this.usingWrapper) {\n        // if wrapper, then put the wrapper back\n        this.getGui().appendChild(this.eCellWrapper);\n      } else if (this.cellRenderer) {\n        // if cellRenderer, then put the gui back in. if the renderer has\n        // a refresh, it will be called. however if it doesn't, then later\n        // the renderer will be destroyed and a new one will be created.\n        // we know it's a dom element (not a string) because we converted\n        // it after the gui was attached if it was a string.\n        var eCell = this.cellRendererGui; // can be null if cell was previously null / contained empty string,\n        // this will result in new value not being rendered.\n\n        if (eCell) {\n          this.getGui().appendChild(eCell);\n        }\n      }\n    }\n\n    this.setInlineEditingClass();\n    this.refreshHandle();\n\n    if (newValueExists && newValue !== oldValue) {\n      // we suppressRefreshCell because the call to rowNode.setDataValue() results in change detection\n      // getting triggered, which results in all cells getting refreshed. we do not want this refresh\n      // to happen on this call as we want to call it explicitly below. otherwise refresh gets called twice.\n      // if we only did this refresh (and not the one below) then the cell would flash and not be forced.\n      this.suppressRefreshCell = true;\n      this.rowNode.setDataValue(this.column, newValue);\n      this.suppressRefreshCell = false;\n    } // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\n    // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\n    // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\n\n\n    this.refreshCell({\n      forceRefresh: true,\n      suppressFlash: true\n    });\n    var event = this.createEvent(null, Events.EVENT_CELL_EDITING_STOPPED);\n    this.beans.eventService.dispatchEvent(event);\n  };\n\n  CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\n  CellComp.CELL_RENDERER_TYPE_NORMAL = 'cellRenderer';\n  CellComp.CELL_RENDERER_TYPE_PINNED = 'pinnedRowCellRenderer';\n  return CellComp;\n}(Component);\n\nexport { CellComp };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/rendering/cellComp.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","Constants","Events","Component","CheckboxSelectionComponent","CellRangeType","SelectionHandleType","RowDragComp","PopupEditorWrapper","_","DndSourceComp","TooltipFeature","CellComp","_super","scope","beans","column","rowNode","rowComp","autoHeightCell","printLayout","_this","hasChartRange","editingCell","suppressRefreshCell","cellEditorVersion","cellRendererVersion","createGridCellVo","rangeSelectionEnabled","rangeController","gridOptionsWrapper","isEnableRangeSelection","cellFocused","focusController","isCellFocused","cellPosition","firstRightPinned","isFirstRightPinned","lastLeftPinned","isLastLeftPinned","rangeCount","getCellRangeCount","getHasChartRange","getValueAndFormat","setUsingWrapper","chooseCellRenderer","setupColSpan","rowSpan","getRowSpan","getCreateTemplate","unselectable","isEnableCellTextSelection","templateParts","col","width","getCellWidth","left","modifyLeftForPrintLayout","getCellLeft","valueToRender","getInitialValueToRender","valueSanitised","get","escape","tooltip","getToolTip","tooltipSanitised","colIdSanitised","getId","wrapperStartTemplate","wrapperEndTemplate","stylesFromColDef","preProcessStylesFromColDef","cssClasses","getInitialCssClasses","stylesForRowSpanning","getStylesForRowSpanning","colIdxSanitised","getAriaColumnIndex","usingWrapper","push","getCompId","join","isEnableBrowserTooltips","exists","Number","singleRowHeight","getRowHeightAsNumber","totalRowHeight","afterAttached","querySelector","eGui","eParentRow","setGui","addDomData","populateTemplate","createCellRendererInstance","angular1Compile","refreshHandle","createManagedBean","context","onColumnHover","isHovered","columnHoverService","addOrRemoveCssClass","getGui","onCellChanged","event","eventImpactsThisCell","refreshCell","mostLeftCol","isEnableRtl","colsSpanning","last","getLeft","getActualWidth","reduce","onFlashCells","cellId","cellPositionUtils","createId","shouldFlash","cells","animateCell","missing","getComponentHolder","colSpan","addManagedListener","eventService","EVENT_DISPLAYED_COLUMNS_CHANGED","onDisplayColumnsChanged","bind","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onWidthChanged","getColSpanningList","getColSpan","pointer","pinned","getPinned","columnController","getDisplayedColAfter","areEqual","onLeftChanged","allColumns","getAllDisplayedColumns","indexOf","toString","refreshAriaIndex","colIdx","el","eCellValue","setAttribute","doingFocusCss","isSuppressCellSelection","pushAll","preProcessClassesFromColDef","preProcessCellClassRules","getInitialRangeClasses","usingCellRenderer","cellRendererGui","colDef","template","templateUrl","templateService","getTemplate","getValueToUse","getRenderedRow","isSuppressNavigable","getCellRenderer","cellRenderer","getCellEditor","cellEditor","params","newData","suppressFlash","suppressCellFlash","forceRefresh","oldValue","value","getValue","valuesDifferent","valuesAreEqual","dataNeedsUpdating","valueFormatted","valueFormatterService","formatValue","cellRendererRefreshed","attemptCellRendererRefresh","replaceContentsAfterRefresh","processingFilterChange","filterManager","isSuppressFlashingCellsBecauseFiltering","flashCell","isEnableCellChangeFlash","enableCellChangeFlash","postProcessStylesFromColDef","postProcessClassesFromColDef","updateAngular1ScopeAndCompile","refreshToolTip","postProcessCellClassRules","delays","flashDelay","fadeDelay","cssName","fullName","animationFullName","element","getCellFlashDelay","getCellFadeDelay","addCssClass","removeCssClass","window","setTimeout","style","transition","clearElement","eParentOfValue","destroyBean","putDataIntoCellAfterRefresh","isAngularCompileRows","data","classList","contains","childElementCount","compiledElement_1","$compile","addDestroyFunc","remove","stylesToUse","processStylesFromColDef","addStylesToElement","cssStyleObjectToMarkup","cellStyle","cssToUse","cellStyleParams","node","$scope","getContext","api","getApi","cellStyleFunc","processClassesFromColDef","className","res","onApplicableClass","stylingService","processStaticCellClasses","rowIndex","columnApi","getColumnApi","innerHTML","valueToUse","refresh","createCellRendererParams","finalParams","userComponentFactory","createFinalParams","cellRendererType","result","undefined","newTooltip","hasNewTooltip","hadTooltip","removeAttribute","val1","val2","equalsMethod","equals","tooltipField","getValueUsingField","isTooltipFieldContainsDots","valueGetter","tooltipValueGetter","getColumn","getTooltipText","processCellClassRules","onNotApplicableClass","processClassRules","cellClassRules","rowPinned","includeSelectionComponent","includeRowDraggingComponent","includeDndSourceComponent","cbSelectionIsFunc","checkboxSelection","rowDraggableIsFunc","rowDrag","dndSourceIsFunc","dndSource","enableTextSelection","lookupComponentClassDef","pinnedRowCellRenderer","CELL_RENDERER_TYPE_PINNED","CELL_RENDERER_TYPE_NORMAL","useTaskService","angularCompileRows","suppressAnimationFrame","isSuppressAnimationFrame","callback","afterCellRendererCreated","cellRendererTypeNormal","createCellRendererFunc","componentPromise","newCellRenderer","then","taskQueue","createTask","cellRendererNotRequired","isAlive","appendChild","setValue","valueService","eGridCell","addRowCompListener","addEventListener","addRenderedRowListener","eventType","listener","console","warn","lockedClosedGroup","leafGroup","isPivotMode","isOpenGroup","group","expanded","footer","groupFootersEnabled","isGroupIncludeFooter","groupAlwaysShowAggData","isGroupSuppressBlankHeader","ignoreAggData","onMouseEvent","eventName","mouseEvent","isStopPropagationForAgGrid","onCellClicked","onMouseDown","onCellDoubleClicked","onMouseOut","onMouseOver","dispatchCellContextMenuEvent","cellContextMenuEvent","createEvent","EVENT_CELL_CONTEXT_MENU","dispatchEvent","onCellContextMenu","domEvent","gridApi","type","cellMouseOutEvent","EVENT_CELL_MOUSE_OUT","clearMouseOver","cellMouseOverEvent","EVENT_CELL_MOUSE_OVER","setMouseOver","cellDoubleClickedEvent","EVENT_CELL_DOUBLE_CLICKED","editOnDoubleClick","isSingleClickEdit","isSuppressClickEdit","startRowOrCellEdit","keyPress","charPress","isFullRowEdit","startRowEditing","startEditingIfEnabled","isCellEditable","cellStartedEdit","afterCellEditorCreated","createCellEditorParams","createCellEditor","cellEditorAsync","focusCell","cellEditorPromise","newCellEditor","getColDef","isPopup","popupEditorWrapper","createBean","init","versionMismatch","cellEditorNotNeeded","editingCancelledByUserComp","isCancelBeforeStart","render","cellEditorInPopup","setInlineEditingClass","addPopupCellEditor","addInCellEditor","afterGuiAttached","EVENT_CELL_EDITING_STARTED","ePopupGui","useModelPopup","isStopEditingWhenGridLosesFocus","hideEditorPopup","popupService","addPopup","onPopupEditorClosed","eventSource","ePopup","keepWithinBounds","position","getPopupPosition","positionPopupUnderComponent","positionPopupOverComponent","stopRowOrCellEdit","editingInline","popupEditorShowing","parentNode","onKeyDown","stopEditing","stopEditingAndFocus","parseValue","suppressNavigateAfterEdit","navigateAfterEdit","newValue","valueParser","expressionService","evaluate","forceBrowserFocus","setFocusedCell","setFocusInOnEditor","focusIn","isEditing","key","which","keyCode","KEY_ENTER","onEnterKeyDown","KEY_F2","onF2KeyDown","KEY_ESCAPE","onEscapeKeyDown","KEY_TAB","onTabKeyDown","KEY_BACKSPACE","KEY_DELETE","onBackspaceOrDeleteKeyPressed","KEY_DOWN","KEY_UP","KEY_RIGHT","KEY_LEFT","onNavigationKeyPressed","setFocusOutOnEditor","focusOut","shiftKey","onShiftRangeSelect","rowRenderer","navigateToNextCell","preventDefault","endCell","extendLatestRangeInDirection","ensureCellVisible","e","isEnterMovesDown","fullRowEdit","enterMovesDownAfterEdit","isEnterMovesDownAfterEdit","onKeyPress","eventTarget","getTarget","eventOnChildComponent","pressedChar","String","fromCharCode","charCode","onSpaceKeyPressed","isEventFromPrintableCharacter","isRowSelection","newSelection","isSelected","isRowDeselection","setSelected","ctrlKey","metaKey","target","_a","isRightClickInExistingRange","getCellRanges","isBrowserIE","isBrowserEdge","containsWidget","thisCell","extendLatestRangeToCell","ctrlKeyPressed","setRangeToCell","EVENT_CELL_MOUSE_DOWN","cellInRange","isCellInAnyRange","getCellPosition","button","isElementChildOfClass","isDoubleClickOnIPad","isIOSUserAgent","isEventSupported","nowMillis","Date","getTime","lastIPadMouseClickEvent","cellClickedEvent","EVENT_CELL_CLICKED","editOnSingleClick","singleClickEdit","getParentRow","setParentRow","detach","removeChild","destroy","cancelTask","selectionHandle","leftPosition","PINNED_LEFT","PINNED_RIGHT","leftWidth_1","getPinnedLeftContainerWidth","bodyWidth","getBodyContainerWidth","leftWidth","getRangeBorders","isRtl","top","right","bottom","thisCol","leftCol","rightCol","getDisplayedColBefore","ranges","filter","range","isCellInSpecificRange","startRow","getRangeStartRow","endRow","getRangeEndRow","rowPositionUtils","sameRow","columns","classes","count","Math","min","isSingleCell","borders","onRowIndexChanged","onCellFocused","onRangeSelectionChanged","newRangeCount","updateRangeBorders","cellRanges","every","includes","DIMENSION","VALUE","shouldHaveSelectionHandle","rangesLen","cellRange","fillHandleIsAvailable","isEnableFillHandle","isEnableRangeHandle","hasCategoryRange","isCategoryCell","isContiguousRange","isBottomRightCell","addSelectionHandle","cellRangeType","selectionHandleFill","FILL","RANGE","getType","selectionHandleFactory","createSelectionHandle","updateRangeBordersIfRangeCount","rangeBorders","isTop","isRight","isBottom","isLeft","onFirstRightPinnedChanged","onLastLeftPinnedChanged","getRefElement","eCellWrapper","addRowDragging","addDndSource","addSelectionCheckbox","getFrameworkOverrides","frameworkOverrides","pagination","isPagination","rowDragManaged","isRowDragManaged","clientSideRowModelActive","isRowModelDefault","doOnce","rowDraggingComp","insertBefore","dndSourceComp","cbSelectionComponent","visibleFunc","setDomData","DOM_DATA_KEY_CELL_COMP","isMoreThanOneCell","focusEl","getFocusableElement","focus","document","activeElement","body","cancel","stopRowEditing","newValueExists","userWantsToCancel","isCancelAfterEnd","eCell","setDataValue","EVENT_CELL_EDITING_STOPPED"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nimport { Constants } from \"../constants\";\nimport { Events } from \"../events\";\nimport { Component } from \"../widgets/component\";\nimport { CheckboxSelectionComponent } from \"./checkboxSelectionComponent\";\nimport { CellRangeType, SelectionHandleType } from \"../interfaces/iRangeController\";\nimport { RowDragComp } from \"./rowDragComp\";\nimport { PopupEditorWrapper } from \"./cellEditors/popupEditorWrapper\";\nimport { _ } from \"../utils\";\nimport { DndSourceComp } from \"./dndSourceComp\";\nimport { TooltipFeature } from \"../widgets/tooltipFeature\";\nvar CellComp = /** @class */ (function (_super) {\n    __extends(CellComp, _super);\n    function CellComp(scope, beans, column, rowNode, rowComp, autoHeightCell, printLayout) {\n        var _this = _super.call(this) || this;\n        _this.hasChartRange = false;\n        _this.editingCell = false;\n        _this.suppressRefreshCell = false;\n        _this.scope = null;\n        // every time we go into edit mode, or back again, this gets incremented.\n        // it's the components way of dealing with the async nature of framework components,\n        // so if a framework component takes a while to be created, we know if the object\n        // is still relevant when creating is finished. eg we could click edit / un-edit 20\n        // times before the first React edit component comes back - we should discard\n        // the first 19.\n        _this.cellEditorVersion = 0;\n        _this.cellRendererVersion = 0;\n        _this.scope = scope;\n        _this.beans = beans;\n        _this.column = column;\n        _this.rowNode = rowNode;\n        _this.rowComp = rowComp;\n        _this.autoHeightCell = autoHeightCell;\n        _this.printLayout = printLayout;\n        _this.createGridCellVo();\n        _this.rangeSelectionEnabled = _this.beans.rangeController && beans.gridOptionsWrapper.isEnableRangeSelection();\n        _this.cellFocused = _this.beans.focusController.isCellFocused(_this.cellPosition);\n        _this.firstRightPinned = _this.column.isFirstRightPinned();\n        _this.lastLeftPinned = _this.column.isLastLeftPinned();\n        if (_this.rangeSelectionEnabled && _this.beans.rangeController) {\n            var rangeController = _this.beans.rangeController;\n            _this.rangeCount = rangeController.getCellRangeCount(_this.cellPosition);\n            _this.hasChartRange = _this.getHasChartRange();\n        }\n        _this.getValueAndFormat();\n        _this.setUsingWrapper();\n        _this.chooseCellRenderer();\n        _this.setupColSpan();\n        _this.rowSpan = _this.column.getRowSpan(_this.rowNode);\n        return _this;\n    }\n    CellComp.prototype.getCreateTemplate = function () {\n        var unselectable = !this.beans.gridOptionsWrapper.isEnableCellTextSelection() ? 'unselectable=\"on\"' : '';\n        var templateParts = [];\n        var col = this.column;\n        var width = this.getCellWidth();\n        var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n        var valueToRender = this.getInitialValueToRender();\n        var valueSanitised = _.get(this.column, 'colDef.template', null) ? valueToRender : _.escape(valueToRender);\n        this.tooltip = this.getToolTip();\n        var tooltipSanitised = _.escape(this.tooltip);\n        var colIdSanitised = _.escape(col.getId());\n        var wrapperStartTemplate = '';\n        var wrapperEndTemplate = '';\n        var stylesFromColDef = this.preProcessStylesFromColDef();\n        var cssClasses = this.getInitialCssClasses();\n        var stylesForRowSpanning = this.getStylesForRowSpanning();\n        var colIdxSanitised = _.escape(this.getAriaColumnIndex());\n        if (this.usingWrapper) {\n            wrapperStartTemplate = \"<div ref=\\\"eCellWrapper\\\" class=\\\"ag-cell-wrapper\\\" role=\\\"presentation\\\">\\n                <span ref=\\\"eCellValue\\\" role=\\\"gridcell\\\" aria-colindex=\\\"\" + colIdxSanitised + \"\\\" class=\\\"ag-cell-value\\\" \" + unselectable + \">\";\n            wrapperEndTemplate = '</span></div>';\n        }\n        templateParts.push(\"<div\");\n        templateParts.push(\" tabindex=\\\"-1\\\"\");\n        templateParts.push(\" \" + unselectable); // THIS IS FOR IE ONLY so text selection doesn't bubble outside of the grid\n        templateParts.push(\" role=\\\"\" + (this.usingWrapper ? 'presentation' : 'gridcell') + \"\\\"\");\n        if (!this.usingWrapper) {\n            templateParts.push(\" aria-colindex=\" + colIdxSanitised);\n        }\n        templateParts.push(\" comp-id=\\\"\" + this.getCompId() + \"\\\" \");\n        templateParts.push(\" col-id=\\\"\" + colIdSanitised + \"\\\"\");\n        templateParts.push(\" class=\\\"\" + _.escape(cssClasses.join(' ')) + \"\\\"\");\n        if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips() && _.exists(tooltipSanitised)) {\n            templateParts.push(\"title=\\\"\" + tooltipSanitised + \"\\\"\");\n        }\n        templateParts.push(\" style=\\\"width: \" + Number(width) + \"px; left: \" + Number(left) + \"px; \" + _.escape(stylesFromColDef) + \" \" + _.escape(stylesForRowSpanning) + \"\\\" >\");\n        templateParts.push(wrapperStartTemplate);\n        if (_.exists(valueSanitised, true)) {\n            templateParts.push(valueSanitised);\n        }\n        templateParts.push(wrapperEndTemplate);\n        templateParts.push(\"</div>\");\n        return templateParts.join('');\n    };\n    CellComp.prototype.getStylesForRowSpanning = function () {\n        if (this.rowSpan === 1) {\n            return '';\n        }\n        var singleRowHeight = this.beans.gridOptionsWrapper.getRowHeightAsNumber();\n        var totalRowHeight = singleRowHeight * this.rowSpan;\n        return \"height: \" + totalRowHeight + \"px; z-index: 1;\";\n    };\n    CellComp.prototype.afterAttached = function () {\n        var querySelector = \"[comp-id=\\\"\" + this.getCompId() + \"\\\"]\";\n        var eGui = this.eParentRow.querySelector(querySelector);\n        this.setGui(eGui);\n        // all of these have dependencies on the eGui, so only do them after eGui is set\n        this.addDomData();\n        this.populateTemplate();\n        this.createCellRendererInstance(true);\n        this.angular1Compile();\n        this.refreshHandle();\n        if (_.exists(this.tooltip) && !this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n            this.createManagedBean(new TooltipFeature(this, 'cell'), this.beans.context);\n        }\n    };\n    CellComp.prototype.onColumnHover = function () {\n        var isHovered = this.beans.columnHoverService.isHovered(this.column);\n        _.addOrRemoveCssClass(this.getGui(), 'ag-column-hover', isHovered);\n    };\n    CellComp.prototype.onCellChanged = function (event) {\n        var eventImpactsThisCell = event.column === this.column;\n        if (eventImpactsThisCell) {\n            this.refreshCell({});\n        }\n    };\n    CellComp.prototype.getCellLeft = function () {\n        var mostLeftCol;\n        if (this.beans.gridOptionsWrapper.isEnableRtl() && this.colsSpanning) {\n            mostLeftCol = _.last(this.colsSpanning);\n        }\n        else {\n            mostLeftCol = this.column;\n        }\n        return mostLeftCol.getLeft();\n    };\n    CellComp.prototype.getCellWidth = function () {\n        if (!this.colsSpanning) {\n            return this.column.getActualWidth();\n        }\n        return this.colsSpanning.reduce(function (width, col) { return width + col.getActualWidth(); }, 0);\n    };\n    CellComp.prototype.onFlashCells = function (event) {\n        var cellId = this.beans.cellPositionUtils.createId(this.cellPosition);\n        var shouldFlash = event.cells[cellId];\n        if (shouldFlash) {\n            this.animateCell('highlight');\n        }\n    };\n    CellComp.prototype.setupColSpan = function () {\n        // if no col span is active, then we don't set it up, as it would be wasteful of CPU\n        if (_.missing(this.getComponentHolder().colSpan)) {\n            return;\n        }\n        // because we are col spanning, a reorder of the cols can change what cols we are spanning over\n        this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayColumnsChanged.bind(this));\n        // because we are spanning over multiple cols, we check for width any time any cols width changes.\n        // this is expensive - really we should be explicitly checking only the cols we are spanning over\n        // instead of every col, however it would be tricky code to track the cols we are spanning over, so\n        // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.\n        this.addManagedListener(this.beans.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, this.onWidthChanged.bind(this));\n        this.colsSpanning = this.getColSpanningList();\n    };\n    CellComp.prototype.getColSpanningList = function () {\n        var colSpan = this.column.getColSpan(this.rowNode);\n        var colsSpanning = [];\n        // if just one col, the col span is just the column we are in\n        if (colSpan === 1) {\n            colsSpanning.push(this.column);\n        }\n        else {\n            var pointer = this.column;\n            var pinned = this.column.getPinned();\n            for (var i = 0; pointer && i < colSpan; i++) {\n                colsSpanning.push(pointer);\n                pointer = this.beans.columnController.getDisplayedColAfter(pointer);\n                if (!pointer || _.missing(pointer)) {\n                    break;\n                }\n                // we do not allow col spanning to span outside of pinned areas\n                if (pinned !== pointer.getPinned()) {\n                    break;\n                }\n            }\n        }\n        return colsSpanning;\n    };\n    CellComp.prototype.onDisplayColumnsChanged = function () {\n        var colsSpanning = this.getColSpanningList();\n        if (!_.areEqual(this.colsSpanning, colsSpanning)) {\n            this.colsSpanning = colsSpanning;\n            this.onWidthChanged();\n            this.onLeftChanged(); // left changes when doing RTL\n        }\n    };\n    CellComp.prototype.getAriaColumnIndex = function () {\n        var allColumns = this.beans.columnController.getAllDisplayedColumns();\n        return (allColumns.indexOf(this.column) + 1).toString();\n    };\n    CellComp.prototype.refreshAriaIndex = function () {\n        var colIdx = this.getAriaColumnIndex();\n        var el = this.usingWrapper ? this.eCellValue : this.getGui();\n        el.setAttribute('aria-colindex', colIdx);\n    };\n    CellComp.prototype.getInitialCssClasses = function () {\n        var cssClasses = [\"ag-cell\", \"ag-cell-not-inline-editing\"];\n        // if we are putting the cell into a dummy container, to work out it's height,\n        // then we don't put the height css in, as we want cell to fit height in that case.\n        if (!this.autoHeightCell) {\n            cssClasses.push('ag-cell-auto-height');\n        }\n        var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n        if (doingFocusCss && this.cellFocused) {\n            // otherwise the class depends on the focus state\n            cssClasses.push('ag-cell-focus');\n        }\n        if (this.firstRightPinned) {\n            cssClasses.push('ag-cell-first-right-pinned');\n        }\n        if (this.lastLeftPinned) {\n            cssClasses.push('ag-cell-last-left-pinned');\n        }\n        if (this.beans.columnHoverService.isHovered(this.column)) {\n            cssClasses.push('ag-column-hover');\n        }\n        _.pushAll(cssClasses, this.preProcessClassesFromColDef());\n        _.pushAll(cssClasses, this.preProcessCellClassRules());\n        _.pushAll(cssClasses, this.getInitialRangeClasses());\n        // if using the wrapper, this class goes on the wrapper instead\n        if (!this.usingWrapper) {\n            cssClasses.push('ag-cell-value');\n        }\n        return cssClasses;\n    };\n    CellComp.prototype.getInitialValueToRender = function () {\n        // if using a cellRenderer, then render the html from the cell renderer if it exists\n        if (this.usingCellRenderer) {\n            if (typeof this.cellRendererGui === 'string') {\n                return this.cellRendererGui;\n            }\n            return '';\n        }\n        var colDef = this.getComponentHolder();\n        if (colDef.template) {\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n            return colDef.template;\n        }\n        if (colDef.templateUrl) {\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n            return template || '';\n        }\n        return this.getValueToUse();\n    };\n    CellComp.prototype.getRenderedRow = function () {\n        return this.rowComp;\n    };\n    CellComp.prototype.isSuppressNavigable = function () {\n        return this.column.isSuppressNavigable(this.rowNode);\n    };\n    CellComp.prototype.getCellRenderer = function () {\n        return this.cellRenderer;\n    };\n    CellComp.prototype.getCellEditor = function () {\n        return this.cellEditor;\n    };\n    // + stop editing {forceRefresh: true, suppressFlash: true}\n    // + event cellChanged {}\n    // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything\n    // + rowComp: event dataChanged {animate: update, newData: !update}\n    // + rowComp: api refreshCells() {animate: true/false}\n    // + rowRenderer: api softRefreshView() {}\n    CellComp.prototype.refreshCell = function (params) {\n        // if we are in the middle of 'stopEditing', then we don't refresh here, as refresh gets called explicitly\n        if (this.suppressRefreshCell || this.editingCell) {\n            return;\n        }\n        var colDef = this.getComponentHolder();\n        var newData = params && params.newData;\n        var suppressFlash = (params && params.suppressFlash) || colDef.suppressCellFlash;\n        var forceRefresh = params && params.forceRefresh;\n        var oldValue = this.value;\n        // get latest value without invoking the value formatter as we may not be updating the cell\n        this.value = this.getValue();\n        // for simple values only (not objects), see if the value is the same, and if it is, skip the refresh.\n        // when never allow skipping after an edit, as after editing, we need to put the GUI back to the way\n        // if was before the edit.\n        var valuesDifferent = !this.valuesAreEqual(oldValue, this.value);\n        var dataNeedsUpdating = forceRefresh || valuesDifferent;\n        if (dataNeedsUpdating) {\n            // now invoke the value formatter as we are going to update cell\n            this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n            // if it's 'new data', then we don't refresh the cellRenderer, even if refresh method is available.\n            // this is because if the whole data is new (ie we are showing stock price 'BBA' now and not 'SSD')\n            // then we are not showing a movement in the stock price, rather we are showing different stock.\n            var cellRendererRefreshed = newData ? false : this.attemptCellRendererRefresh();\n            // we do the replace if not doing refresh, or if refresh was unsuccessful.\n            // the refresh can be unsuccessful if we are using a framework (eg ng2 or react) and the framework\n            // wrapper has the refresh method, but the underlying component doesn't\n            if (!cellRendererRefreshed) {\n                this.replaceContentsAfterRefresh();\n            }\n            // we don't want to flash the cells when processing a filter change, as otherwise the UI would\n            // be to busy. see comment in FilterManager with regards processingFilterChange\n            var processingFilterChange = this.beans.filterManager.isSuppressFlashingCellsBecauseFiltering();\n            var flashCell = !suppressFlash && !processingFilterChange &&\n                (this.beans.gridOptionsWrapper.isEnableCellChangeFlash() || colDef.enableCellChangeFlash);\n            if (flashCell) {\n                this.flashCell();\n            }\n            // need to check rules. note, we ignore colDef classes and styles, these are assumed to be static\n            this.postProcessStylesFromColDef();\n            this.postProcessClassesFromColDef();\n        }\n        // we can't readily determine if the data in an angularjs template has changed, so here we just update\n        // and recompile (if applicable)\n        this.updateAngular1ScopeAndCompile();\n        this.refreshToolTip();\n        // we do cellClassRules even if the value has not changed, so that users who have rules that\n        // look at other parts of the row (where the other part of the row might of changed) will work.\n        this.postProcessCellClassRules();\n    };\n    // user can also call this via API\n    CellComp.prototype.flashCell = function (delays) {\n        var flashDelay = delays && delays.flashDelay;\n        var fadeDelay = delays && delays.fadeDelay;\n        this.animateCell('data-changed', flashDelay, fadeDelay);\n    };\n    CellComp.prototype.animateCell = function (cssName, flashDelay, fadeDelay) {\n        var fullName = \"ag-cell-\" + cssName;\n        var animationFullName = \"ag-cell-\" + cssName + \"-animation\";\n        var element = this.getGui();\n        var gridOptionsWrapper = this.beans.gridOptionsWrapper;\n        if (!flashDelay) {\n            flashDelay = gridOptionsWrapper.getCellFlashDelay();\n        }\n        if (!fadeDelay) {\n            fadeDelay = gridOptionsWrapper.getCellFadeDelay();\n        }\n        // we want to highlight the cells, without any animation\n        _.addCssClass(element, fullName);\n        _.removeCssClass(element, animationFullName);\n        // then once that is applied, we remove the highlight with animation\n        window.setTimeout(function () {\n            _.removeCssClass(element, fullName);\n            _.addCssClass(element, animationFullName);\n            element.style.transition = \"background-color \" + fadeDelay + \"ms\";\n            window.setTimeout(function () {\n                // and then to leave things as we got them, we remove the animation\n                _.removeCssClass(element, animationFullName);\n                element.style.transition = null;\n            }, fadeDelay);\n        }, flashDelay);\n    };\n    CellComp.prototype.replaceContentsAfterRefresh = function () {\n        // otherwise we rip out the cell and replace it\n        _.clearElement(this.eParentOfValue);\n        // remove old renderer component if it exists\n        this.cellRenderer = this.beans.context.destroyBean(this.cellRenderer);\n        this.cellRendererGui = null;\n        // populate\n        this.putDataIntoCellAfterRefresh();\n        this.updateAngular1ScopeAndCompile();\n    };\n    CellComp.prototype.updateAngular1ScopeAndCompile = function () {\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows() && this.scope) {\n            this.scope.data = __assign({}, this.rowNode.data);\n            this.angular1Compile();\n        }\n    };\n    CellComp.prototype.angular1Compile = function () {\n        // if angular compiling, then need to also compile the cell again (angular compiling sucks, please wait...)\n        if (this.beans.gridOptionsWrapper.isAngularCompileRows()) {\n            var eGui = this.getGui();\n            // only compile the node if it hasn't already been done\n            // this prevents \"orphaned\" node leaks\n            if (!eGui.classList.contains('ng-scope') || eGui.childElementCount === 0) {\n                var compiledElement_1 = this.beans.$compile(eGui)(this.scope);\n                this.addDestroyFunc(function () { return compiledElement_1.remove(); });\n            }\n        }\n    };\n    CellComp.prototype.postProcessStylesFromColDef = function () {\n        var stylesToUse = this.processStylesFromColDef();\n        if (stylesToUse) {\n            _.addStylesToElement(this.getGui(), stylesToUse);\n        }\n    };\n    CellComp.prototype.preProcessStylesFromColDef = function () {\n        return _.cssStyleObjectToMarkup(this.processStylesFromColDef());\n    };\n    CellComp.prototype.processStylesFromColDef = function () {\n        var colDef = this.getComponentHolder();\n        if (colDef.cellStyle) {\n            var cssToUse = void 0;\n            if (typeof colDef.cellStyle === 'function') {\n                var cellStyleParams = {\n                    value: this.value,\n                    data: this.rowNode.data,\n                    node: this.rowNode,\n                    colDef: colDef,\n                    column: this.column,\n                    $scope: this.scope,\n                    context: this.beans.gridOptionsWrapper.getContext(),\n                    api: this.beans.gridOptionsWrapper.getApi()\n                };\n                var cellStyleFunc = colDef.cellStyle;\n                cssToUse = cellStyleFunc(cellStyleParams);\n            }\n            else {\n                cssToUse = colDef.cellStyle;\n            }\n            return cssToUse;\n        }\n    };\n    CellComp.prototype.postProcessClassesFromColDef = function () {\n        var _this = this;\n        this.processClassesFromColDef(function (className) { return _.addCssClass(_this.getGui(), className); });\n    };\n    CellComp.prototype.preProcessClassesFromColDef = function () {\n        var res = [];\n        this.processClassesFromColDef(function (className) { return res.push(className); });\n        return res;\n    };\n    CellComp.prototype.processClassesFromColDef = function (onApplicableClass) {\n        var colDef = this.getComponentHolder();\n        this.beans.stylingService.processStaticCellClasses(colDef, {\n            value: this.value,\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: colDef,\n            rowIndex: this.rowNode.rowIndex,\n            $scope: this.scope,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext()\n        }, onApplicableClass);\n    };\n    CellComp.prototype.putDataIntoCellAfterRefresh = function () {\n        // template gets preference, then cellRenderer, then do it ourselves\n        var colDef = this.getComponentHolder();\n        if (colDef.template) {\n            // template is really only used for angular 1 - as people using ng1 are used to providing templates with\n            // bindings in it. in ng2, people will hopefully want to provide components, not templates.\n            this.eParentOfValue.innerHTML = colDef.template;\n        }\n        else if (colDef.templateUrl) {\n            // likewise for templateUrl - it's for ng1 really - when we move away from ng1, we can take these out.\n            // niall was pro angular 1 when writing template and templateUrl, if writing from scratch now, would\n            // not do these, but would follow a pattern that was friendly towards components, not templates.\n            var template = this.beans.templateService.getTemplate(colDef.templateUrl, this.refreshCell.bind(this, true));\n            if (template) {\n                this.eParentOfValue.innerHTML = template;\n            }\n        }\n        else {\n            // we can switch from using a cell renderer back to the default if a user\n            // is using cellRendererSelect\n            this.chooseCellRenderer();\n            if (this.usingCellRenderer) {\n                this.createCellRendererInstance();\n            }\n            else {\n                var valueToUse = this.getValueToUse();\n                if (valueToUse != null) {\n                    this.eParentOfValue.innerHTML = _.escape(valueToUse);\n                }\n            }\n        }\n    };\n    CellComp.prototype.attemptCellRendererRefresh = function () {\n        if (_.missing(this.cellRenderer) || !this.cellRenderer || _.missing(this.cellRenderer.refresh)) {\n            return false;\n        }\n        // if the cell renderer has a refresh method, we call this instead of doing a refresh\n        var params = this.createCellRendererParams();\n        // take any custom params off of the user\n        var finalParams = this.beans.userComponentFactory.createFinalParams(this.getComponentHolder(), this.cellRendererType, params);\n        var result = this.cellRenderer.refresh(finalParams);\n        // NOTE on undefined: previous version of the cellRenderer.refresh() interface\n        // returned nothing, if the method existed, we assumed it refreshed. so for\n        // backwards compatibility, we assume if method exists and returns nothing,\n        // that it was successful.\n        return result === true || result === undefined;\n    };\n    CellComp.prototype.refreshToolTip = function () {\n        var newTooltip = this.getToolTip();\n        if (this.tooltip === newTooltip) {\n            return;\n        }\n        var hasNewTooltip = _.exists(newTooltip);\n        if (hasNewTooltip && this.tooltip === newTooltip.toString()) {\n            return;\n        }\n        var hadTooltip = _.exists(this.tooltip);\n        this.tooltip = newTooltip;\n        if (this.beans.gridOptionsWrapper.isEnableBrowserTooltips()) {\n            if (hasNewTooltip) {\n                this.eParentOfValue.setAttribute('title', this.tooltip);\n            }\n            else {\n                this.eParentOfValue.removeAttribute('title');\n            }\n        }\n    };\n    CellComp.prototype.valuesAreEqual = function (val1, val2) {\n        // if the user provided an equals method, use that, otherwise do simple comparison\n        var colDef = this.getComponentHolder();\n        var equalsMethod = colDef ? colDef.equals : null;\n        return equalsMethod ? equalsMethod(val1, val2) : val1 === val2;\n    };\n    CellComp.prototype.getToolTip = function () {\n        var colDef = this.getComponentHolder();\n        var data = this.rowNode.data;\n        if (colDef.tooltipField && _.exists(data)) {\n            return _.getValueUsingField(data, colDef.tooltipField, this.column.isTooltipFieldContainsDots());\n        }\n        var valueGetter = colDef.tooltipValueGetter || colDef.tooltip;\n        if (valueGetter) {\n            return valueGetter({\n                api: this.beans.gridOptionsWrapper.getApi(),\n                columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n                colDef: colDef,\n                column: this.getColumn(),\n                context: this.beans.gridOptionsWrapper.getContext(),\n                value: this.value,\n                valueFormatted: this.valueFormatted,\n                rowIndex: this.cellPosition.rowIndex,\n                node: this.rowNode,\n                data: this.rowNode.data\n            });\n        }\n        return null;\n    };\n    CellComp.prototype.getTooltipText = function (escape) {\n        if (escape === void 0) { escape = true; }\n        return escape ? _.escape(this.tooltip) : this.tooltip;\n    };\n    CellComp.prototype.processCellClassRules = function (onApplicableClass, onNotApplicableClass) {\n        var colDef = this.getComponentHolder();\n        this.beans.stylingService.processClassRules(colDef.cellClassRules, {\n            value: this.value,\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: colDef,\n            rowIndex: this.cellPosition.rowIndex,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            $scope: this.scope,\n            context: this.beans.gridOptionsWrapper.getContext()\n        }, onApplicableClass, onNotApplicableClass);\n    };\n    CellComp.prototype.postProcessCellClassRules = function () {\n        var _this = this;\n        this.processCellClassRules(function (className) { return _.addCssClass(_this.getGui(), className); }, function (className) { return _.removeCssClass(_this.getGui(), className); });\n    };\n    CellComp.prototype.preProcessCellClassRules = function () {\n        var res = [];\n        this.processCellClassRules(function (className) { return res.push(className); }, function (_) {\n            // not catered for, if creating, no need\n            // to remove class as it was never there\n        });\n        return res;\n    };\n    // a wrapper is used when we are putting a selection checkbox in the cell with the value\n    CellComp.prototype.setUsingWrapper = function () {\n        var colDef = this.getComponentHolder();\n        // never allow selection or dragging on pinned rows\n        if (this.rowNode.rowPinned) {\n            this.usingWrapper = false;\n            this.includeSelectionComponent = false;\n            this.includeRowDraggingComponent = false;\n            this.includeDndSourceComponent = false;\n            return;\n        }\n        var cbSelectionIsFunc = typeof colDef.checkboxSelection === 'function';\n        var rowDraggableIsFunc = typeof colDef.rowDrag === 'function';\n        var dndSourceIsFunc = typeof colDef.dndSource === 'function';\n        this.includeSelectionComponent = cbSelectionIsFunc || colDef.checkboxSelection === true;\n        this.includeRowDraggingComponent = rowDraggableIsFunc || colDef.rowDrag === true;\n        this.includeDndSourceComponent = dndSourceIsFunc || colDef.dndSource === true;\n        var enableTextSelection = this.beans.gridOptionsWrapper.isEnableCellTextSelection();\n        this.usingWrapper = enableTextSelection || this.includeRowDraggingComponent || this.includeSelectionComponent || this.includeDndSourceComponent;\n    };\n    CellComp.prototype.chooseCellRenderer = function () {\n        // template gets preference, then cellRenderer, then do it ourselves\n        var colDef = this.getComponentHolder();\n        // templates are for ng1, ideally we wouldn't have these, they are ng1 support\n        // inside the core which is bad\n        if (colDef.template || colDef.templateUrl) {\n            this.usingCellRenderer = false;\n            return;\n        }\n        var params = this.createCellRendererParams();\n        var cellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'cellRenderer', params);\n        var pinnedRowCellRenderer = this.beans.userComponentFactory.lookupComponentClassDef(colDef, 'pinnedRowCellRenderer', params);\n        if (pinnedRowCellRenderer && this.rowNode.rowPinned) {\n            this.cellRendererType = CellComp.CELL_RENDERER_TYPE_PINNED;\n            this.usingCellRenderer = true;\n        }\n        else if (cellRenderer) {\n            this.cellRendererType = CellComp.CELL_RENDERER_TYPE_NORMAL;\n            this.usingCellRenderer = true;\n        }\n        else {\n            this.usingCellRenderer = false;\n        }\n    };\n    CellComp.prototype.createCellRendererInstance = function (useTaskService) {\n        var _this = this;\n        if (useTaskService === void 0) { useTaskService = false; }\n        if (!this.usingCellRenderer) {\n            return;\n        }\n        // never use task service if angularCompileRows=true, as that assume the cell renderers\n        // are finished when the row is created. also we never use it if animation frame service\n        // is turned off.\n        // and lastly we never use it if doing auto-height, as the auto-height service checks the\n        // row height directly after the cell is created, it doesn't wait around for the tasks to complete\n        var angularCompileRows = this.beans.gridOptionsWrapper.isAngularCompileRows();\n        var suppressAnimationFrame = this.beans.gridOptionsWrapper.isSuppressAnimationFrame();\n        if (angularCompileRows || suppressAnimationFrame || this.autoHeightCell) {\n            useTaskService = false;\n        }\n        var params = this.createCellRendererParams();\n        this.cellRendererVersion++;\n        var callback = this.afterCellRendererCreated.bind(this, this.cellRendererVersion);\n        var cellRendererTypeNormal = this.cellRendererType === CellComp.CELL_RENDERER_TYPE_NORMAL;\n        this.createCellRendererFunc = function () {\n            _this.createCellRendererFunc = null;\n            // this can return null in the event that the user has switched from a renderer component to nothing, for example\n            // when using a cellRendererSelect to return a component or null depending on row data etc\n            var componentPromise = _this.beans.userComponentFactory.newCellRenderer(_this.getComponentHolder(), params, !cellRendererTypeNormal);\n            if (componentPromise) {\n                componentPromise.then(callback);\n            }\n        };\n        if (useTaskService) {\n            this.beans.taskQueue.createTask(this.createCellRendererFunc, this.rowNode.rowIndex, 'createTasksP2');\n        }\n        else {\n            this.createCellRendererFunc();\n        }\n    };\n    CellComp.prototype.afterCellRendererCreated = function (cellRendererVersion, cellRenderer) {\n        var cellRendererNotRequired = !this.isAlive() || (cellRendererVersion !== this.cellRendererVersion);\n        if (cellRendererNotRequired) {\n            this.beans.context.destroyBean(cellRenderer);\n            return;\n        }\n        this.cellRenderer = cellRenderer;\n        this.cellRendererGui = this.cellRenderer.getGui();\n        if (_.missing(this.cellRendererGui)) {\n            return;\n        }\n        // if async components, then it's possible the user started editing since this call was made\n        if (!this.editingCell) {\n            this.eParentOfValue.appendChild(this.cellRendererGui);\n        }\n    };\n    CellComp.prototype.createCellRendererParams = function () {\n        var _this = this;\n        return {\n            value: this.value,\n            valueFormatted: this.valueFormatted,\n            getValue: this.getValue.bind(this),\n            setValue: function (value) { return _this.beans.valueService.setValue(_this.rowNode, _this.column, value); },\n            formatValue: this.formatValue.bind(this),\n            data: this.rowNode.data,\n            node: this.rowNode,\n            colDef: this.getComponentHolder(),\n            column: this.column,\n            $scope: this.scope,\n            rowIndex: this.cellPosition.rowIndex,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            refreshCell: this.refreshCell.bind(this),\n            eGridCell: this.getGui(),\n            eParentOfValue: this.eParentOfValue,\n            // these bits are not documented anywhere, so we could drop them?\n            // it was in the olden days to allow user to register for when rendered\n            // row was removed (the row comp was removed), however now that the user\n            // can provide components for cells, the destroy method gets call when this\n            // happens so no longer need to fire event.\n            addRowCompListener: this.rowComp ? this.rowComp.addEventListener.bind(this.rowComp) : null,\n            addRenderedRowListener: function (eventType, listener) {\n                console.warn('ag-Grid: since ag-Grid .v11, params.addRenderedRowListener() is now params.addRowCompListener()');\n                if (_this.rowComp) {\n                    _this.rowComp.addEventListener(eventType, listener);\n                }\n            }\n        };\n    };\n    CellComp.prototype.formatValue = function (value) {\n        var valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, value);\n        return valueFormatted != null ? valueFormatted : value;\n    };\n    CellComp.prototype.getValueToUse = function () {\n        return this.valueFormatted != null ? this.valueFormatted : this.value;\n    };\n    CellComp.prototype.getValueAndFormat = function () {\n        this.value = this.getValue();\n        this.valueFormatted = this.beans.valueFormatterService.formatValue(this.column, this.rowNode, this.scope, this.value);\n    };\n    CellComp.prototype.getValue = function () {\n        // if we don't check this, then the grid will render leaf groups as open even if we are not\n        // allowing the user to open leaf groups. confused? remember for pivot mode we don't allow\n        // opening leaf groups, so we have to force leafGroups to be closed in case the user expanded\n        // them via the API, or user user expanded them in the UI before turning on pivot mode\n        var lockedClosedGroup = this.rowNode.leafGroup && this.beans.columnController.isPivotMode();\n        var isOpenGroup = this.rowNode.group && this.rowNode.expanded && !this.rowNode.footer && !lockedClosedGroup;\n        // are we showing group footers\n        var groupFootersEnabled = this.beans.gridOptionsWrapper.isGroupIncludeFooter();\n        // if doing footers, we normally don't show agg data at group level when group is open\n        var groupAlwaysShowAggData = this.beans.gridOptionsWrapper.isGroupSuppressBlankHeader();\n        // if doing grouping and footers, we don't want to include the agg value\n        // in the header when the group is open\n        var ignoreAggData = (isOpenGroup && groupFootersEnabled) && !groupAlwaysShowAggData;\n        return this.beans.valueService.getValue(this.column, this.rowNode, false, ignoreAggData);\n    };\n    CellComp.prototype.onMouseEvent = function (eventName, mouseEvent) {\n        if (_.isStopPropagationForAgGrid(mouseEvent)) {\n            return;\n        }\n        switch (eventName) {\n            case 'click':\n                this.onCellClicked(mouseEvent);\n                break;\n            case 'mousedown':\n                this.onMouseDown(mouseEvent);\n                break;\n            case 'dblclick':\n                this.onCellDoubleClicked(mouseEvent);\n                break;\n            case 'mouseout':\n                this.onMouseOut(mouseEvent);\n                break;\n            case 'mouseover':\n                this.onMouseOver(mouseEvent);\n                break;\n        }\n    };\n    CellComp.prototype.dispatchCellContextMenuEvent = function (event) {\n        var colDef = this.getComponentHolder();\n        var cellContextMenuEvent = this.createEvent(event, Events.EVENT_CELL_CONTEXT_MENU);\n        this.beans.eventService.dispatchEvent(cellContextMenuEvent);\n        if (colDef.onCellContextMenu) {\n            // to make the callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellContextMenu(cellContextMenuEvent); }, 0);\n        }\n    };\n    CellComp.prototype.createEvent = function (domEvent, eventType) {\n        var event = {\n            node: this.rowNode,\n            data: this.rowNode.data,\n            value: this.value,\n            column: this.column,\n            colDef: this.getComponentHolder(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            api: this.beans.gridApi,\n            columnApi: this.beans.columnApi,\n            rowPinned: this.rowNode.rowPinned,\n            event: domEvent,\n            type: eventType,\n            rowIndex: this.rowNode.rowIndex\n        };\n        // because we are hacking in $scope for angular 1, we have to de-reference\n        if (this.scope) {\n            event.$scope = this.scope;\n        }\n        return event;\n    };\n    CellComp.prototype.onMouseOut = function (mouseEvent) {\n        var cellMouseOutEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OUT);\n        this.beans.eventService.dispatchEvent(cellMouseOutEvent);\n        this.beans.columnHoverService.clearMouseOver();\n    };\n    CellComp.prototype.onMouseOver = function (mouseEvent) {\n        var cellMouseOverEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_OVER);\n        this.beans.eventService.dispatchEvent(cellMouseOverEvent);\n        this.beans.columnHoverService.setMouseOver([this.column]);\n    };\n    CellComp.prototype.onCellDoubleClicked = function (mouseEvent) {\n        var colDef = this.getComponentHolder();\n        // always dispatch event to eventService\n        var cellDoubleClickedEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_DOUBLE_CLICKED);\n        this.beans.eventService.dispatchEvent(cellDoubleClickedEvent);\n        // check if colDef also wants to handle event\n        if (typeof colDef.onCellDoubleClicked === 'function') {\n            // to make the callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellDoubleClicked(cellDoubleClickedEvent); }, 0);\n        }\n        var editOnDoubleClick = !this.beans.gridOptionsWrapper.isSingleClickEdit()\n            && !this.beans.gridOptionsWrapper.isSuppressClickEdit();\n        if (editOnDoubleClick) {\n            this.startRowOrCellEdit();\n        }\n    };\n    // called by rowRenderer when user navigates via tab key\n    CellComp.prototype.startRowOrCellEdit = function (keyPress, charPress) {\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n            this.rowComp.startRowEditing(keyPress, charPress, this);\n        }\n        else {\n            this.startEditingIfEnabled(keyPress, charPress, true);\n        }\n    };\n    CellComp.prototype.isCellEditable = function () {\n        return this.column.isCellEditable(this.rowNode);\n    };\n    // either called internally if single cell editing, or called by rowRenderer if row editing\n    CellComp.prototype.startEditingIfEnabled = function (keyPress, charPress, cellStartedEdit) {\n        if (keyPress === void 0) { keyPress = null; }\n        if (charPress === void 0) { charPress = null; }\n        if (cellStartedEdit === void 0) { cellStartedEdit = false; }\n        // don't do it if not editable\n        if (!this.isCellEditable()) {\n            return;\n        }\n        // don't do it if already editing\n        if (this.editingCell) {\n            return;\n        }\n        this.editingCell = true;\n        this.cellEditorVersion++;\n        var callback = this.afterCellEditorCreated.bind(this, this.cellEditorVersion);\n        var params = this.createCellEditorParams(keyPress, charPress, cellStartedEdit);\n        this.createCellEditor(params).then(callback);\n        // if we don't do this, and editor component is async, then there will be a period\n        // when the component isn't present and keyboard navigation won't work - so example\n        // of user hitting tab quickly (more quickly than renderers getting created) won't work\n        var cellEditorAsync = _.missing(this.cellEditor);\n        if (cellEditorAsync && cellStartedEdit) {\n            this.focusCell(true);\n        }\n    };\n    CellComp.prototype.createCellEditor = function (params) {\n        var _this = this;\n        var cellEditorPromise = this.beans.userComponentFactory.newCellEditor(this.column.getColDef(), params);\n        return cellEditorPromise.then(function (cellEditor) {\n            var isPopup = cellEditor.isPopup && cellEditor.isPopup();\n            if (!isPopup) {\n                return cellEditor;\n            }\n            if (_this.beans.gridOptionsWrapper.isFullRowEdit()) {\n                console.warn('ag-Grid: popup cellEditor does not work with fullRowEdit - you cannot use them both ' +\n                    '- either turn off fullRowEdit, or stop using popup editors.');\n            }\n            // if a popup, then we wrap in a popup editor and return the popup\n            var popupEditorWrapper = new PopupEditorWrapper(cellEditor);\n            _this.beans.context.createBean(popupEditorWrapper);\n            popupEditorWrapper.init(params);\n            return popupEditorWrapper;\n        });\n    };\n    CellComp.prototype.afterCellEditorCreated = function (cellEditorVersion, cellEditor) {\n        // if editingCell=false, means user cancelled the editor before component was ready.\n        // if versionMismatch, then user cancelled the edit, then started the edit again, and this\n        //   is the first editor which is now stale.\n        var versionMismatch = cellEditorVersion !== this.cellEditorVersion;\n        var cellEditorNotNeeded = versionMismatch || !this.editingCell;\n        if (cellEditorNotNeeded) {\n            this.beans.context.destroyBean(cellEditor);\n            return;\n        }\n        var editingCancelledByUserComp = cellEditor.isCancelBeforeStart && cellEditor.isCancelBeforeStart();\n        if (editingCancelledByUserComp) {\n            this.beans.context.destroyBean(cellEditor);\n            this.editingCell = false;\n            return;\n        }\n        if (!cellEditor.getGui) {\n            console.warn(\"ag-Grid: cellEditor for column \" + this.column.getId() + \" is missing getGui() method\");\n            // no getGui, for React guys, see if they attached a react component directly\n            if (cellEditor.render) {\n                console.warn(\"ag-Grid: we found 'render' on the component, are you trying to set a React renderer but added it as colDef.cellEditor instead of colDef.cellEditorFmk?\");\n            }\n            this.beans.context.destroyBean(cellEditor);\n            this.editingCell = false;\n            return;\n        }\n        this.cellEditor = cellEditor;\n        this.cellEditorInPopup = cellEditor.isPopup !== undefined && cellEditor.isPopup();\n        this.setInlineEditingClass();\n        if (this.cellEditorInPopup) {\n            this.addPopupCellEditor();\n        }\n        else {\n            this.addInCellEditor();\n        }\n        if (cellEditor.afterGuiAttached) {\n            cellEditor.afterGuiAttached();\n        }\n        var event = this.createEvent(null, Events.EVENT_CELL_EDITING_STARTED);\n        this.beans.eventService.dispatchEvent(event);\n    };\n    CellComp.prototype.addInCellEditor = function () {\n        _.clearElement(this.getGui());\n        if (this.cellEditor) {\n            this.getGui().appendChild(this.cellEditor.getGui());\n        }\n        this.angular1Compile();\n    };\n    CellComp.prototype.addPopupCellEditor = function () {\n        var _this = this;\n        var ePopupGui = this.cellEditor ? this.cellEditor.getGui() : null;\n        var useModelPopup = this.beans.gridOptionsWrapper.isStopEditingWhenGridLosesFocus();\n        this.hideEditorPopup = this.beans.popupService.addPopup(useModelPopup, ePopupGui, true, \n        // callback for when popup disappears\n        function () {\n            _this.onPopupEditorClosed();\n        });\n        var params = {\n            column: this.column,\n            rowNode: this.rowNode,\n            type: 'popupCellEditor',\n            eventSource: this.getGui(),\n            ePopup: ePopupGui,\n            keepWithinBounds: true\n        };\n        var position = this.cellEditor && this.cellEditor.getPopupPosition ? this.cellEditor.getPopupPosition() : 'over';\n        if (position === 'under') {\n            this.beans.popupService.positionPopupUnderComponent(params);\n        }\n        else {\n            this.beans.popupService.positionPopupOverComponent(params);\n        }\n        this.angular1Compile();\n    };\n    CellComp.prototype.onPopupEditorClosed = function () {\n        // we only call stopEditing if we are editing, as\n        // it's possible the popup called 'stop editing'\n        // before this, eg if 'enter key' was pressed on\n        // the editor.\n        if (this.editingCell) {\n            // note: this only happens when use clicks outside of the grid. if use clicks on another\n            // cell, then the editing will have already stopped on this cell\n            this.stopRowOrCellEdit();\n            // we only focus cell again if this cell is still focused. it is possible\n            // it is not focused if the user cancelled the edit by clicking on another\n            // cell outside of this one\n            if (this.beans.focusController.isCellFocused(this.cellPosition)) {\n                this.focusCell(true);\n            }\n        }\n    };\n    // if we are editing inline, then we don't have the padding in the cell (set in the themes)\n    // to allow the text editor full access to the entire cell\n    CellComp.prototype.setInlineEditingClass = function () {\n        if (!this.isAlive()) {\n            return;\n        }\n        // ag-cell-inline-editing - appears when user is inline editing\n        // ag-cell-not-inline-editing - appears when user is no inline editing\n        // ag-cell-popup-editing - appears when user is editing cell in popup (appears on the cell, not on the popup)\n        // note: one of {ag-cell-inline-editing, ag-cell-not-inline-editing} is always present, they toggle.\n        //       however {ag-cell-popup-editing} shows when popup, so you have both {ag-cell-popup-editing}\n        //       and {ag-cell-not-inline-editing} showing at the same time.\n        var editingInline = this.editingCell && !this.cellEditorInPopup;\n        var popupEditorShowing = this.editingCell && this.cellEditorInPopup;\n        _.addOrRemoveCssClass(this.getGui(), \"ag-cell-inline-editing\", editingInline);\n        _.addOrRemoveCssClass(this.getGui(), \"ag-cell-not-inline-editing\", !editingInline);\n        _.addOrRemoveCssClass(this.getGui(), \"ag-cell-popup-editing\", popupEditorShowing);\n        _.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-inline-editing\", editingInline);\n        _.addOrRemoveCssClass(this.getGui().parentNode, \"ag-row-not-inline-editing\", !editingInline);\n    };\n    CellComp.prototype.createCellEditorParams = function (keyPress, charPress, cellStartedEdit) {\n        return {\n            value: this.getValue(),\n            keyPress: keyPress,\n            charPress: charPress,\n            column: this.column,\n            colDef: this.column.getColDef(),\n            rowIndex: this.cellPosition.rowIndex,\n            node: this.rowNode,\n            data: this.rowNode.data,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            cellStartedEdit: cellStartedEdit,\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext(),\n            $scope: this.scope,\n            onKeyDown: this.onKeyDown.bind(this),\n            stopEditing: this.stopEditingAndFocus.bind(this),\n            eGridCell: this.getGui(),\n            parseValue: this.parseValue.bind(this),\n            formatValue: this.formatValue.bind(this)\n        };\n    };\n    // cell editors call this, when they want to stop for reasons other\n    // than what we pick up on. eg selecting from a dropdown ends editing.\n    CellComp.prototype.stopEditingAndFocus = function (suppressNavigateAfterEdit) {\n        if (suppressNavigateAfterEdit === void 0) { suppressNavigateAfterEdit = false; }\n        this.stopRowOrCellEdit();\n        this.focusCell(true);\n        if (!suppressNavigateAfterEdit) {\n            this.navigateAfterEdit();\n        }\n    };\n    CellComp.prototype.parseValue = function (newValue) {\n        var colDef = this.getComponentHolder();\n        var params = {\n            node: this.rowNode,\n            data: this.rowNode.data,\n            oldValue: this.value,\n            newValue: newValue,\n            colDef: colDef,\n            column: this.column,\n            api: this.beans.gridOptionsWrapper.getApi(),\n            columnApi: this.beans.gridOptionsWrapper.getColumnApi(),\n            context: this.beans.gridOptionsWrapper.getContext()\n        };\n        var valueParser = colDef.valueParser;\n        return _.exists(valueParser) ? this.beans.expressionService.evaluate(valueParser, params) : newValue;\n    };\n    CellComp.prototype.focusCell = function (forceBrowserFocus) {\n        if (forceBrowserFocus === void 0) { forceBrowserFocus = false; }\n        this.beans.focusController.setFocusedCell(this.cellPosition.rowIndex, this.column, this.rowNode.rowPinned, forceBrowserFocus);\n    };\n    CellComp.prototype.setFocusInOnEditor = function () {\n        if (this.editingCell) {\n            if (this.cellEditor && this.cellEditor.focusIn) {\n                // if the editor is present, then we just focus it\n                this.cellEditor.focusIn();\n            }\n            else {\n                // if the editor is not present, it means async cell editor (eg React fibre)\n                // and we are trying to set focus before the cell editor is present, so we\n                // focus the cell instead\n                this.focusCell(true);\n            }\n        }\n    };\n    CellComp.prototype.isEditing = function () {\n        return this.editingCell;\n    };\n    CellComp.prototype.onKeyDown = function (event) {\n        var key = event.which || event.keyCode;\n        switch (key) {\n            case Constants.KEY_ENTER:\n                this.onEnterKeyDown(event);\n                break;\n            case Constants.KEY_F2:\n                this.onF2KeyDown();\n                break;\n            case Constants.KEY_ESCAPE:\n                this.onEscapeKeyDown();\n                break;\n            case Constants.KEY_TAB:\n                this.onTabKeyDown(event);\n                break;\n            case Constants.KEY_BACKSPACE:\n            case Constants.KEY_DELETE:\n                this.onBackspaceOrDeleteKeyPressed(key);\n                break;\n            case Constants.KEY_DOWN:\n            case Constants.KEY_UP:\n            case Constants.KEY_RIGHT:\n            case Constants.KEY_LEFT:\n                this.onNavigationKeyPressed(event, key);\n                break;\n        }\n    };\n    CellComp.prototype.setFocusOutOnEditor = function () {\n        if (this.editingCell && this.cellEditor && this.cellEditor.focusOut) {\n            this.cellEditor.focusOut();\n        }\n    };\n    CellComp.prototype.onNavigationKeyPressed = function (event, key) {\n        if (this.editingCell) {\n            return;\n        }\n        if (event.shiftKey && this.rangeSelectionEnabled) {\n            this.onShiftRangeSelect(key);\n        }\n        else {\n            this.beans.rowRenderer.navigateToNextCell(event, key, this.cellPosition, true);\n        }\n        // if we don't prevent default, the grid will scroll with the navigation keys\n        event.preventDefault();\n    };\n    CellComp.prototype.onShiftRangeSelect = function (key) {\n        if (!this.beans.rangeController) {\n            return;\n        }\n        var endCell = this.beans.rangeController.extendLatestRangeInDirection(key);\n        if (endCell) {\n            this.beans.rowRenderer.ensureCellVisible(endCell);\n        }\n    };\n    CellComp.prototype.onTabKeyDown = function (event) {\n        this.beans.rowRenderer.onTabKeyDown(this, event);\n    };\n    CellComp.prototype.onBackspaceOrDeleteKeyPressed = function (key) {\n        if (!this.editingCell) {\n            this.startRowOrCellEdit(key);\n        }\n    };\n    CellComp.prototype.onEnterKeyDown = function (e) {\n        if (this.editingCell || this.rowComp.isEditing()) {\n            this.stopEditingAndFocus();\n        }\n        else {\n            if (this.beans.gridOptionsWrapper.isEnterMovesDown()) {\n                this.beans.rowRenderer.navigateToNextCell(null, Constants.KEY_DOWN, this.cellPosition, false);\n            }\n            else {\n                e.preventDefault();\n                this.startRowOrCellEdit(Constants.KEY_ENTER);\n            }\n        }\n    };\n    CellComp.prototype.navigateAfterEdit = function () {\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n        if (fullRowEdit) {\n            return;\n        }\n        var enterMovesDownAfterEdit = this.beans.gridOptionsWrapper.isEnterMovesDownAfterEdit();\n        if (enterMovesDownAfterEdit) {\n            this.beans.rowRenderer.navigateToNextCell(null, Constants.KEY_DOWN, this.cellPosition, false);\n        }\n    };\n    CellComp.prototype.onF2KeyDown = function () {\n        if (!this.editingCell) {\n            this.startRowOrCellEdit(Constants.KEY_F2);\n        }\n    };\n    CellComp.prototype.onEscapeKeyDown = function () {\n        if (this.editingCell) {\n            this.stopRowOrCellEdit(true);\n            this.focusCell(true);\n        }\n    };\n    CellComp.prototype.onKeyPress = function (event) {\n        // check this, in case focus is on a (for example) a text field inside the cell,\n        // in which cse we should not be listening for these key pressed\n        var eventTarget = _.getTarget(event);\n        var eventOnChildComponent = eventTarget !== this.getGui();\n        if (eventOnChildComponent || this.editingCell) {\n            return;\n        }\n        var pressedChar = String.fromCharCode(event.charCode);\n        if (pressedChar === ' ') {\n            this.onSpaceKeyPressed(event);\n        }\n        else if (_.isEventFromPrintableCharacter(event)) {\n            this.startRowOrCellEdit(null, pressedChar);\n            // if we don't prevent default, then the keypress also gets applied to the text field\n            // (at least when doing the default editor), but we need to allow the editor to decide\n            // what it wants to do. we only do this IF editing was started - otherwise it messes\n            // up when the use is not doing editing, but using rendering with text fields in cellRenderer\n            // (as it would block the the user from typing into text fields).\n            event.preventDefault();\n        }\n    };\n    CellComp.prototype.onSpaceKeyPressed = function (event) {\n        var gridOptionsWrapper = this.beans.gridOptionsWrapper;\n        if (!this.editingCell && gridOptionsWrapper.isRowSelection()) {\n            var newSelection = !this.rowNode.isSelected();\n            if (newSelection || gridOptionsWrapper.isRowDeselection()) {\n                this.rowNode.setSelected(newSelection);\n            }\n        }\n        // prevent default as space key, by default, moves browser scroll down\n        event.preventDefault();\n    };\n    CellComp.prototype.onMouseDown = function (mouseEvent) {\n        var ctrlKey = mouseEvent.ctrlKey, metaKey = mouseEvent.metaKey, shiftKey = mouseEvent.shiftKey;\n        var target = mouseEvent.target;\n        var _a = this.beans, eventService = _a.eventService, rangeController = _a.rangeController;\n        // do not change the range for right-clicks inside an existing range\n        if (this.isRightClickInExistingRange(mouseEvent)) {\n            return;\n        }\n        if (!shiftKey || (rangeController && !rangeController.getCellRanges().length)) {\n            // We only need to pass true to focusCell when the browser is IE/Edge and we are trying\n            // to focus the cell itself. This should never be true if the mousedown was triggered\n            // due to a click on a cell editor for example.\n            var forceBrowserFocus = (_.isBrowserIE() || _.isBrowserEdge()) && !this.editingCell;\n            this.focusCell(forceBrowserFocus);\n        }\n        else {\n            // if a range is being changed, we need to make sure the focused cell does not change.\n            mouseEvent.preventDefault();\n        }\n        // if we are clicking on a checkbox, we need to make sure the cell wrapping that checkbox\n        // is focused but we don't want to change the range selection, so return here.\n        if (this.containsWidget(target)) {\n            return;\n        }\n        if (rangeController) {\n            var thisCell = this.cellPosition;\n            if (shiftKey) {\n                rangeController.extendLatestRangeToCell(thisCell);\n            }\n            else {\n                var ctrlKeyPressed = ctrlKey || metaKey;\n                rangeController.setRangeToCell(thisCell, ctrlKeyPressed);\n            }\n        }\n        eventService.dispatchEvent(this.createEvent(mouseEvent, Events.EVENT_CELL_MOUSE_DOWN));\n    };\n    CellComp.prototype.isRightClickInExistingRange = function (mouseEvent) {\n        var rangeController = this.beans.rangeController;\n        if (rangeController) {\n            var cellInRange = rangeController.isCellInAnyRange(this.getCellPosition());\n            if (cellInRange && mouseEvent.button === 2) {\n                return true;\n            }\n        }\n        return false;\n    };\n    CellComp.prototype.containsWidget = function (target) {\n        return _.isElementChildOfClass(target, 'ag-selection-checkbox', 3);\n    };\n    // returns true if on iPad and this is second 'click' event in 200ms\n    CellComp.prototype.isDoubleClickOnIPad = function () {\n        if (!_.isIOSUserAgent() || _.isEventSupported('dblclick')) {\n            return false;\n        }\n        var nowMillis = new Date().getTime();\n        var res = nowMillis - this.lastIPadMouseClickEvent < 200;\n        this.lastIPadMouseClickEvent = nowMillis;\n        return res;\n    };\n    CellComp.prototype.onCellClicked = function (mouseEvent) {\n        // iPad doesn't have double click - so we need to mimic it to enable editing for iPad.\n        if (this.isDoubleClickOnIPad()) {\n            this.onCellDoubleClicked(mouseEvent);\n            mouseEvent.preventDefault(); // if we don't do this, then iPad zooms in\n            return;\n        }\n        var _a = this.beans, eventService = _a.eventService, gridOptionsWrapper = _a.gridOptionsWrapper;\n        var cellClickedEvent = this.createEvent(mouseEvent, Events.EVENT_CELL_CLICKED);\n        eventService.dispatchEvent(cellClickedEvent);\n        var colDef = this.getComponentHolder();\n        if (colDef.onCellClicked) {\n            // to make callback async, do in a timeout\n            window.setTimeout(function () { return colDef.onCellClicked(cellClickedEvent); }, 0);\n        }\n        var editOnSingleClick = (gridOptionsWrapper.isSingleClickEdit() || colDef.singleClickEdit)\n            && !gridOptionsWrapper.isSuppressClickEdit();\n        if (editOnSingleClick) {\n            this.startRowOrCellEdit();\n        }\n    };\n    CellComp.prototype.createGridCellVo = function () {\n        this.cellPosition = {\n            rowIndex: this.rowNode.rowIndex,\n            rowPinned: this.rowNode.rowPinned,\n            column: this.column\n        };\n    };\n    CellComp.prototype.getCellPosition = function () {\n        return this.cellPosition;\n    };\n    CellComp.prototype.getParentRow = function () {\n        return this.eParentRow;\n    };\n    CellComp.prototype.setParentRow = function (eParentRow) {\n        this.eParentRow = eParentRow;\n    };\n    CellComp.prototype.getColumn = function () {\n        return this.column;\n    };\n    CellComp.prototype.getComponentHolder = function () {\n        return this.column.getColDef();\n    };\n    CellComp.prototype.detach = function () {\n        this.eParentRow.removeChild(this.getGui());\n    };\n    // if the row is also getting destroyed, then we don't need to remove from dom,\n    // as the row will also get removed, so no need to take out the cells from the row\n    // if the row is going (removing is an expensive operation, so only need to remove\n    // the top part)\n    //\n    // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.\n    CellComp.prototype.destroy = function () {\n        if (this.createCellRendererFunc) {\n            this.beans.taskQueue.cancelTask(this.createCellRendererFunc);\n        }\n        this.stopEditing();\n        this.cellRenderer = this.beans.context.destroyBean(this.cellRenderer);\n        this.beans.context.destroyBean(this.selectionHandle);\n        _super.prototype.destroy.call(this);\n    };\n    CellComp.prototype.onLeftChanged = function () {\n        var left = this.modifyLeftForPrintLayout(this.getCellLeft());\n        this.getGui().style.left = left + 'px';\n        this.refreshAriaIndex();\n    };\n    CellComp.prototype.modifyLeftForPrintLayout = function (leftPosition) {\n        if (!this.printLayout || this.column.getPinned() === Constants.PINNED_LEFT) {\n            return leftPosition;\n        }\n        if (this.column.getPinned() === Constants.PINNED_RIGHT) {\n            var leftWidth_1 = this.beans.columnController.getPinnedLeftContainerWidth();\n            var bodyWidth = this.beans.columnController.getBodyContainerWidth();\n            return leftWidth_1 + bodyWidth + leftPosition;\n        }\n        // is in body\n        var leftWidth = this.beans.columnController.getPinnedLeftContainerWidth();\n        return leftWidth + leftPosition;\n    };\n    CellComp.prototype.onWidthChanged = function () {\n        var width = this.getCellWidth();\n        this.getGui().style.width = width + 'px';\n    };\n    CellComp.prototype.getRangeBorders = function () {\n        var _this = this;\n        var isRtl = this.beans.gridOptionsWrapper.isEnableRtl();\n        var top = false;\n        var right = false;\n        var bottom = false;\n        var left = false;\n        var thisCol = this.cellPosition.column;\n        var _a = this.beans, rangeController = _a.rangeController, columnController = _a.columnController;\n        var leftCol;\n        var rightCol;\n        if (isRtl) {\n            leftCol = columnController.getDisplayedColAfter(thisCol);\n            rightCol = columnController.getDisplayedColBefore(thisCol);\n        }\n        else {\n            leftCol = columnController.getDisplayedColBefore(thisCol);\n            rightCol = columnController.getDisplayedColAfter(thisCol);\n        }\n        var ranges = rangeController.getCellRanges().filter(function (range) { return rangeController.isCellInSpecificRange(_this.cellPosition, range); });\n        // this means we are the first column in the grid\n        if (!leftCol) {\n            left = true;\n        }\n        // this means we are the last column in the grid\n        if (!rightCol) {\n            right = true;\n        }\n        for (var i = 0; i < ranges.length; i++) {\n            if (top && right && bottom && left) {\n                break;\n            }\n            var range = ranges[i];\n            var startRow = rangeController.getRangeStartRow(range);\n            var endRow = rangeController.getRangeEndRow(range);\n            if (!top && this.beans.rowPositionUtils.sameRow(startRow, this.cellPosition)) {\n                top = true;\n            }\n            if (!bottom && this.beans.rowPositionUtils.sameRow(endRow, this.cellPosition)) {\n                bottom = true;\n            }\n            if (!left && range.columns.indexOf(leftCol) < 0) {\n                left = true;\n            }\n            if (!right && range.columns.indexOf(rightCol) < 0) {\n                right = true;\n            }\n        }\n        return { top: top, right: right, bottom: bottom, left: left };\n    };\n    CellComp.prototype.getInitialRangeClasses = function () {\n        var classes = [];\n        if (!this.rangeSelectionEnabled || !this.rangeCount) {\n            return classes;\n        }\n        classes.push('ag-cell-range-selected');\n        if (this.hasChartRange) {\n            classes.push('ag-cell-range-chart');\n        }\n        var count = Math.min(this.rangeCount, 4);\n        classes.push(\"ag-cell-range-selected-\" + count);\n        if (this.isSingleCell()) {\n            classes.push('ag-cell-range-single-cell');\n        }\n        if (this.rangeCount > 0) {\n            var borders = this.getRangeBorders();\n            if (borders.top) {\n                classes.push('ag-cell-range-top');\n            }\n            if (borders.right) {\n                classes.push('ag-cell-range-right');\n            }\n            if (borders.bottom) {\n                classes.push('ag-cell-range-bottom');\n            }\n            if (borders.left) {\n                classes.push('ag-cell-range-left');\n            }\n        }\n        if (!!this.selectionHandle) {\n            classes.push('ag-cell-range-handle');\n        }\n        return classes;\n    };\n    CellComp.prototype.onRowIndexChanged = function () {\n        // when index changes, this influences items that need the index, so we update the\n        // grid cell so they are working off the new index.\n        this.createGridCellVo();\n        // when the index of the row changes, ie means the cell may have lost or gained focus\n        this.onCellFocused();\n        // check range selection\n        this.onRangeSelectionChanged();\n    };\n    CellComp.prototype.onRangeSelectionChanged = function () {\n        var rangeController = this.beans.rangeController;\n        if (!rangeController) {\n            return;\n        }\n        var _a = this, cellPosition = _a.cellPosition, rangeCount = _a.rangeCount;\n        var newRangeCount = rangeController.getCellRangeCount(cellPosition);\n        var element = this.getGui();\n        if (rangeCount !== newRangeCount) {\n            _.addOrRemoveCssClass(element, 'ag-cell-range-selected', newRangeCount !== 0);\n            _.addOrRemoveCssClass(element, 'ag-cell-range-selected-1', newRangeCount === 1);\n            _.addOrRemoveCssClass(element, 'ag-cell-range-selected-2', newRangeCount === 2);\n            _.addOrRemoveCssClass(element, 'ag-cell-range-selected-3', newRangeCount === 3);\n            _.addOrRemoveCssClass(element, 'ag-cell-range-selected-4', newRangeCount >= 4);\n            this.rangeCount = newRangeCount;\n        }\n        var hasChartRange = this.getHasChartRange();\n        if (hasChartRange !== this.hasChartRange) {\n            this.hasChartRange = hasChartRange;\n            _.addOrRemoveCssClass(element, 'ag-cell-range-chart', this.hasChartRange);\n        }\n        this.updateRangeBorders();\n        _.addOrRemoveCssClass(element, 'ag-cell-range-single-cell', this.isSingleCell());\n        this.refreshHandle();\n    };\n    CellComp.prototype.getHasChartRange = function () {\n        var rangeController = this.beans.rangeController;\n        if (!this.rangeCount || !rangeController) {\n            return false;\n        }\n        var cellRanges = rangeController.getCellRanges();\n        return cellRanges.length > 0 && cellRanges.every(function (range) { return _.includes([CellRangeType.DIMENSION, CellRangeType.VALUE], range.type); });\n    };\n    CellComp.prototype.shouldHaveSelectionHandle = function () {\n        var _a = this.beans, gridOptionsWrapper = _a.gridOptionsWrapper, rangeController = _a.rangeController;\n        var cellRanges = rangeController.getCellRanges();\n        var rangesLen = cellRanges.length;\n        if (this.rangeCount < 1 || rangesLen < 1) {\n            return false;\n        }\n        var cellRange = _.last(cellRanges);\n        var cellPosition = this.getCellPosition();\n        var fillHandleIsAvailable = rangesLen === 1 &&\n            (gridOptionsWrapper.isEnableFillHandle() || gridOptionsWrapper.isEnableRangeHandle()) &&\n            !this.editingCell;\n        if (this.hasChartRange) {\n            var hasCategoryRange = cellRanges[0].type === CellRangeType.DIMENSION;\n            var isCategoryCell = hasCategoryRange && rangeController.isCellInSpecificRange(cellPosition, cellRanges[0]);\n            _.addOrRemoveCssClass(this.getGui(), 'ag-cell-range-chart-category', isCategoryCell);\n            fillHandleIsAvailable = cellRange.type === CellRangeType.VALUE;\n        }\n        return fillHandleIsAvailable &&\n            cellRange.endRow != null &&\n            rangeController.isContiguousRange(cellRange) &&\n            rangeController.isBottomRightCell(cellRange, cellPosition);\n    };\n    CellComp.prototype.addSelectionHandle = function () {\n        var _a = this.beans, gridOptionsWrapper = _a.gridOptionsWrapper, context = _a.context, rangeController = _a.rangeController;\n        var cellRangeType = _.last(rangeController.getCellRanges()).type;\n        var selectionHandleFill = gridOptionsWrapper.isEnableFillHandle() && _.missing(cellRangeType);\n        var type = selectionHandleFill ? SelectionHandleType.FILL : SelectionHandleType.RANGE;\n        if (this.selectionHandle && this.selectionHandle.getType() !== type) {\n            this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);\n        }\n        if (!this.selectionHandle) {\n            this.selectionHandle = this.beans.selectionHandleFactory.createSelectionHandle(type);\n        }\n        this.selectionHandle.refresh(this);\n    };\n    CellComp.prototype.updateRangeBordersIfRangeCount = function () {\n        // we only need to update range borders if we are in a range\n        if (this.rangeCount > 0) {\n            this.updateRangeBorders();\n            this.refreshHandle();\n        }\n    };\n    CellComp.prototype.refreshHandle = function () {\n        if (!this.beans.rangeController) {\n            return;\n        }\n        var shouldHaveSelectionHandle = this.shouldHaveSelectionHandle();\n        if (this.selectionHandle && !shouldHaveSelectionHandle) {\n            this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle);\n        }\n        if (shouldHaveSelectionHandle) {\n            this.addSelectionHandle();\n        }\n        _.addOrRemoveCssClass(this.getGui(), 'ag-cell-range-handle', !!this.selectionHandle);\n    };\n    CellComp.prototype.updateRangeBorders = function () {\n        var rangeBorders = this.getRangeBorders();\n        var isSingleCell = this.isSingleCell();\n        var isTop = !isSingleCell && rangeBorders.top;\n        var isRight = !isSingleCell && rangeBorders.right;\n        var isBottom = !isSingleCell && rangeBorders.bottom;\n        var isLeft = !isSingleCell && rangeBorders.left;\n        var element = this.getGui();\n        _.addOrRemoveCssClass(element, 'ag-cell-range-top', isTop);\n        _.addOrRemoveCssClass(element, 'ag-cell-range-right', isRight);\n        _.addOrRemoveCssClass(element, 'ag-cell-range-bottom', isBottom);\n        _.addOrRemoveCssClass(element, 'ag-cell-range-left', isLeft);\n    };\n    CellComp.prototype.onFirstRightPinnedChanged = function () {\n        var firstRightPinned = this.column.isFirstRightPinned();\n        if (this.firstRightPinned !== firstRightPinned) {\n            this.firstRightPinned = firstRightPinned;\n            _.addOrRemoveCssClass(this.getGui(), 'ag-cell-first-right-pinned', firstRightPinned);\n        }\n    };\n    CellComp.prototype.onLastLeftPinnedChanged = function () {\n        var lastLeftPinned = this.column.isLastLeftPinned();\n        if (this.lastLeftPinned !== lastLeftPinned) {\n            this.lastLeftPinned = lastLeftPinned;\n            _.addOrRemoveCssClass(this.getGui(), 'ag-cell-last-left-pinned', lastLeftPinned);\n        }\n    };\n    CellComp.prototype.populateTemplate = function () {\n        if (this.usingWrapper) {\n            this.eParentOfValue = this.getRefElement('eCellValue');\n            this.eCellWrapper = this.getRefElement('eCellWrapper');\n            this.eCellValue = this.getRefElement('eCellValue');\n            if (this.includeRowDraggingComponent) {\n                this.addRowDragging();\n            }\n            if (this.includeDndSourceComponent) {\n                this.addDndSource();\n            }\n            if (this.includeSelectionComponent) {\n                this.addSelectionCheckbox();\n            }\n        }\n        else {\n            this.eParentOfValue = this.getGui();\n        }\n    };\n    CellComp.prototype.getFrameworkOverrides = function () {\n        return this.beans.frameworkOverrides;\n    };\n    CellComp.prototype.addRowDragging = function () {\n        var pagination = this.beans.gridOptionsWrapper.isPagination();\n        var rowDragManaged = this.beans.gridOptionsWrapper.isRowDragManaged();\n        var clientSideRowModelActive = this.beans.gridOptionsWrapper.isRowModelDefault();\n        if (rowDragManaged) {\n            // row dragging only available in default row model\n            if (!clientSideRowModelActive) {\n                _.doOnce(function () { return console.warn('ag-Grid: managed row dragging is only allowed in the Client Side Row Model'); }, 'CellComp.addRowDragging');\n                return;\n            }\n            if (pagination) {\n                _.doOnce(function () { return console.warn('ag-Grid: managed row dragging is not possible when doing pagination'); }, 'CellComp.addRowDragging');\n                return;\n            }\n        }\n        var rowDraggingComp = new RowDragComp(this.rowNode, this.column, this.getValueToUse(), this.beans);\n        this.createManagedBean(rowDraggingComp, this.beans.context);\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(rowDraggingComp.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addDndSource = function () {\n        var dndSourceComp = new DndSourceComp(this.rowNode, this.column, this.getValueToUse(), this.beans, this.getGui());\n        this.createManagedBean(dndSourceComp, this.beans.context);\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(dndSourceComp.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addSelectionCheckbox = function () {\n        var _this = this;\n        var cbSelectionComponent = new CheckboxSelectionComponent();\n        this.beans.context.createBean(cbSelectionComponent);\n        var visibleFunc = this.getComponentHolder().checkboxSelection;\n        visibleFunc = typeof visibleFunc === 'function' ? visibleFunc : null;\n        cbSelectionComponent.init({ rowNode: this.rowNode, column: this.column, visibleFunc: visibleFunc });\n        this.addDestroyFunc(function () { return _this.beans.context.destroyBean(cbSelectionComponent); });\n        // put the checkbox in before the value\n        this.eCellWrapper.insertBefore(cbSelectionComponent.getGui(), this.eParentOfValue);\n    };\n    CellComp.prototype.addDomData = function () {\n        var _this = this;\n        var element = this.getGui();\n        this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, this);\n        this.addDestroyFunc(function () { return _this.beans.gridOptionsWrapper.setDomData(element, CellComp.DOM_DATA_KEY_CELL_COMP, null); });\n    };\n    CellComp.prototype.isSingleCell = function () {\n        var rangeController = this.beans.rangeController;\n        return this.rangeCount === 1 && rangeController && !rangeController.isMoreThanOneCell();\n    };\n    CellComp.prototype.onCellFocused = function (event) {\n        var cellFocused = this.beans.focusController.isCellFocused(this.cellPosition);\n        // see if we need to change the classes on this cell\n        if (cellFocused !== this.cellFocused) {\n            // if we are not doing cell selection, then the focus class does not change\n            var doingFocusCss = !this.beans.gridOptionsWrapper.isSuppressCellSelection();\n            if (doingFocusCss) {\n                _.addOrRemoveCssClass(this.getGui(), 'ag-cell-focus', cellFocused);\n            }\n            this.cellFocused = cellFocused;\n        }\n        // see if we need to force browser focus - this can happen if focus is programmatically set\n        if (cellFocused && event && event.forceBrowserFocus) {\n            var focusEl = this.getFocusableElement();\n            focusEl.focus();\n            // Fix for AG-3465 \"IE11 - After editing cell's content, selection doesn't go one cell below on enter\"\n            // IE can fail to focus the cell after the first call to focus(), and needs a second call\n            if (!document.activeElement || document.activeElement === document.body) {\n                focusEl.focus();\n            }\n        }\n        // if another cell was focused, and we are editing, then stop editing\n        var fullRowEdit = this.beans.gridOptionsWrapper.isFullRowEdit();\n        if (!cellFocused && !fullRowEdit && this.editingCell) {\n            this.stopRowOrCellEdit();\n        }\n    };\n    // pass in 'true' to cancel the editing.\n    CellComp.prototype.stopRowOrCellEdit = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        if (this.beans.gridOptionsWrapper.isFullRowEdit()) {\n            this.rowComp.stopRowEditing(cancel);\n        }\n        else {\n            this.stopEditing(cancel);\n        }\n    };\n    CellComp.prototype.stopEditing = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        if (!this.editingCell) {\n            return;\n        }\n        // if no cell editor, this means due to async, that the cell editor never got initialised,\n        // so we just carry on regardless as if the editing was never started.\n        if (!this.cellEditor) {\n            this.editingCell = false;\n            return;\n        }\n        var oldValue = this.getValue();\n        var newValueExists = false;\n        var newValue;\n        if (!cancel) {\n            // also have another option here to cancel after editing, so for example user could have a popup editor and\n            // it is closed by user clicking outside the editor. then the editor will close automatically (with false\n            // passed above) and we need to see if the editor wants to accept the new value.\n            var userWantsToCancel = this.cellEditor.isCancelAfterEnd && this.cellEditor.isCancelAfterEnd();\n            if (!userWantsToCancel) {\n                newValue = this.cellEditor.getValue();\n                newValueExists = true;\n            }\n        }\n        // it is important we set this after setValue() above, as otherwise the cell will flash\n        // when editing stops. the 'refresh' method checks editing, and doesn't refresh editing cells.\n        // thus it will skip the refresh on this cell until the end of this method where we call\n        // refresh directly and we suppress the flash.\n        this.editingCell = false;\n        // important to clear this out - as parts of the code will check for\n        // this to see if an async cellEditor has yet to be created\n        this.cellEditor = this.beans.context.destroyBean(this.cellEditor);\n        this.cellEditor = null;\n        if (this.cellEditorInPopup && this.hideEditorPopup) {\n            this.hideEditorPopup();\n            this.hideEditorPopup = null;\n        }\n        else {\n            _.clearElement(this.getGui());\n            // put the cell back the way it was before editing\n            if (this.usingWrapper) {\n                // if wrapper, then put the wrapper back\n                this.getGui().appendChild(this.eCellWrapper);\n            }\n            else if (this.cellRenderer) {\n                // if cellRenderer, then put the gui back in. if the renderer has\n                // a refresh, it will be called. however if it doesn't, then later\n                // the renderer will be destroyed and a new one will be created.\n                // we know it's a dom element (not a string) because we converted\n                // it after the gui was attached if it was a string.\n                var eCell = this.cellRendererGui;\n                // can be null if cell was previously null / contained empty string,\n                // this will result in new value not being rendered.\n                if (eCell) {\n                    this.getGui().appendChild(eCell);\n                }\n            }\n        }\n        this.setInlineEditingClass();\n        this.refreshHandle();\n        if (newValueExists && newValue !== oldValue) {\n            // we suppressRefreshCell because the call to rowNode.setDataValue() results in change detection\n            // getting triggered, which results in all cells getting refreshed. we do not want this refresh\n            // to happen on this call as we want to call it explicitly below. otherwise refresh gets called twice.\n            // if we only did this refresh (and not the one below) then the cell would flash and not be forced.\n            this.suppressRefreshCell = true;\n            this.rowNode.setDataValue(this.column, newValue);\n            this.suppressRefreshCell = false;\n        }\n        // we suppress the flash, as it is not correct to flash the cell the user has finished editing,\n        // the user doesn't need to flash as they were the one who did the edit, the flash is pointless\n        // (as the flash is meant to draw the user to a change that they didn't manually do themselves).\n        this.refreshCell({ forceRefresh: true, suppressFlash: true });\n        var event = this.createEvent(null, Events.EVENT_CELL_EDITING_STOPPED);\n        this.beans.eventService.dispatchEvent(event);\n    };\n    CellComp.DOM_DATA_KEY_CELL_COMP = 'cellComp';\n    CellComp.CELL_RENDERER_TYPE_NORMAL = 'cellRenderer';\n    CellComp.CELL_RENDERER_TYPE_PINNED = 'pinnedRowCellRenderer';\n    return CellComp;\n}(Component));\nexport { CellComp };\n"]},"metadata":{},"sourceType":"module"}