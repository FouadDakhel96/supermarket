{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Group } from \"../scene/group\";\nimport { Selection } from \"../scene/selection\";\nimport { MarkerLabel } from \"./markerLabel\";\nimport { reactive, Observable } from \"../util/observable\";\nimport { getMarker } from \"./marker/util\";\nimport { createId } from \"../util/id\";\nexport var LegendOrientation;\n\n(function (LegendOrientation) {\n  LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n  LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation || (LegendOrientation = {}));\n\nexport var LegendPosition;\n\n(function (LegendPosition) {\n  LegendPosition[\"Top\"] = \"top\";\n  LegendPosition[\"Right\"] = \"right\";\n  LegendPosition[\"Bottom\"] = \"bottom\";\n  LegendPosition[\"Left\"] = \"left\";\n})(LegendPosition || (LegendPosition = {}));\n\nvar Legend =\n/** @class */\nfunction (_super) {\n  __extends(Legend, _super);\n\n  function Legend() {\n    var _this = _super.call(this) || this;\n\n    _this.id = createId(_this);\n    _this.group = new Group();\n    _this.itemSelection = Selection.select(_this.group).selectAll();\n    _this.oldSize = [0, 0];\n    _this.data = [];\n    _this.enabled = true;\n    _this.orientation = LegendOrientation.Vertical;\n    _this.position = LegendPosition.Right;\n    /**\n     * Spacing between the legend and the edge of the chart's element.\n     */\n\n    _this.spacing = 20;\n    /**\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\n     * spacing between legend items.\n     */\n\n    _this.layoutHorizontalSpacing = 16;\n    /**\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\n     * spacing between legend items.\n     */\n\n    _this.layoutVerticalSpacing = 8;\n    /**\n     * Spacing between the marker and the label within each legend item.\n     */\n\n    _this.itemSpacing = 8;\n    _this.markerSize = 15;\n    _this.strokeWidth = 1;\n    _this.color = 'black';\n    _this.fontSize = 12;\n    _this.fontFamily = 'Verdana, sans-serif';\n    _this._size = [0, 0];\n\n    _this.addPropertyListener('data', _this.onDataChange);\n\n    _this.addPropertyListener('enabled', _this.onEnabledChange);\n\n    _this.addPropertyListener('position', _this.onPositionChange);\n\n    _this.addPropertyListener('markerShape', _this.onMarkerShapeChange);\n\n    _this.addEventListener('change', _this.update);\n\n    return _this;\n  }\n\n  Object.defineProperty(Legend.prototype, \"size\", {\n    get: function () {\n      return this._size;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  Legend.prototype.onDataChange = function (event) {\n    this.group.visible = event.value.length > 0 && this.enabled;\n  };\n\n  Legend.prototype.onEnabledChange = function (event) {\n    this.group.visible = event.value && this.data.length > 0;\n  };\n\n  Legend.prototype.onPositionChange = function (event) {\n    switch (event.value) {\n      case 'right':\n      case 'left':\n        this.orientation = LegendOrientation.Vertical;\n        break;\n\n      case 'bottom':\n      case 'top':\n        this.orientation = LegendOrientation.Horizontal;\n        break;\n    }\n  };\n\n  Legend.prototype.onMarkerShapeChange = function () {\n    this.itemSelection = this.itemSelection.setData([]);\n    this.itemSelection.exit.remove();\n  };\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n\n\n  Legend.prototype.performLayout = function (width, height) {\n    var _this = this;\n\n    var _a = this,\n        markerShape = _a.markerShape,\n        layoutHorizontalSpacing = _a.layoutHorizontalSpacing,\n        layoutVerticalSpacing = _a.layoutVerticalSpacing;\n\n    var updateSelection = this.itemSelection.setData(this.data, function (_, datum) {\n      var MarkerShape = getMarker(markerShape || datum.marker.shape);\n      return datum.id + '-' + datum.itemId + '-' + MarkerShape.name;\n    });\n    updateSelection.exit.remove();\n    var enterSelection = updateSelection.enter.append(MarkerLabel).each(function (node, datum) {\n      var MarkerShape = getMarker(markerShape || datum.marker.shape);\n      node.marker = new MarkerShape();\n    });\n    var itemSelection = this.itemSelection = updateSelection.merge(enterSelection);\n    var itemCount = itemSelection.size; // Update properties that affect the size of the legend items and measure them.\n\n    var bboxes = [];\n    itemSelection.each(function (markerLabel, datum) {\n      // TODO: measure only when one of these properties or data change (in a separate routine)\n      markerLabel.markerSize = _this.markerSize;\n      markerLabel.fontStyle = _this.fontStyle;\n      markerLabel.fontWeight = _this.fontWeight;\n      markerLabel.fontSize = _this.fontSize;\n      markerLabel.fontFamily = _this.fontFamily;\n      markerLabel.text = datum.label.text;\n      markerLabel.spacing = _this.itemSpacing;\n      bboxes.push(markerLabel.computeBBox());\n    });\n    var itemHeight = bboxes.length && bboxes[0].height;\n    var rowCount = 0;\n    var columnWidth = 0;\n    var paddedItemsWidth = 0;\n    var paddedItemsHeight = 0;\n\n    switch (this.orientation) {\n      case LegendOrientation.Horizontal:\n        if (!(isFinite(width) && width > 0)) {\n          return false;\n        }\n\n        rowCount = 0;\n        var columnCount = 0; // Split legend items into columns until the width is suitable.\n\n        do {\n          var itemsWidth = 0;\n          columnCount = 0;\n          columnWidth = 0;\n          rowCount++;\n          var i = 0;\n\n          while (i < itemCount) {\n            var bbox = bboxes[i];\n\n            if (bbox.width > columnWidth) {\n              columnWidth = bbox.width;\n            }\n\n            i++;\n\n            if (i % rowCount === 0) {\n              itemsWidth += columnWidth;\n              columnWidth = 0;\n              columnCount++;\n            }\n          }\n\n          if (i % rowCount !== 0) {\n            itemsWidth += columnWidth;\n            columnCount++;\n          }\n\n          paddedItemsWidth = itemsWidth + (columnCount - 1) * layoutHorizontalSpacing;\n        } while (paddedItemsWidth > width && columnCount > 1);\n\n        paddedItemsHeight = itemHeight * rowCount + (rowCount - 1) * layoutVerticalSpacing;\n        break;\n\n      case LegendOrientation.Vertical:\n        if (!(isFinite(height) && height > 0)) {\n          return false;\n        }\n\n        rowCount = itemCount * 2; // Split legend items into columns until the height is suitable.\n\n        do {\n          rowCount = (rowCount >> 1) + rowCount % 2;\n          columnWidth = 0;\n          var itemsWidth = 0;\n          var itemsHeight = 0;\n          var columnCount_1 = 0;\n          var i = 0;\n\n          while (i < itemCount) {\n            var bbox = bboxes[i];\n\n            if (!columnCount_1) {\n              itemsHeight += bbox.height;\n            }\n\n            if (bbox.width > columnWidth) {\n              columnWidth = bbox.width;\n            }\n\n            i++;\n\n            if (i % rowCount === 0) {\n              itemsWidth += columnWidth;\n              columnWidth = 0;\n              columnCount_1++;\n            }\n          }\n\n          if (i % rowCount !== 0) {\n            itemsWidth += columnWidth;\n            columnCount_1++;\n          }\n\n          paddedItemsWidth = itemsWidth + (columnCount_1 - 1) * layoutHorizontalSpacing;\n          paddedItemsHeight = itemsHeight + (rowCount - 1) * layoutVerticalSpacing;\n        } while (paddedItemsHeight > height && rowCount > 1);\n\n        break;\n    } // Top-left corner of the first legend item.\n\n\n    var startX = (width - paddedItemsWidth) / 2;\n    var startY = (height - paddedItemsHeight) / 2;\n    var x = 0;\n    var y = 0;\n    columnWidth = 0; // Position legend items using the layout computed above.\n\n    itemSelection.each(function (markerLabel, datum, i) {\n      // Round off for pixel grid alignment to work properly.\n      markerLabel.translationX = Math.floor(startX + x);\n      markerLabel.translationY = Math.floor(startY + y);\n      var bbox = bboxes[i];\n\n      if (bbox.width > columnWidth) {\n        columnWidth = bbox.width;\n      }\n\n      if ((i + 1) % rowCount === 0) {\n        x += columnWidth + layoutHorizontalSpacing;\n        y = 0;\n        columnWidth = 0;\n      } else {\n        y += bbox.height + layoutVerticalSpacing;\n      }\n    }); // Update legend item properties that don't affect the layout.\n\n    this.update();\n    var size = this._size;\n    var oldSize = this.oldSize;\n    size[0] = paddedItemsWidth;\n    size[1] = paddedItemsHeight;\n\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n  };\n\n  Legend.prototype.update = function () {\n    var _this = this;\n\n    this.itemSelection.each(function (markerLabel, datum) {\n      var marker = datum.marker;\n      markerLabel.markerFill = marker.fill;\n      markerLabel.markerStroke = marker.stroke;\n      markerLabel.markerStrokeWidth = _this.strokeWidth;\n      markerLabel.markerFillOpacity = marker.fillOpacity;\n      markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n      markerLabel.opacity = datum.enabled ? 1 : 0.5;\n      markerLabel.color = _this.color;\n    });\n  };\n\n  Legend.prototype.getDatumForPoint = function (x, y) {\n    var node = this.group.pickNode(x, y);\n\n    if (node && node.parent) {\n      return node.parent.datum;\n    }\n  };\n\n  Legend.className = 'Legend';\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"data\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"enabled\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"orientation\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"position\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"spacing\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"layoutHorizontalSpacing\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"layoutVerticalSpacing\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"itemSpacing\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"markerShape\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"markerSize\", void 0);\n\n  __decorate([reactive('change')], Legend.prototype, \"strokeWidth\", void 0);\n\n  __decorate([reactive('change')], Legend.prototype, \"color\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"fontStyle\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"fontWeight\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"fontSize\", void 0);\n\n  __decorate([reactive('layoutChange')], Legend.prototype, \"fontFamily\", void 0);\n\n  return Legend;\n}(Observable);\n\nexport { Legend };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/ag-charts-community/dist/es6/chart/legend.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Group","Selection","MarkerLabel","reactive","Observable","getMarker","createId","LegendOrientation","LegendPosition","Legend","_super","_this","call","id","group","itemSelection","select","selectAll","oldSize","data","enabled","orientation","Vertical","position","Right","spacing","layoutHorizontalSpacing","layoutVerticalSpacing","itemSpacing","markerSize","strokeWidth","color","fontSize","fontFamily","_size","addPropertyListener","onDataChange","onEnabledChange","onPositionChange","onMarkerShapeChange","addEventListener","update","get","enumerable","configurable","event","visible","value","Horizontal","setData","exit","remove","performLayout","width","height","_a","markerShape","updateSelection","_","datum","MarkerShape","marker","shape","itemId","name","enterSelection","enter","append","each","node","merge","itemCount","size","bboxes","markerLabel","fontStyle","fontWeight","text","label","push","computeBBox","itemHeight","rowCount","columnWidth","paddedItemsWidth","paddedItemsHeight","isFinite","columnCount","itemsWidth","bbox","itemsHeight","columnCount_1","startX","startY","x","y","translationX","Math","floor","translationY","markerFill","fill","markerStroke","stroke","markerStrokeWidth","markerFillOpacity","fillOpacity","markerStrokeOpacity","strokeOpacity","opacity","getDatumForPoint","pickNode","parent","className"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Group } from \"../scene/group\";\nimport { Selection } from \"../scene/selection\";\nimport { MarkerLabel } from \"./markerLabel\";\nimport { reactive, Observable } from \"../util/observable\";\nimport { getMarker } from \"./marker/util\";\nimport { createId } from \"../util/id\";\nexport var LegendOrientation;\n(function (LegendOrientation) {\n    LegendOrientation[LegendOrientation[\"Vertical\"] = 0] = \"Vertical\";\n    LegendOrientation[LegendOrientation[\"Horizontal\"] = 1] = \"Horizontal\";\n})(LegendOrientation || (LegendOrientation = {}));\nexport var LegendPosition;\n(function (LegendPosition) {\n    LegendPosition[\"Top\"] = \"top\";\n    LegendPosition[\"Right\"] = \"right\";\n    LegendPosition[\"Bottom\"] = \"bottom\";\n    LegendPosition[\"Left\"] = \"left\";\n})(LegendPosition || (LegendPosition = {}));\nvar Legend = /** @class */ (function (_super) {\n    __extends(Legend, _super);\n    function Legend() {\n        var _this = _super.call(this) || this;\n        _this.id = createId(_this);\n        _this.group = new Group();\n        _this.itemSelection = Selection.select(_this.group).selectAll();\n        _this.oldSize = [0, 0];\n        _this.data = [];\n        _this.enabled = true;\n        _this.orientation = LegendOrientation.Vertical;\n        _this.position = LegendPosition.Right;\n        /**\n         * Spacing between the legend and the edge of the chart's element.\n         */\n        _this.spacing = 20;\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\n         * spacing between legend items.\n         */\n        _this.layoutHorizontalSpacing = 16;\n        /**\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\n         * spacing between legend items.\n         */\n        _this.layoutVerticalSpacing = 8;\n        /**\n         * Spacing between the marker and the label within each legend item.\n         */\n        _this.itemSpacing = 8;\n        _this.markerSize = 15;\n        _this.strokeWidth = 1;\n        _this.color = 'black';\n        _this.fontSize = 12;\n        _this.fontFamily = 'Verdana, sans-serif';\n        _this._size = [0, 0];\n        _this.addPropertyListener('data', _this.onDataChange);\n        _this.addPropertyListener('enabled', _this.onEnabledChange);\n        _this.addPropertyListener('position', _this.onPositionChange);\n        _this.addPropertyListener('markerShape', _this.onMarkerShapeChange);\n        _this.addEventListener('change', _this.update);\n        return _this;\n    }\n    Object.defineProperty(Legend.prototype, \"size\", {\n        get: function () {\n            return this._size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Legend.prototype.onDataChange = function (event) {\n        this.group.visible = event.value.length > 0 && this.enabled;\n    };\n    Legend.prototype.onEnabledChange = function (event) {\n        this.group.visible = event.value && this.data.length > 0;\n    };\n    Legend.prototype.onPositionChange = function (event) {\n        switch (event.value) {\n            case 'right':\n            case 'left':\n                this.orientation = LegendOrientation.Vertical;\n                break;\n            case 'bottom':\n            case 'top':\n                this.orientation = LegendOrientation.Horizontal;\n                break;\n        }\n    };\n    Legend.prototype.onMarkerShapeChange = function () {\n        this.itemSelection = this.itemSelection.setData([]);\n        this.itemSelection.exit.remove();\n    };\n    /**\n     * The method is given the desired size of the legend, which only serves as a hint.\n     * The vertically oriented legend will take as much horizontal space as needed, but will\n     * respect the height constraints, and the horizontal legend will take as much vertical\n     * space as needed in an attempt not to exceed the given width.\n     * After the layout is done, the {@link size} will contain the actual size of the legend.\n     * If the actual size is not the same as the previous actual size, the legend will fire\n     * the 'layoutChange' event to communicate that another layout is needed, and the above\n     * process should be repeated.\n     * @param width\n     * @param height\n     */\n    Legend.prototype.performLayout = function (width, height) {\n        var _this = this;\n        var _a = this, markerShape = _a.markerShape, layoutHorizontalSpacing = _a.layoutHorizontalSpacing, layoutVerticalSpacing = _a.layoutVerticalSpacing;\n        var updateSelection = this.itemSelection.setData(this.data, function (_, datum) {\n            var MarkerShape = getMarker(markerShape || datum.marker.shape);\n            return datum.id + '-' + datum.itemId + '-' + MarkerShape.name;\n        });\n        updateSelection.exit.remove();\n        var enterSelection = updateSelection.enter.append(MarkerLabel).each(function (node, datum) {\n            var MarkerShape = getMarker(markerShape || datum.marker.shape);\n            node.marker = new MarkerShape();\n        });\n        var itemSelection = this.itemSelection = updateSelection.merge(enterSelection);\n        var itemCount = itemSelection.size;\n        // Update properties that affect the size of the legend items and measure them.\n        var bboxes = [];\n        itemSelection.each(function (markerLabel, datum) {\n            // TODO: measure only when one of these properties or data change (in a separate routine)\n            markerLabel.markerSize = _this.markerSize;\n            markerLabel.fontStyle = _this.fontStyle;\n            markerLabel.fontWeight = _this.fontWeight;\n            markerLabel.fontSize = _this.fontSize;\n            markerLabel.fontFamily = _this.fontFamily;\n            markerLabel.text = datum.label.text;\n            markerLabel.spacing = _this.itemSpacing;\n            bboxes.push(markerLabel.computeBBox());\n        });\n        var itemHeight = bboxes.length && bboxes[0].height;\n        var rowCount = 0;\n        var columnWidth = 0;\n        var paddedItemsWidth = 0;\n        var paddedItemsHeight = 0;\n        switch (this.orientation) {\n            case LegendOrientation.Horizontal:\n                if (!(isFinite(width) && width > 0)) {\n                    return false;\n                }\n                rowCount = 0;\n                var columnCount = 0;\n                // Split legend items into columns until the width is suitable.\n                do {\n                    var itemsWidth = 0;\n                    columnCount = 0;\n                    columnWidth = 0;\n                    rowCount++;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount - 1) * layoutHorizontalSpacing;\n                } while (paddedItemsWidth > width && columnCount > 1);\n                paddedItemsHeight = itemHeight * rowCount + (rowCount - 1) * layoutVerticalSpacing;\n                break;\n            case LegendOrientation.Vertical:\n                if (!(isFinite(height) && height > 0)) {\n                    return false;\n                }\n                rowCount = itemCount * 2;\n                // Split legend items into columns until the height is suitable.\n                do {\n                    rowCount = (rowCount >> 1) + (rowCount % 2);\n                    columnWidth = 0;\n                    var itemsWidth = 0;\n                    var itemsHeight = 0;\n                    var columnCount_1 = 0;\n                    var i = 0;\n                    while (i < itemCount) {\n                        var bbox = bboxes[i];\n                        if (!columnCount_1) {\n                            itemsHeight += bbox.height;\n                        }\n                        if (bbox.width > columnWidth) {\n                            columnWidth = bbox.width;\n                        }\n                        i++;\n                        if (i % rowCount === 0) {\n                            itemsWidth += columnWidth;\n                            columnWidth = 0;\n                            columnCount_1++;\n                        }\n                    }\n                    if (i % rowCount !== 0) {\n                        itemsWidth += columnWidth;\n                        columnCount_1++;\n                    }\n                    paddedItemsWidth = itemsWidth + (columnCount_1 - 1) * layoutHorizontalSpacing;\n                    paddedItemsHeight = itemsHeight + (rowCount - 1) * layoutVerticalSpacing;\n                } while (paddedItemsHeight > height && rowCount > 1);\n                break;\n        }\n        // Top-left corner of the first legend item.\n        var startX = (width - paddedItemsWidth) / 2;\n        var startY = (height - paddedItemsHeight) / 2;\n        var x = 0;\n        var y = 0;\n        columnWidth = 0;\n        // Position legend items using the layout computed above.\n        itemSelection.each(function (markerLabel, datum, i) {\n            // Round off for pixel grid alignment to work properly.\n            markerLabel.translationX = Math.floor(startX + x);\n            markerLabel.translationY = Math.floor(startY + y);\n            var bbox = bboxes[i];\n            if (bbox.width > columnWidth) {\n                columnWidth = bbox.width;\n            }\n            if ((i + 1) % rowCount === 0) {\n                x += columnWidth + layoutHorizontalSpacing;\n                y = 0;\n                columnWidth = 0;\n            }\n            else {\n                y += bbox.height + layoutVerticalSpacing;\n            }\n        });\n        // Update legend item properties that don't affect the layout.\n        this.update();\n        var size = this._size;\n        var oldSize = this.oldSize;\n        size[0] = paddedItemsWidth;\n        size[1] = paddedItemsHeight;\n        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n            oldSize[0] = size[0];\n            oldSize[1] = size[1];\n        }\n    };\n    Legend.prototype.update = function () {\n        var _this = this;\n        this.itemSelection.each(function (markerLabel, datum) {\n            var marker = datum.marker;\n            markerLabel.markerFill = marker.fill;\n            markerLabel.markerStroke = marker.stroke;\n            markerLabel.markerStrokeWidth = _this.strokeWidth;\n            markerLabel.markerFillOpacity = marker.fillOpacity;\n            markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n            markerLabel.opacity = datum.enabled ? 1 : 0.5;\n            markerLabel.color = _this.color;\n        });\n    };\n    Legend.prototype.getDatumForPoint = function (x, y) {\n        var node = this.group.pickNode(x, y);\n        if (node && node.parent) {\n            return node.parent.datum;\n        }\n    };\n    Legend.className = 'Legend';\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"data\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"enabled\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"orientation\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"position\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"spacing\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"layoutHorizontalSpacing\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"layoutVerticalSpacing\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"itemSpacing\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"markerShape\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"markerSize\", void 0);\n    __decorate([\n        reactive('change')\n    ], Legend.prototype, \"strokeWidth\", void 0);\n    __decorate([\n        reactive('change')\n    ], Legend.prototype, \"color\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"fontStyle\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"fontWeight\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"fontSize\", void 0);\n    __decorate([\n        reactive('layoutChange')\n    ], Legend.prototype, \"fontFamily\", void 0);\n    return Legend;\n}(Observable));\nexport { Legend };\n"]},"metadata":{},"sourceType":"module"}