{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { Constants } from \"../constants\";\nimport { DragAndDropService, DragSourceType, HorizontalDirection } from \"../dragAndDrop/dragAndDropService\";\nimport { _ } from \"../utils\";\n\nvar MoveColumnController =\n/** @class */\nfunction () {\n  function MoveColumnController(pinned, eContainer) {\n    this.needToMoveLeft = false;\n    this.needToMoveRight = false;\n    this.pinned = pinned;\n    this.eContainer = eContainer;\n    this.centerContainer = !_.exists(pinned);\n  }\n\n  MoveColumnController.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n  };\n\n  MoveColumnController.prototype.init = function () {\n    this.logger = this.loggerFactory.create('MoveColumnController');\n  };\n\n  MoveColumnController.prototype.getIconName = function () {\n    return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;\n  };\n\n  MoveColumnController.prototype.onDragEnter = function (draggingEvent) {\n    // we do dummy drag, so make sure column appears in the right location when first placed\n    var columns = draggingEvent.dragItem.columns;\n    var dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;\n\n    if (dragCameFromToolPanel) {\n      // the if statement doesn't work if drag leaves grid, then enters again\n      this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n    } else {\n      // restore previous state of visible columns upon re-entering. this means if the user drags\n      // a group out, and then drags the group back in, only columns that were originally visible\n      // will be visible again. otherwise a group with three columns (but only two visible) could\n      // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n      var visibleState_1 = draggingEvent.dragItem.visibleState;\n      var visibleColumns = columns.filter(function (column) {\n        return visibleState_1[column.getId()];\n      });\n      this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n    }\n\n    this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n    this.onDragging(draggingEvent, true);\n  };\n\n  MoveColumnController.prototype.onDragLeave = function (draggingEvent) {\n    var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n\n    if (hideColumnOnExit) {\n      var dragItem = draggingEvent.dragSource.getDragItem();\n      var columns = dragItem.columns;\n      this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n    }\n\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnController.prototype.setColumnsVisible = function (columns, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockVisible;\n      });\n      this.columnController.setColumnsVisible(allowedCols, visible, source);\n    }\n  };\n\n  MoveColumnController.prototype.setColumnsPinned = function (columns, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (columns) {\n      var allowedCols = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n      this.columnController.setColumnsPinned(allowedCols, pinned, source);\n    }\n  };\n\n  MoveColumnController.prototype.onDragStop = function () {\n    this.ensureIntervalCleared();\n  };\n\n  MoveColumnController.prototype.normaliseX = function (x) {\n    // flip the coordinate if doing RTL\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      var clientWidth = this.eContainer.clientWidth;\n      x = clientWidth - x;\n    } // adjust for scroll only if centre container (the pinned containers don't scroll)\n\n\n    if (this.centerContainer) {\n      x += this.gridPanel.getCenterViewportScrollLeft();\n    }\n\n    return x;\n  };\n\n  MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n    if (this.centerContainer) {\n      // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n      // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n      var firstVisiblePixel = this.gridPanel.getCenterViewportScrollLeft();\n      var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();\n\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        this.needToMoveRight = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveLeft = xAdjustedForScroll > lastVisiblePixel - 50;\n      } else {\n        this.needToMoveLeft = xAdjustedForScroll < firstVisiblePixel + 50;\n        this.needToMoveRight = xAdjustedForScroll > lastVisiblePixel - 50;\n      }\n\n      if (this.needToMoveLeft || this.needToMoveRight) {\n        this.ensureIntervalStarted();\n      } else {\n        this.ensureIntervalCleared();\n      }\n    }\n  };\n\n  MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {\n    var _this = this;\n\n    if (fromEnter === void 0) {\n      fromEnter = false;\n    }\n\n    this.lastDraggingEvent = draggingEvent; // if moving up or down (ie not left or right) then do nothing\n\n    if (_.missing(draggingEvent.hDirection)) {\n      return;\n    }\n\n    var mouseXNormalised = this.normaliseX(draggingEvent.x); // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n    // we don't want to scroll the grid this time, it would appear like the table is jumping\n    // each time a column is dragged in.\n\n    if (!fromEnter) {\n      this.checkCenterForScrolling(mouseXNormalised);\n    }\n\n    var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n    var dragSourceType = draggingEvent.dragSource.type;\n    var columnsToMove = draggingEvent.dragSource.getDragItem().columns;\n    columnsToMove = columnsToMove.filter(function (col) {\n      if (col.getColDef().lockPinned) {\n        // if locked return true only if both col and container are same pin type.\n        // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n        return col.getPinned() == _this.pinned;\n      } else {\n        // if not pin locked, then always allowed to be in this container\n        return true;\n      }\n    });\n    this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n  };\n\n  MoveColumnController.prototype.normaliseDirection = function (hDirection) {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      switch (hDirection) {\n        case HorizontalDirection.Left:\n          return HorizontalDirection.Right;\n\n        case HorizontalDirection.Right:\n          return HorizontalDirection.Left;\n\n        default:\n          console.error(\"ag-Grid: Unknown direction \" + hDirection);\n      }\n    } else {\n      return hDirection;\n    }\n  }; // returns the index of the first column in the list ONLY if the cols are all beside\n  // each other. if the cols are not beside each other, then returns null\n\n\n  MoveColumnController.prototype.calculateOldIndex = function (movingCols) {\n    var gridCols = this.columnController.getAllGridColumns();\n\n    var indexes = _.sortNumerically(movingCols.map(function (col) {\n      return gridCols.indexOf(col);\n    }));\n\n    var firstIndex = indexes[0];\n\n    var lastIndex = _.last(indexes);\n\n    var spread = lastIndex - firstIndex;\n    var gapsExist = spread !== indexes.length - 1;\n    return gapsExist ? null : firstIndex;\n  };\n\n  MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n    var draggingLeft = hDirection === HorizontalDirection.Left;\n    var draggingRight = hDirection === HorizontalDirection.Right;\n    var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, mouseX); // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n    // (ie left or right) to the mouse direction. however\n\n    var oldIndex = this.calculateOldIndex(allMovingColumns);\n\n    if (validMoves.length === 0) {\n      return;\n    }\n\n    var firstValidMove = validMoves[0]; // the two check below stop an error when the user grabs a group my a middle column, then\n    // it is possible the mouse pointer is to the right of a column while been dragged left.\n    // so we need to make sure that the mouse pointer is actually left of the left most column\n    // if moving left, and right of the right most column if moving right\n    // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n    // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n    // place the column to the RHS even if the mouse is moving left and the column is already on\n    // the LHS. otherwise we stick to the rule described above.\n\n    var constrainDirection = oldIndex !== null && !fromEnter; // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n\n    if (dragSourceType == DragSourceType.HeaderCell) {\n      constrainDirection = oldIndex !== null;\n    }\n\n    if (constrainDirection) {\n      // only allow left drag if this column is moving left\n      if (draggingLeft && firstValidMove >= oldIndex) {\n        return;\n      } // only allow right drag if this column is moving right\n\n\n      if (draggingRight && firstValidMove <= oldIndex) {\n        return;\n      }\n    }\n\n    for (var i = 0; i < validMoves.length; i++) {\n      var move = validMoves[i];\n\n      if (!this.columnController.doesMovePassRules(allMovingColumns, move)) {\n        continue;\n      }\n\n      this.columnController.moveColumns(allMovingColumns, move, \"uiColumnDragged\"); // important to return here, so once we do the first valid move, we don't try do any more\n\n      return;\n    }\n  };\n\n  MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n    var isMoveBlocked = this.gridOptionsWrapper.isSuppressMovableColumns() || movingCols.some(function (col) {\n      return col.getColDef().suppressMovable;\n    });\n\n    if (isMoveBlocked) {\n      return [];\n    } // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n\n\n    var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned); // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n    // so the result we return has to be and index location for this list\n\n    var allGridCols = this.columnController.getAllGridColumns();\n    var movingDisplayedCols = allDisplayedCols.filter(function (col) {\n      return _.includes(movingCols, col);\n    });\n    var otherDisplayedCols = allDisplayedCols.filter(function (col) {\n      return !_.includes(movingCols, col);\n    });\n    var otherGridCols = allGridCols.filter(function (col) {\n      return !_.includes(movingCols, col);\n    }); // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n    // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n    // col between b and c (so that it is under the mouse position).\n\n    var displayIndex = 0;\n    var availableWidth = mouseX; // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n    // include the width of the moving columns\n\n    if (draggingRight) {\n      var widthOfMovingDisplayedCols_1 = 0;\n      movingDisplayedCols.forEach(function (col) {\n        return widthOfMovingDisplayedCols_1 += col.getActualWidth();\n      });\n      availableWidth -= widthOfMovingDisplayedCols_1;\n    }\n\n    if (availableWidth > 0) {\n      // now count how many of the displayed columns will fit to the left\n      for (var i = 0; i < otherDisplayedCols.length; i++) {\n        var col = otherDisplayedCols[i];\n        availableWidth -= col.getActualWidth();\n\n        if (availableWidth < 0) {\n          break;\n        }\n\n        displayIndex++;\n      } // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n\n\n      if (draggingRight) {\n        displayIndex++;\n      }\n    } // the display index is with respect to all the showing columns, however when we move, it's with\n    // respect to all grid columns, so we need to translate from display index to grid index\n\n\n    var firstValidMove;\n\n    if (displayIndex > 0) {\n      var leftColumn = otherDisplayedCols[displayIndex - 1];\n      firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n    } else {\n      firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);\n\n      if (firstValidMove === -1) {\n        firstValidMove = 0;\n      }\n    }\n\n    var validMoves = [firstValidMove]; // add in other valid moves due to hidden columns and married children. for example, a particular\n    // move might break a group that has married children (so move isn't valid), however there could\n    // be hidden columns (not displayed) that we could jump over to make the move valid. because\n    // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n    // not work. for example imagine a group with 9 columns and all columns are hidden except the\n    // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n    // be relative to the not-shown column, however we need to consider the move jumping over all the\n    // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n    // grid, there would be no way to put a column after it (as the grid would only consider beside the\n    // visible column, which would fail valid move rules).\n\n    if (draggingRight) {\n      // if dragging right, then we add all the additional moves to the right. so in other words\n      // if the next move is not valid, find the next move to the right that is valid.\n      var pointer = firstValidMove + 1;\n      var lastIndex = allGridCols.length - 1;\n\n      while (pointer <= lastIndex) {\n        validMoves.push(pointer);\n        pointer++;\n      }\n    } else {\n      // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n      // left. however we also have to consider moves to the right for all hidden columns first.\n      // (this logic is hard to reason with, it was worked out with trial and error,\n      // move observation rather than science).\n      // add moves to the right\n      var pointer = firstValidMove;\n      var lastIndex = allGridCols.length - 1;\n      var displacedCol = allGridCols[pointer];\n\n      while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n        pointer++;\n        validMoves.push(pointer);\n        displacedCol = allGridCols[pointer];\n      } // add moves to the left\n\n\n      pointer = firstValidMove - 1;\n      var firstDisplayIndex = 0;\n\n      while (pointer >= firstDisplayIndex) {\n        validMoves.push(pointer);\n        pointer--;\n      }\n    }\n\n    return validMoves;\n  }; // isHidden takes into account visible=false and group=closed, ie it is not displayed\n\n\n  MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {\n    return displayedColumns.indexOf(col) < 0;\n  };\n\n  MoveColumnController.prototype.ensureIntervalStarted = function () {\n    if (!this.movingIntervalId) {\n      this.intervalCount = 0;\n      this.failedMoveAttempts = 0;\n      this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n\n      if (this.needToMoveLeft) {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);\n      } else {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);\n      }\n    }\n  };\n\n  MoveColumnController.prototype.ensureIntervalCleared = function () {\n    if (this.moveInterval) {\n      window.clearInterval(this.movingIntervalId);\n      this.movingIntervalId = null;\n      this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n    }\n  };\n\n  MoveColumnController.prototype.moveInterval = function () {\n    // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n    // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n    var pixelsToMove;\n    this.intervalCount++;\n    pixelsToMove = 10 + this.intervalCount * 5;\n\n    if (pixelsToMove > 100) {\n      pixelsToMove = 100;\n    }\n\n    var pixelsMoved;\n\n    if (this.needToMoveLeft) {\n      pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);\n    } else if (this.needToMoveRight) {\n      pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);\n    }\n\n    if (pixelsMoved !== 0) {\n      this.onDragging(this.lastDraggingEvent);\n      this.failedMoveAttempts = 0;\n    } else {\n      // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n      // this is how we achieve pining by dragging the column to the edge of the grid.\n      this.failedMoveAttempts++;\n      var columns = this.lastDraggingEvent.dragItem.columns;\n      var columnsThatCanPin = columns.filter(function (c) {\n        return !c.getColDef().lockPinned;\n      });\n\n      if (columnsThatCanPin.length > 0) {\n        this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);\n\n        if (this.failedMoveAttempts > 7) {\n          var pinType = this.needToMoveLeft ? Constants.PINNED_LEFT : Constants.PINNED_RIGHT;\n          this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n          this.dragAndDropService.nudge();\n        }\n      }\n    }\n  };\n\n  __decorate([Autowired('loggerFactory')], MoveColumnController.prototype, \"loggerFactory\", void 0);\n\n  __decorate([Autowired('columnController')], MoveColumnController.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('dragAndDropService')], MoveColumnController.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([Autowired('gridOptionsWrapper')], MoveColumnController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([PostConstruct], MoveColumnController.prototype, \"init\", null);\n\n  return MoveColumnController;\n}();\n\nexport { MoveColumnController };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/headerRendering/moveColumnController.js"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","Autowired","PostConstruct","Constants","DragAndDropService","DragSourceType","HorizontalDirection","_","MoveColumnController","pinned","eContainer","needToMoveLeft","needToMoveRight","centerContainer","exists","prototype","registerGridComp","gridPanel","init","logger","loggerFactory","create","getIconName","ICON_PINNED","ICON_MOVE","onDragEnter","draggingEvent","columns","dragItem","dragCameFromToolPanel","dragSource","type","ToolPanel","setColumnsVisible","visibleState_1","visibleState","visibleColumns","filter","column","getId","setColumnsPinned","onDragging","onDragLeave","hideColumnOnExit","gridOptionsWrapper","isSuppressDragLeaveHidesColumns","fromNudge","getDragItem","ensureIntervalCleared","visible","source","allowedCols","getColDef","lockVisible","columnController","lockPinned","onDragStop","normaliseX","x","isEnableRtl","clientWidth","getCenterViewportScrollLeft","checkCenterForScrolling","xAdjustedForScroll","firstVisiblePixel","lastVisiblePixel","getCenterWidth","ensureIntervalStarted","fromEnter","_this","lastDraggingEvent","missing","hDirection","mouseXNormalised","hDirectionNormalised","normaliseDirection","dragSourceType","columnsToMove","col","getPinned","attemptMoveColumns","Left","Right","console","error","calculateOldIndex","movingCols","gridCols","getAllGridColumns","indexes","sortNumerically","map","indexOf","firstIndex","lastIndex","last","spread","gapsExist","allMovingColumns","mouseX","draggingLeft","draggingRight","validMoves","calculateValidMoves","oldIndex","firstValidMove","constrainDirection","HeaderCell","move","doesMovePassRules","moveColumns","isMoveBlocked","isSuppressMovableColumns","some","suppressMovable","allDisplayedCols","getDisplayedColumns","allGridCols","movingDisplayedCols","includes","otherDisplayedCols","otherGridCols","displayIndex","availableWidth","widthOfMovingDisplayedCols_1","forEach","getActualWidth","leftColumn","pointer","push","displacedCol","isColumnHidden","firstDisplayIndex","displayedColumns","movingIntervalId","intervalCount","failedMoveAttempts","window","setInterval","moveInterval","bind","dragAndDropService","setGhostIcon","ICON_LEFT","ICON_RIGHT","clearInterval","pixelsToMove","pixelsMoved","scrollHorizontally","columnsThatCanPin","pinType","PINNED_LEFT","PINNED_RIGHT","nudge"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, PostConstruct } from \"../context/context\";\nimport { Constants } from \"../constants\";\nimport { DragAndDropService, DragSourceType, HorizontalDirection } from \"../dragAndDrop/dragAndDropService\";\nimport { _ } from \"../utils\";\nvar MoveColumnController = /** @class */ (function () {\n    function MoveColumnController(pinned, eContainer) {\n        this.needToMoveLeft = false;\n        this.needToMoveRight = false;\n        this.pinned = pinned;\n        this.eContainer = eContainer;\n        this.centerContainer = !_.exists(pinned);\n    }\n    MoveColumnController.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n    };\n    MoveColumnController.prototype.init = function () {\n        this.logger = this.loggerFactory.create('MoveColumnController');\n    };\n    MoveColumnController.prototype.getIconName = function () {\n        return this.pinned ? DragAndDropService.ICON_PINNED : DragAndDropService.ICON_MOVE;\n    };\n    MoveColumnController.prototype.onDragEnter = function (draggingEvent) {\n        // we do dummy drag, so make sure column appears in the right location when first placed\n        var columns = draggingEvent.dragItem.columns;\n        var dragCameFromToolPanel = draggingEvent.dragSource.type === DragSourceType.ToolPanel;\n        if (dragCameFromToolPanel) {\n            // the if statement doesn't work if drag leaves grid, then enters again\n            this.setColumnsVisible(columns, true, \"uiColumnDragged\");\n        }\n        else {\n            // restore previous state of visible columns upon re-entering. this means if the user drags\n            // a group out, and then drags the group back in, only columns that were originally visible\n            // will be visible again. otherwise a group with three columns (but only two visible) could\n            // be dragged out, then when it's dragged in again, all three are visible. this stops that.\n            var visibleState_1 = draggingEvent.dragItem.visibleState;\n            var visibleColumns = columns.filter(function (column) { return visibleState_1[column.getId()]; });\n            this.setColumnsVisible(visibleColumns, true, \"uiColumnDragged\");\n        }\n        this.setColumnsPinned(columns, this.pinned, \"uiColumnDragged\");\n        this.onDragging(draggingEvent, true);\n    };\n    MoveColumnController.prototype.onDragLeave = function (draggingEvent) {\n        var hideColumnOnExit = !this.gridOptionsWrapper.isSuppressDragLeaveHidesColumns() && !draggingEvent.fromNudge;\n        if (hideColumnOnExit) {\n            var dragItem = draggingEvent.dragSource.getDragItem();\n            var columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.setColumnsVisible = function (columns, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockVisible; });\n            this.columnController.setColumnsVisible(allowedCols, visible, source);\n        }\n    };\n    MoveColumnController.prototype.setColumnsPinned = function (columns, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (columns) {\n            var allowedCols = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            this.columnController.setColumnsPinned(allowedCols, pinned, source);\n        }\n    };\n    MoveColumnController.prototype.onDragStop = function () {\n        this.ensureIntervalCleared();\n    };\n    MoveColumnController.prototype.normaliseX = function (x) {\n        // flip the coordinate if doing RTL\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            var clientWidth = this.eContainer.clientWidth;\n            x = clientWidth - x;\n        }\n        // adjust for scroll only if centre container (the pinned containers don't scroll)\n        if (this.centerContainer) {\n            x += this.gridPanel.getCenterViewportScrollLeft();\n        }\n        return x;\n    };\n    MoveColumnController.prototype.checkCenterForScrolling = function (xAdjustedForScroll) {\n        if (this.centerContainer) {\n            // scroll if the mouse has gone outside the grid (or just outside the scrollable part if pinning)\n            // putting in 50 buffer, so even if user gets to edge of grid, a scroll will happen\n            var firstVisiblePixel = this.gridPanel.getCenterViewportScrollLeft();\n            var lastVisiblePixel = firstVisiblePixel + this.gridPanel.getCenterWidth();\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                this.needToMoveRight = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveLeft = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            else {\n                this.needToMoveLeft = xAdjustedForScroll < (firstVisiblePixel + 50);\n                this.needToMoveRight = xAdjustedForScroll > (lastVisiblePixel - 50);\n            }\n            if (this.needToMoveLeft || this.needToMoveRight) {\n                this.ensureIntervalStarted();\n            }\n            else {\n                this.ensureIntervalCleared();\n            }\n        }\n    };\n    MoveColumnController.prototype.onDragging = function (draggingEvent, fromEnter) {\n        var _this = this;\n        if (fromEnter === void 0) { fromEnter = false; }\n        this.lastDraggingEvent = draggingEvent;\n        // if moving up or down (ie not left or right) then do nothing\n        if (_.missing(draggingEvent.hDirection)) {\n            return;\n        }\n        var mouseXNormalised = this.normaliseX(draggingEvent.x);\n        // if the user is dragging into the panel, ie coming from the side panel into the main grid,\n        // we don't want to scroll the grid this time, it would appear like the table is jumping\n        // each time a column is dragged in.\n        if (!fromEnter) {\n            this.checkCenterForScrolling(mouseXNormalised);\n        }\n        var hDirectionNormalised = this.normaliseDirection(draggingEvent.hDirection);\n        var dragSourceType = draggingEvent.dragSource.type;\n        var columnsToMove = draggingEvent.dragSource.getDragItem().columns;\n        columnsToMove = columnsToMove.filter(function (col) {\n            if (col.getColDef().lockPinned) {\n                // if locked return true only if both col and container are same pin type.\n                // double equals (==) here on purpose so that null==undefined is true (for not pinned options)\n                return col.getPinned() == _this.pinned;\n            }\n            else {\n                // if not pin locked, then always allowed to be in this container\n                return true;\n            }\n        });\n        this.attemptMoveColumns(dragSourceType, columnsToMove, hDirectionNormalised, mouseXNormalised, fromEnter);\n    };\n    MoveColumnController.prototype.normaliseDirection = function (hDirection) {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            switch (hDirection) {\n                case HorizontalDirection.Left: return HorizontalDirection.Right;\n                case HorizontalDirection.Right: return HorizontalDirection.Left;\n                default: console.error(\"ag-Grid: Unknown direction \" + hDirection);\n            }\n        }\n        else {\n            return hDirection;\n        }\n    };\n    // returns the index of the first column in the list ONLY if the cols are all beside\n    // each other. if the cols are not beside each other, then returns null\n    MoveColumnController.prototype.calculateOldIndex = function (movingCols) {\n        var gridCols = this.columnController.getAllGridColumns();\n        var indexes = _.sortNumerically(movingCols.map(function (col) { return gridCols.indexOf(col); }));\n        var firstIndex = indexes[0];\n        var lastIndex = _.last(indexes);\n        var spread = lastIndex - firstIndex;\n        var gapsExist = spread !== indexes.length - 1;\n        return gapsExist ? null : firstIndex;\n    };\n    MoveColumnController.prototype.attemptMoveColumns = function (dragSourceType, allMovingColumns, hDirection, mouseX, fromEnter) {\n        var draggingLeft = hDirection === HorizontalDirection.Left;\n        var draggingRight = hDirection === HorizontalDirection.Right;\n        var validMoves = this.calculateValidMoves(allMovingColumns, draggingRight, mouseX);\n        // if cols are not adjacent, then this returns null. when moving, we constrain the direction of the move\n        // (ie left or right) to the mouse direction. however\n        var oldIndex = this.calculateOldIndex(allMovingColumns);\n        if (validMoves.length === 0) {\n            return;\n        }\n        var firstValidMove = validMoves[0];\n        // the two check below stop an error when the user grabs a group my a middle column, then\n        // it is possible the mouse pointer is to the right of a column while been dragged left.\n        // so we need to make sure that the mouse pointer is actually left of the left most column\n        // if moving left, and right of the right most column if moving right\n        // we check 'fromEnter' below so we move the column to the new spot if the mouse is coming from\n        // outside the grid, eg if the column is moving from side panel, mouse is moving left, then we should\n        // place the column to the RHS even if the mouse is moving left and the column is already on\n        // the LHS. otherwise we stick to the rule described above.\n        var constrainDirection = oldIndex !== null && !fromEnter;\n        // don't consider 'fromEnter' when dragging header cells, otherwise group can jump to opposite direction of drag\n        if (dragSourceType == DragSourceType.HeaderCell) {\n            constrainDirection = oldIndex !== null;\n        }\n        if (constrainDirection) {\n            // only allow left drag if this column is moving left\n            if (draggingLeft && firstValidMove >= oldIndex) {\n                return;\n            }\n            // only allow right drag if this column is moving right\n            if (draggingRight && firstValidMove <= oldIndex) {\n                return;\n            }\n        }\n        for (var i = 0; i < validMoves.length; i++) {\n            var move = validMoves[i];\n            if (!this.columnController.doesMovePassRules(allMovingColumns, move)) {\n                continue;\n            }\n            this.columnController.moveColumns(allMovingColumns, move, \"uiColumnDragged\");\n            // important to return here, so once we do the first valid move, we don't try do any more\n            return;\n        }\n    };\n    MoveColumnController.prototype.calculateValidMoves = function (movingCols, draggingRight, mouseX) {\n        var isMoveBlocked = this.gridOptionsWrapper.isSuppressMovableColumns() || movingCols.some(function (col) { return col.getColDef().suppressMovable; });\n        if (isMoveBlocked) {\n            return [];\n        }\n        // this is the list of cols on the screen, so it's these we use when comparing the x mouse position\n        var allDisplayedCols = this.columnController.getDisplayedColumns(this.pinned);\n        // but this list is the list of all cols, when we move a col it's the index within this list that gets used,\n        // so the result we return has to be and index location for this list\n        var allGridCols = this.columnController.getAllGridColumns();\n        var movingDisplayedCols = allDisplayedCols.filter(function (col) { return _.includes(movingCols, col); });\n        var otherDisplayedCols = allDisplayedCols.filter(function (col) { return !_.includes(movingCols, col); });\n        var otherGridCols = allGridCols.filter(function (col) { return !_.includes(movingCols, col); });\n        // work out how many DISPLAYED columns fit before the 'x' position. this gives us the displayIndex.\n        // for example, if cols are a,b,c,d and we find a,b fit before 'x', then we want to place the moving\n        // col between b and c (so that it is under the mouse position).\n        var displayIndex = 0;\n        var availableWidth = mouseX;\n        // if we are dragging right, then the columns will be to the left of the mouse, so we also want to\n        // include the width of the moving columns\n        if (draggingRight) {\n            var widthOfMovingDisplayedCols_1 = 0;\n            movingDisplayedCols.forEach(function (col) { return widthOfMovingDisplayedCols_1 += col.getActualWidth(); });\n            availableWidth -= widthOfMovingDisplayedCols_1;\n        }\n        if (availableWidth > 0) {\n            // now count how many of the displayed columns will fit to the left\n            for (var i = 0; i < otherDisplayedCols.length; i++) {\n                var col = otherDisplayedCols[i];\n                availableWidth -= col.getActualWidth();\n                if (availableWidth < 0) {\n                    break;\n                }\n                displayIndex++;\n            }\n            // trial and error, if going right, we adjust by one, i didn't manage to quantify why, but it works\n            if (draggingRight) {\n                displayIndex++;\n            }\n        }\n        // the display index is with respect to all the showing columns, however when we move, it's with\n        // respect to all grid columns, so we need to translate from display index to grid index\n        var firstValidMove;\n        if (displayIndex > 0) {\n            var leftColumn = otherDisplayedCols[displayIndex - 1];\n            firstValidMove = otherGridCols.indexOf(leftColumn) + 1;\n        }\n        else {\n            firstValidMove = otherGridCols.indexOf(otherDisplayedCols[0]);\n            if (firstValidMove === -1) {\n                firstValidMove = 0;\n            }\n        }\n        var validMoves = [firstValidMove];\n        // add in other valid moves due to hidden columns and married children. for example, a particular\n        // move might break a group that has married children (so move isn't valid), however there could\n        // be hidden columns (not displayed) that we could jump over to make the move valid. because\n        // they are hidden, user doesn't see any different, however it allows moves that would otherwise\n        // not work. for example imagine a group with 9 columns and all columns are hidden except the\n        // middle one (so 4 hidden to left, 4 hidden to right), then when moving 'firstValidMove' will\n        // be relative to the not-shown column, however we need to consider the move jumping over all the\n        // hidden children. if we didn't do this, then if the group just described was at the end (RHS) of the\n        // grid, there would be no way to put a column after it (as the grid would only consider beside the\n        // visible column, which would fail valid move rules).\n        if (draggingRight) {\n            // if dragging right, then we add all the additional moves to the right. so in other words\n            // if the next move is not valid, find the next move to the right that is valid.\n            var pointer = firstValidMove + 1;\n            var lastIndex = allGridCols.length - 1;\n            while (pointer <= lastIndex) {\n                validMoves.push(pointer);\n                pointer++;\n            }\n        }\n        else {\n            // if dragging left we do the reverse of dragging right, we add in all the valid moves to the\n            // left. however we also have to consider moves to the right for all hidden columns first.\n            // (this logic is hard to reason with, it was worked out with trial and error,\n            // move observation rather than science).\n            // add moves to the right\n            var pointer = firstValidMove;\n            var lastIndex = allGridCols.length - 1;\n            var displacedCol = allGridCols[pointer];\n            while (pointer <= lastIndex && this.isColumnHidden(allDisplayedCols, displacedCol)) {\n                pointer++;\n                validMoves.push(pointer);\n                displacedCol = allGridCols[pointer];\n            }\n            // add moves to the left\n            pointer = firstValidMove - 1;\n            var firstDisplayIndex = 0;\n            while (pointer >= firstDisplayIndex) {\n                validMoves.push(pointer);\n                pointer--;\n            }\n        }\n        return validMoves;\n    };\n    // isHidden takes into account visible=false and group=closed, ie it is not displayed\n    MoveColumnController.prototype.isColumnHidden = function (displayedColumns, col) {\n        return displayedColumns.indexOf(col) < 0;\n    };\n    MoveColumnController.prototype.ensureIntervalStarted = function () {\n        if (!this.movingIntervalId) {\n            this.intervalCount = 0;\n            this.failedMoveAttempts = 0;\n            this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100);\n            if (this.needToMoveLeft) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_LEFT, true);\n            }\n            else {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_RIGHT, true);\n            }\n        }\n    };\n    MoveColumnController.prototype.ensureIntervalCleared = function () {\n        if (this.moveInterval) {\n            window.clearInterval(this.movingIntervalId);\n            this.movingIntervalId = null;\n            this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_MOVE);\n        }\n    };\n    MoveColumnController.prototype.moveInterval = function () {\n        // the amounts we move get bigger at each interval, so the speed accelerates, starting a bit slow\n        // and getting faster. this is to give smoother user experience. we max at 100px to limit the speed.\n        var pixelsToMove;\n        this.intervalCount++;\n        pixelsToMove = 10 + (this.intervalCount * 5);\n        if (pixelsToMove > 100) {\n            pixelsToMove = 100;\n        }\n        var pixelsMoved;\n        if (this.needToMoveLeft) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(-pixelsToMove);\n        }\n        else if (this.needToMoveRight) {\n            pixelsMoved = this.gridPanel.scrollHorizontally(pixelsToMove);\n        }\n        if (pixelsMoved !== 0) {\n            this.onDragging(this.lastDraggingEvent);\n            this.failedMoveAttempts = 0;\n        }\n        else {\n            // we count the failed move attempts. if we fail to move 7 times, then we pin the column.\n            // this is how we achieve pining by dragging the column to the edge of the grid.\n            this.failedMoveAttempts++;\n            var columns = this.lastDraggingEvent.dragItem.columns;\n            var columnsThatCanPin = columns.filter(function (c) { return !c.getColDef().lockPinned; });\n            if (columnsThatCanPin.length > 0) {\n                this.dragAndDropService.setGhostIcon(DragAndDropService.ICON_PINNED);\n                if (this.failedMoveAttempts > 7) {\n                    var pinType = this.needToMoveLeft ? Constants.PINNED_LEFT : Constants.PINNED_RIGHT;\n                    this.setColumnsPinned(columnsThatCanPin, pinType, \"uiColumnDragged\");\n                    this.dragAndDropService.nudge();\n                }\n            }\n        }\n    };\n    __decorate([\n        Autowired('loggerFactory')\n    ], MoveColumnController.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        Autowired('columnController')\n    ], MoveColumnController.prototype, \"columnController\", void 0);\n    __decorate([\n        Autowired('dragAndDropService')\n    ], MoveColumnController.prototype, \"dragAndDropService\", void 0);\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], MoveColumnController.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        PostConstruct\n    ], MoveColumnController.prototype, \"init\", null);\n    return MoveColumnController;\n}());\nexport { MoveColumnController };\n"]},"metadata":{},"sourceType":"module"}