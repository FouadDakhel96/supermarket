{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { BeanStub } from \"../../context/beanStub\";\nimport { RowNodeBlock } from \"./rowNodeBlock\";\nimport { NumberSequence, _ } from \"../../utils\";\nimport { Autowired, PostConstruct, PreDestroy } from \"../../context/context\";\n\nvar RowNodeCache =\n/** @class */\nfunction (_super) {\n  __extends(RowNodeCache, _super);\n\n  function RowNodeCache(cacheParams) {\n    var _this = _super.call(this) || this;\n\n    _this.maxRowFound = false;\n    _this.blocks = {};\n    _this.blockCount = 0;\n    _this.virtualRowCount = cacheParams.initialRowCount;\n    _this.cacheParams = cacheParams;\n    return _this;\n  }\n\n  RowNodeCache.prototype.destroyAllBlocks = function () {\n    var _this = this;\n\n    this.forEachBlockInOrder(function (block) {\n      return _this.destroyBlock(block);\n    });\n  };\n\n  RowNodeCache.prototype.init = function () {\n    var _this = this;\n\n    this.active = true;\n    this.addDestroyFunc(function () {\n      return _this.active = false;\n    });\n  };\n\n  RowNodeCache.prototype.isActive = function () {\n    return this.active;\n  };\n\n  RowNodeCache.prototype.getVirtualRowCount = function () {\n    return this.virtualRowCount;\n  };\n\n  RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {\n    this.virtualRowCount = virtualRowCount;\n  };\n\n  RowNodeCache.prototype.isMaxRowFound = function () {\n    return this.maxRowFound;\n  }; // listener on EVENT_LOAD_COMPLETE\n\n\n  RowNodeCache.prototype.onPageLoaded = function (event) {\n    this.cacheParams.rowNodeBlockLoader.loadComplete();\n    this.checkBlockToLoad(); // if we are not active, then we ignore all events, otherwise we could end up getting the\n    // grid to refresh even though we are no longer the active cache\n\n    if (!this.isActive()) {\n      return;\n    }\n\n    this.logger.log(\"onPageLoaded: page = \" + event.page.getBlockNumber() + \", lastRow = \" + event.lastRow);\n\n    if (event.success) {\n      this.checkVirtualRowCount(event.page, event.lastRow);\n    }\n  };\n\n  RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n    var _this = this; // put all candidate blocks into a list for sorting\n\n\n    var blocksForPurging = [];\n    this.forEachBlockInOrder(function (block) {\n      // we exclude checking for the page just created, as this has yet to be accessed and hence\n      // the lastAccessed stamp will not be updated for the first time yet\n      if (block === blockToExclude) {\n        return;\n      }\n\n      blocksForPurging.push(block);\n    }); // note: need to verify that this sorts items in the right order\n\n    blocksForPurging.sort(function (a, b) {\n      return b.getLastAccessed() - a.getLastAccessed();\n    }); // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n    // in other words, after the splice operation below, we have taken out the blocks\n    // we want to keep, which means we are left with blocks that we can potentially purge\n\n    var maxBlocksProvided = this.cacheParams.maxBlocksInCache > 0;\n    var blocksToKeep = maxBlocksProvided ? this.cacheParams.maxBlocksInCache - 1 : null;\n    var emptyBlocksToKeep = RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n    blocksForPurging.forEach(function (block, index) {\n      var purgeBecauseBlockEmpty = block.getState() === RowNodeBlock.STATE_DIRTY && index >= emptyBlocksToKeep;\n      var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n\n      if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n        // we never purge blocks if they are open, as purging them would mess up with\n        // our indexes, it would be very messy to restore the purged block to it's\n        // previous state if it had open children (and what if open children of open\n        // children, jeeeesus, just thinking about it freaks me out) so best is have a\n        // rule, if block is open, we never purge.\n        if (block.isAnyNodeOpen(_this.virtualRowCount)) {\n          return;\n        } // if the block currently has rows been displayed, then don't remove it either.\n        // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n        // but the screen is showing 20 rows, so at least 4 blocks are needed.\n\n\n        if (_this.isBlockCurrentlyDisplayed(block)) {\n          return;\n        } // at this point, block is not needed, and no open nodes, so burn baby burn\n\n\n        _this.removeBlockFromCache(block);\n      }\n    });\n  };\n\n  RowNodeCache.prototype.isBlockCurrentlyDisplayed = function (block) {\n    var firstViewportRow = this.rowRenderer.getFirstVirtualRenderedRow();\n    var lastViewportRow = this.rowRenderer.getLastVirtualRenderedRow();\n    var firstRowIndex = block.getDisplayIndexStart();\n    var lastRowIndex = block.getDisplayIndexEnd() - 1; // parent closed means the parent node is not expanded, thus these blocks are not visible\n\n    var parentClosed = firstRowIndex == null || lastRowIndex == null;\n\n    if (parentClosed) {\n      return false;\n    }\n\n    var blockBeforeViewport = firstRowIndex > lastViewportRow;\n    var blockAfterViewport = lastRowIndex < firstViewportRow;\n    var blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n    return blockInsideViewport;\n  };\n\n  RowNodeCache.prototype.postCreateBlock = function (newBlock) {\n    newBlock.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\n    this.setBlock(newBlock.getBlockNumber(), newBlock);\n    this.purgeBlocksIfNeeded(newBlock);\n    this.checkBlockToLoad();\n  };\n\n  RowNodeCache.prototype.removeBlockFromCache = function (blockToRemove) {\n    if (!blockToRemove) {\n      return;\n    }\n\n    this.destroyBlock(blockToRemove); // we do not want to remove the 'loaded' event listener, as the\n    // concurrent loads count needs to be updated when the load is complete\n    // if the purged page is in loading state\n  }; // gets called after: 1) block loaded 2) block created 3) cache refresh\n\n\n  RowNodeCache.prototype.checkBlockToLoad = function () {\n    this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\n  };\n\n  RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {\n    // if client provided a last row, we always use it, as it could change between server calls\n    // if user deleted data and then called refresh on the grid.\n    if (typeof lastRow === 'number' && lastRow >= 0) {\n      this.virtualRowCount = lastRow;\n      this.maxRowFound = true;\n      this.onCacheUpdated();\n    } else if (!this.maxRowFound) {\n      // otherwise, see if we need to add some virtual rows\n      var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\n      var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\n\n      if (this.virtualRowCount < lastRowIndexPlusOverflow) {\n        this.virtualRowCount = lastRowIndexPlusOverflow;\n        this.onCacheUpdated();\n      } else if (this.cacheParams.dynamicRowHeight) {\n        // the only other time is if dynamic row height, as loading rows\n        // will change the height of the block, given the height of the rows\n        // is only known after the row is loaded.\n        this.onCacheUpdated();\n      }\n    }\n  };\n\n  RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\n    this.virtualRowCount = rowCount; // if undefined is passed, we do not set this value, if one of {true,false}\n    // is passed, we do set the value.\n\n    if (_.exists(maxRowFound)) {\n      this.maxRowFound = maxRowFound;\n    } // if we are still searching, then the row count must not end at the end\n    // of a particular page, otherwise the searching will not pop into the\n    // next page\n\n\n    if (!this.maxRowFound) {\n      if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\n        this.virtualRowCount++;\n      }\n    }\n\n    this.onCacheUpdated();\n  };\n\n  RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {\n    var _this = this;\n\n    if (sequence === void 0) {\n      sequence = new NumberSequence();\n    }\n\n    this.forEachBlockInOrder(function (block) {\n      block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);\n    });\n  };\n\n  RowNodeCache.prototype.forEachBlockInOrder = function (callback) {\n    var ids = this.getBlockIdsSorted();\n    this.forEachBlockId(ids, callback);\n  };\n\n  RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {\n    var ids = this.getBlockIdsSorted().reverse();\n    this.forEachBlockId(ids, callback);\n  };\n\n  RowNodeCache.prototype.forEachBlockId = function (ids, callback) {\n    var _this = this;\n\n    ids.forEach(function (id) {\n      var block = _this.blocks[id];\n      callback(block, id);\n    });\n  };\n\n  RowNodeCache.prototype.getBlockIdsSorted = function () {\n    // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n    var numberComparator = function (a, b) {\n      return a - b;\n    }; // default comparator for array is string comparison\n\n\n    var blockIds = Object.keys(this.blocks).map(function (idStr) {\n      return parseInt(idStr, 10);\n    }).sort(numberComparator);\n    return blockIds;\n  };\n\n  RowNodeCache.prototype.getBlock = function (blockId) {\n    return this.blocks[blockId];\n  };\n\n  RowNodeCache.prototype.setBlock = function (id, block) {\n    this.blocks[id] = block;\n    this.blockCount++;\n    this.cacheParams.rowNodeBlockLoader.addBlock(block);\n  };\n\n  RowNodeCache.prototype.destroyBlock = function (block) {\n    delete this.blocks[block.getBlockNumber()];\n    this.destroyBean(block);\n    this.blockCount--;\n    this.cacheParams.rowNodeBlockLoader.removeBlock(block);\n  }; // gets called 1) row count changed 2) cache purged 3) items inserted\n\n\n  RowNodeCache.prototype.onCacheUpdated = function () {\n    if (this.isActive()) {\n      // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n      // in the valid range. so we must remove these. this can happen if user explicitly sets\n      // the virtual row count, or the datasource returns a result and sets lastRow to something\n      // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n      this.destroyAllBlocksPastVirtualRowCount(); // this results in both row models (infinite and server side) firing ModelUpdated,\n      // however server side row model also updates the row indexes first\n\n      var event_1 = {\n        type: RowNodeCache.EVENT_CACHE_UPDATED\n      };\n      this.dispatchEvent(event_1);\n    }\n  };\n\n  RowNodeCache.prototype.destroyAllBlocksPastVirtualRowCount = function () {\n    var _this = this;\n\n    var blocksToDestroy = [];\n    this.forEachBlockInOrder(function (block, id) {\n      var startRow = id * _this.cacheParams.blockSize;\n\n      if (startRow >= _this.virtualRowCount) {\n        blocksToDestroy.push(block);\n      }\n    });\n\n    if (blocksToDestroy.length > 0) {\n      blocksToDestroy.forEach(function (block) {\n        return _this.destroyBlock(block);\n      });\n    }\n  };\n\n  RowNodeCache.prototype.purgeCache = function () {\n    var _this = this;\n\n    this.forEachBlockInOrder(function (block) {\n      return _this.removeBlockFromCache(block);\n    });\n    this.maxRowFound = false; // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n    // otherwise if set to zero rows last time, and we don't update the row count, then after\n    // the purge there will still be zero rows, meaning the SRRM won't request any rows.\n    // to kick things off, at lest one row needs to be asked for.\n\n    if (this.virtualRowCount === 0) {\n      this.virtualRowCount = this.cacheParams.initialRowCount;\n    }\n\n    this.onCacheUpdated();\n  };\n\n  RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n    var _this = this;\n\n    var result = [];\n    var lastBlockId = -1;\n    var inActiveRange = false;\n    var numberSequence = new NumberSequence(); // if only one node passed, we start the selection at the top\n\n    if (_.missing(firstInRange)) {\n      inActiveRange = true;\n    }\n\n    var foundGapInSelection = false;\n    this.forEachBlockInOrder(function (block, id) {\n      if (foundGapInSelection) {\n        return;\n      }\n\n      if (inActiveRange && lastBlockId + 1 !== id) {\n        foundGapInSelection = true;\n        return;\n      }\n\n      lastBlockId = id;\n      block.forEachNodeShallow(function (rowNode) {\n        var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n\n        if (inActiveRange || hitFirstOrLast) {\n          result.push(rowNode);\n        }\n\n        if (hitFirstOrLast) {\n          inActiveRange = !inActiveRange;\n        }\n      }, numberSequence, _this.virtualRowCount);\n    }); // inActiveRange will be still true if we never hit the second rowNode\n\n    var invalidRange = foundGapInSelection || inActiveRange;\n    return invalidRange ? [] : result;\n  };\n\n  RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated'; // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n  // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n  // scrolled over are not needed to be loaded.\n\n  RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n\n  __decorate([Autowired('rowRenderer')], RowNodeCache.prototype, \"rowRenderer\", void 0);\n\n  __decorate([PreDestroy], RowNodeCache.prototype, \"destroyAllBlocks\", null);\n\n  __decorate([PostConstruct], RowNodeCache.prototype, \"init\", null);\n\n  return RowNodeCache;\n}(BeanStub);\n\nexport { RowNodeCache };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/modules/rowNodeCache/rowNodeCache.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","BeanStub","RowNodeBlock","NumberSequence","_","Autowired","PostConstruct","PreDestroy","RowNodeCache","_super","cacheParams","_this","call","maxRowFound","blocks","blockCount","virtualRowCount","initialRowCount","destroyAllBlocks","forEachBlockInOrder","block","destroyBlock","init","active","addDestroyFunc","isActive","getVirtualRowCount","hack_setVirtualRowCount","isMaxRowFound","onPageLoaded","event","rowNodeBlockLoader","loadComplete","checkBlockToLoad","logger","log","page","getBlockNumber","lastRow","success","checkVirtualRowCount","purgeBlocksIfNeeded","blockToExclude","blocksForPurging","push","sort","a","getLastAccessed","maxBlocksProvided","maxBlocksInCache","blocksToKeep","emptyBlocksToKeep","MAX_EMPTY_BLOCKS_TO_KEEP","forEach","index","purgeBecauseBlockEmpty","getState","STATE_DIRTY","purgeBecauseCacheFull","isAnyNodeOpen","isBlockCurrentlyDisplayed","removeBlockFromCache","firstViewportRow","rowRenderer","getFirstVirtualRenderedRow","lastViewportRow","getLastVirtualRenderedRow","firstRowIndex","getDisplayIndexStart","lastRowIndex","getDisplayIndexEnd","parentClosed","blockBeforeViewport","blockAfterViewport","blockInsideViewport","postCreateBlock","newBlock","addEventListener","EVENT_LOAD_COMPLETE","bind","setBlock","blockToRemove","onCacheUpdated","blockSize","lastRowIndexPlusOverflow","overflowSize","dynamicRowHeight","setVirtualRowCount","rowCount","exists","forEachNodeDeep","callback","sequence","ids","getBlockIdsSorted","forEachBlockId","forEachBlockInReverseOrder","reverse","id","numberComparator","blockIds","keys","map","idStr","parseInt","getBlock","blockId","addBlock","destroyBean","removeBlock","destroyAllBlocksPastVirtualRowCount","event_1","type","EVENT_CACHE_UPDATED","dispatchEvent","blocksToDestroy","startRow","purgeCache","getRowNodesInRange","firstInRange","lastInRange","result","lastBlockId","inActiveRange","numberSequence","missing","foundGapInSelection","forEachNodeShallow","rowNode","hitFirstOrLast","invalidRange"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { BeanStub } from \"../../context/beanStub\";\nimport { RowNodeBlock } from \"./rowNodeBlock\";\nimport { NumberSequence, _ } from \"../../utils\";\nimport { Autowired, PostConstruct, PreDestroy } from \"../../context/context\";\nvar RowNodeCache = /** @class */ (function (_super) {\n    __extends(RowNodeCache, _super);\n    function RowNodeCache(cacheParams) {\n        var _this = _super.call(this) || this;\n        _this.maxRowFound = false;\n        _this.blocks = {};\n        _this.blockCount = 0;\n        _this.virtualRowCount = cacheParams.initialRowCount;\n        _this.cacheParams = cacheParams;\n        return _this;\n    }\n    RowNodeCache.prototype.destroyAllBlocks = function () {\n        var _this = this;\n        this.forEachBlockInOrder(function (block) { return _this.destroyBlock(block); });\n    };\n    RowNodeCache.prototype.init = function () {\n        var _this = this;\n        this.active = true;\n        this.addDestroyFunc(function () { return _this.active = false; });\n    };\n    RowNodeCache.prototype.isActive = function () {\n        return this.active;\n    };\n    RowNodeCache.prototype.getVirtualRowCount = function () {\n        return this.virtualRowCount;\n    };\n    RowNodeCache.prototype.hack_setVirtualRowCount = function (virtualRowCount) {\n        this.virtualRowCount = virtualRowCount;\n    };\n    RowNodeCache.prototype.isMaxRowFound = function () {\n        return this.maxRowFound;\n    };\n    // listener on EVENT_LOAD_COMPLETE\n    RowNodeCache.prototype.onPageLoaded = function (event) {\n        this.cacheParams.rowNodeBlockLoader.loadComplete();\n        this.checkBlockToLoad();\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isActive()) {\n            return;\n        }\n        this.logger.log(\"onPageLoaded: page = \" + event.page.getBlockNumber() + \", lastRow = \" + event.lastRow);\n        if (event.success) {\n            this.checkVirtualRowCount(event.page, event.lastRow);\n        }\n    };\n    RowNodeCache.prototype.purgeBlocksIfNeeded = function (blockToExclude) {\n        var _this = this;\n        // put all candidate blocks into a list for sorting\n        var blocksForPurging = [];\n        this.forEachBlockInOrder(function (block) {\n            // we exclude checking for the page just created, as this has yet to be accessed and hence\n            // the lastAccessed stamp will not be updated for the first time yet\n            if (block === blockToExclude) {\n                return;\n            }\n            blocksForPurging.push(block);\n        });\n        // note: need to verify that this sorts items in the right order\n        blocksForPurging.sort(function (a, b) { return b.getLastAccessed() - a.getLastAccessed(); });\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        var maxBlocksProvided = this.cacheParams.maxBlocksInCache > 0;\n        var blocksToKeep = maxBlocksProvided ? this.cacheParams.maxBlocksInCache - 1 : null;\n        var emptyBlocksToKeep = RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n        blocksForPurging.forEach(function (block, index) {\n            var purgeBecauseBlockEmpty = block.getState() === RowNodeBlock.STATE_DIRTY && index >= emptyBlocksToKeep;\n            var purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep : false;\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n                // we never purge blocks if they are open, as purging them would mess up with\n                // our indexes, it would be very messy to restore the purged block to it's\n                // previous state if it had open children (and what if open children of open\n                // children, jeeeesus, just thinking about it freaks me out) so best is have a\n                // rule, if block is open, we never purge.\n                if (block.isAnyNodeOpen(_this.virtualRowCount)) {\n                    return;\n                }\n                // if the block currently has rows been displayed, then don't remove it either.\n                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n                // but the screen is showing 20 rows, so at least 4 blocks are needed.\n                if (_this.isBlockCurrentlyDisplayed(block)) {\n                    return;\n                }\n                // at this point, block is not needed, and no open nodes, so burn baby burn\n                _this.removeBlockFromCache(block);\n            }\n        });\n    };\n    RowNodeCache.prototype.isBlockCurrentlyDisplayed = function (block) {\n        var firstViewportRow = this.rowRenderer.getFirstVirtualRenderedRow();\n        var lastViewportRow = this.rowRenderer.getLastVirtualRenderedRow();\n        var firstRowIndex = block.getDisplayIndexStart();\n        var lastRowIndex = block.getDisplayIndexEnd() - 1;\n        // parent closed means the parent node is not expanded, thus these blocks are not visible\n        var parentClosed = firstRowIndex == null || lastRowIndex == null;\n        if (parentClosed) {\n            return false;\n        }\n        var blockBeforeViewport = firstRowIndex > lastViewportRow;\n        var blockAfterViewport = lastRowIndex < firstViewportRow;\n        var blockInsideViewport = !blockBeforeViewport && !blockAfterViewport;\n        return blockInsideViewport;\n    };\n    RowNodeCache.prototype.postCreateBlock = function (newBlock) {\n        newBlock.addEventListener(RowNodeBlock.EVENT_LOAD_COMPLETE, this.onPageLoaded.bind(this));\n        this.setBlock(newBlock.getBlockNumber(), newBlock);\n        this.purgeBlocksIfNeeded(newBlock);\n        this.checkBlockToLoad();\n    };\n    RowNodeCache.prototype.removeBlockFromCache = function (blockToRemove) {\n        if (!blockToRemove) {\n            return;\n        }\n        this.destroyBlock(blockToRemove);\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    };\n    // gets called after: 1) block loaded 2) block created 3) cache refresh\n    RowNodeCache.prototype.checkBlockToLoad = function () {\n        this.cacheParams.rowNodeBlockLoader.checkBlockToLoad();\n    };\n    RowNodeCache.prototype.checkVirtualRowCount = function (block, lastRow) {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.virtualRowCount = lastRow;\n            this.maxRowFound = true;\n            this.onCacheUpdated();\n        }\n        else if (!this.maxRowFound) {\n            // otherwise, see if we need to add some virtual rows\n            var lastRowIndex = (block.getBlockNumber() + 1) * this.cacheParams.blockSize;\n            var lastRowIndexPlusOverflow = lastRowIndex + this.cacheParams.overflowSize;\n            if (this.virtualRowCount < lastRowIndexPlusOverflow) {\n                this.virtualRowCount = lastRowIndexPlusOverflow;\n                this.onCacheUpdated();\n            }\n            else if (this.cacheParams.dynamicRowHeight) {\n                // the only other time is if dynamic row height, as loading rows\n                // will change the height of the block, given the height of the rows\n                // is only known after the row is loaded.\n                this.onCacheUpdated();\n            }\n        }\n    };\n    RowNodeCache.prototype.setVirtualRowCount = function (rowCount, maxRowFound) {\n        this.virtualRowCount = rowCount;\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (_.exists(maxRowFound)) {\n            this.maxRowFound = maxRowFound;\n        }\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.maxRowFound) {\n            if (this.virtualRowCount % this.cacheParams.blockSize === 0) {\n                this.virtualRowCount++;\n            }\n        }\n        this.onCacheUpdated();\n    };\n    RowNodeCache.prototype.forEachNodeDeep = function (callback, sequence) {\n        var _this = this;\n        if (sequence === void 0) { sequence = new NumberSequence(); }\n        this.forEachBlockInOrder(function (block) {\n            block.forEachNodeDeep(callback, sequence, _this.virtualRowCount);\n        });\n    };\n    RowNodeCache.prototype.forEachBlockInOrder = function (callback) {\n        var ids = this.getBlockIdsSorted();\n        this.forEachBlockId(ids, callback);\n    };\n    RowNodeCache.prototype.forEachBlockInReverseOrder = function (callback) {\n        var ids = this.getBlockIdsSorted().reverse();\n        this.forEachBlockId(ids, callback);\n    };\n    RowNodeCache.prototype.forEachBlockId = function (ids, callback) {\n        var _this = this;\n        ids.forEach(function (id) {\n            var block = _this.blocks[id];\n            callback(block, id);\n        });\n    };\n    RowNodeCache.prototype.getBlockIdsSorted = function () {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        var numberComparator = function (a, b) { return a - b; }; // default comparator for array is string comparison\n        var blockIds = Object.keys(this.blocks).map(function (idStr) { return parseInt(idStr, 10); }).sort(numberComparator);\n        return blockIds;\n    };\n    RowNodeCache.prototype.getBlock = function (blockId) {\n        return this.blocks[blockId];\n    };\n    RowNodeCache.prototype.setBlock = function (id, block) {\n        this.blocks[id] = block;\n        this.blockCount++;\n        this.cacheParams.rowNodeBlockLoader.addBlock(block);\n    };\n    RowNodeCache.prototype.destroyBlock = function (block) {\n        delete this.blocks[block.getBlockNumber()];\n        this.destroyBean(block);\n        this.blockCount--;\n        this.cacheParams.rowNodeBlockLoader.removeBlock(block);\n    };\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    RowNodeCache.prototype.onCacheUpdated = function () {\n        if (this.isActive()) {\n            // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n            // in the valid range. so we must remove these. this can happen if user explicitly sets\n            // the virtual row count, or the datasource returns a result and sets lastRow to something\n            // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n            this.destroyAllBlocksPastVirtualRowCount();\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            var event_1 = {\n                type: RowNodeCache.EVENT_CACHE_UPDATED\n            };\n            this.dispatchEvent(event_1);\n        }\n    };\n    RowNodeCache.prototype.destroyAllBlocksPastVirtualRowCount = function () {\n        var _this = this;\n        var blocksToDestroy = [];\n        this.forEachBlockInOrder(function (block, id) {\n            var startRow = id * _this.cacheParams.blockSize;\n            if (startRow >= _this.virtualRowCount) {\n                blocksToDestroy.push(block);\n            }\n        });\n        if (blocksToDestroy.length > 0) {\n            blocksToDestroy.forEach(function (block) { return _this.destroyBlock(block); });\n        }\n    };\n    RowNodeCache.prototype.purgeCache = function () {\n        var _this = this;\n        this.forEachBlockInOrder(function (block) { return _this.removeBlockFromCache(block); });\n        this.maxRowFound = false;\n        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n        // otherwise if set to zero rows last time, and we don't update the row count, then after\n        // the purge there will still be zero rows, meaning the SRRM won't request any rows.\n        // to kick things off, at lest one row needs to be asked for.\n        if (this.virtualRowCount === 0) {\n            this.virtualRowCount = this.cacheParams.initialRowCount;\n        }\n        this.onCacheUpdated();\n    };\n    RowNodeCache.prototype.getRowNodesInRange = function (firstInRange, lastInRange) {\n        var _this = this;\n        var result = [];\n        var lastBlockId = -1;\n        var inActiveRange = false;\n        var numberSequence = new NumberSequence();\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n        var foundGapInSelection = false;\n        this.forEachBlockInOrder(function (block, id) {\n            if (foundGapInSelection) {\n                return;\n            }\n            if (inActiveRange && (lastBlockId + 1 !== id)) {\n                foundGapInSelection = true;\n                return;\n            }\n            lastBlockId = id;\n            block.forEachNodeShallow(function (rowNode) {\n                var hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n            }, numberSequence, _this.virtualRowCount);\n        });\n        // inActiveRange will be still true if we never hit the second rowNode\n        var invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    };\n    RowNodeCache.EVENT_CACHE_UPDATED = 'cacheUpdated';\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    RowNodeCache.MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n    __decorate([\n        Autowired('rowRenderer')\n    ], RowNodeCache.prototype, \"rowRenderer\", void 0);\n    __decorate([\n        PreDestroy\n    ], RowNodeCache.prototype, \"destroyAllBlocks\", null);\n    __decorate([\n        PostConstruct\n    ], RowNodeCache.prototype, \"init\", null);\n    return RowNodeCache;\n}(BeanStub));\nexport { RowNodeCache };\n"]},"metadata":{},"sourceType":"module"}