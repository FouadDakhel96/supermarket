{"ast":null,"code":"// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n  for (var i = 0, ln = arr.length; i < ln; i++) {\n    var value = arr[i];\n\n    if (predicate(value, i, arr)) {\n      return value;\n    }\n  }\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\n\nexport function extent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value) {\n      min = max = value;\n\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null) {\n          if (min > value) {\n            min = value;\n          }\n\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n  var n = values.length;\n  var i = -1;\n  var value;\n  var min;\n  var max;\n\n  while (++i < n) {\n    // Find the first comparable finite value.\n    if ((value = values[i]) != null && value >= value && isFinite(value)) {\n      min = max = value;\n\n      while (++i < n) {\n        // Compare the remaining values.\n        if ((value = values[i]) != null && isFinite(value)) {\n          if (min > value) {\n            min = value;\n          }\n\n          if (max < value) {\n            max = value;\n          }\n        }\n      }\n    }\n  }\n\n  return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\n\nexport function numericExtent(values) {\n  var calculatedExtent = finiteExtent(values);\n\n  if (typeof calculatedExtent === 'undefined') {\n    return;\n  }\n\n  var a = calculatedExtent[0],\n      b = calculatedExtent[1];\n  var min = a instanceof Date ? a.getTime() : a;\n  var max = b instanceof Date ? b.getTime() : b;\n\n  if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n    return [min, max];\n  }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\n\nexport function findMinMax(values) {\n  var min = 0;\n  var max = 0;\n\n  for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n    var value = values_1[_i];\n\n    if (value < 0) {\n      min += value;\n    } else {\n      max += value;\n    }\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}\nexport function findLargestMinMax(totals) {\n  var min = 0;\n  var max = 0;\n\n  for (var _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {\n    var total = totals_1[_i];\n\n    if (total.min < min) {\n      min = total.min;\n    }\n\n    if (total.max > max) {\n      max = total.max;\n    }\n  }\n\n  return {\n    min: min,\n    max: max\n  };\n}","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/ag-charts-community/dist/es6/util/array.js"],"names":["find","arr","predicate","i","ln","length","value","extent","values","n","min","max","undefined","finiteExtent","isFinite","numericExtent","calculatedExtent","a","b","Date","getTime","findMinMax","_i","values_1","findLargestMinMax","totals","totals_1","total"],"mappings":"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","sourcesContent":["// Custom `Array.find` implementation for legacy browsers.\nexport function find(arr, predicate) {\n    for (var i = 0, ln = arr.length; i < ln; i++) {\n        var value = arr[i];\n        if (predicate(value, i, arr)) {\n            return value;\n        }\n    }\n}\n/**\n * Returns the minimum and maximum value in the given iterable using natural order.\n * If the iterable contains no comparable values, returns `undefined`.\n * @param values\n */\nexport function extent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return typeof min === 'undefined' || typeof max === 'undefined' ? undefined : [min, max];\n}\nexport function finiteExtent(values) {\n    var n = values.length;\n    var i = -1;\n    var value;\n    var min;\n    var max;\n    while (++i < n) { // Find the first comparable finite value.\n        if ((value = values[i]) != null && value >= value && isFinite(value)) {\n            min = max = value;\n            while (++i < n) { // Compare the remaining values.\n                if ((value = values[i]) != null && isFinite(value)) {\n                    if (min > value) {\n                        min = value;\n                    }\n                    if (max < value) {\n                        max = value;\n                    }\n                }\n            }\n        }\n    }\n    return min === undefined || max === undefined ? undefined : [min, max];\n}\n/**\n * This method will only return `undefined` if there's not a single valid finite number present\n * in the given array of values. Date values will be converted to timestamps.\n * @param values\n */\nexport function numericExtent(values) {\n    var calculatedExtent = finiteExtent(values);\n    if (typeof calculatedExtent === 'undefined') {\n        return;\n    }\n    var a = calculatedExtent[0], b = calculatedExtent[1];\n    var min = a instanceof Date ? a.getTime() : a;\n    var max = b instanceof Date ? b.getTime() : b;\n    if (typeof min === 'number' && isFinite(min) && typeof max === 'number' && isFinite(max)) {\n        return [min, max];\n    }\n}\n/**\n * finds the min and max using a process appropriate for stacked values. Ie,\n * summing up the positive and negative numbers, and returning the totals of each\n */\nexport function findMinMax(values) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\n        var value = values_1[_i];\n        if (value < 0) {\n            min += value;\n        }\n        else {\n            max += value;\n        }\n    }\n    return { min: min, max: max };\n}\nexport function findLargestMinMax(totals) {\n    var min = 0;\n    var max = 0;\n    for (var _i = 0, totals_1 = totals; _i < totals_1.length; _i++) {\n        var total = totals_1[_i];\n        if (total.min < min) {\n            min = total.min;\n        }\n        if (total.max > max) {\n            max = total.max;\n        }\n    }\n    return { min: min, max: max };\n}\n"]},"metadata":{},"sourceType":"module"}