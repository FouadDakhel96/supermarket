{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, Bean, BeanStub, NumberSequence, PostConstruct, RowNode, _ } from \"@ag-grid-community/core\";\n\nvar GroupStage =\n/** @class */\nfunction (_super) {\n  __extends(GroupStage, _super);\n\n  function GroupStage() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // we use a sequence variable so that each time we do a grouping, we don't\n    // reuse the ids - otherwise the rowRenderer will confuse rowNodes between redraws\n    // when it tries to animate between rows.\n\n\n    _this.groupIdSequence = new NumberSequence();\n    return _this;\n  }\n\n  GroupStage.prototype.postConstruct = function () {\n    this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n\n    if (this.usingTreeData) {\n      this.getDataPath = this.gridOptionsWrapper.getDataPathFunc();\n    }\n  };\n\n  GroupStage.prototype.execute = function (params) {\n    var details = this.createGroupingDetails(params);\n\n    if (details.transactions) {\n      this.handleTransaction(details);\n    } else {\n      var afterColsChanged = params.afterColumnsChanged === true;\n      this.shotgunResetEverything(details, afterColsChanged);\n    }\n\n    this.sortGroupsWithComparator(details.rootNode);\n    this.selectableService.updateSelectableAfterGrouping(details.rootNode);\n  };\n\n  GroupStage.prototype.createGroupingDetails = function (params) {\n    var rowNode = params.rowNode,\n        changedPath = params.changedPath,\n        rowNodeTransactions = params.rowNodeTransactions,\n        rowNodeOrder = params.rowNodeOrder;\n    var groupedCols = this.usingTreeData ? null : this.columnController.getRowGroupColumns();\n    var details = {\n      // someone complained that the parent attribute was causing some change detection\n      // to break is some angular add-on - which i never used. taking the parent out breaks\n      // a cyclic dependency, hence this flag got introduced.\n      includeParents: !this.gridOptionsWrapper.isSuppressParentsInRowNodes(),\n      expandByDefault: this.gridOptionsWrapper.isGroupSuppressRow() ? -1 : this.gridOptionsWrapper.getGroupDefaultExpanded(),\n      groupedCols: groupedCols,\n      rootNode: rowNode,\n      pivotMode: this.columnController.isPivotMode(),\n      groupedColCount: this.usingTreeData || !groupedCols ? 0 : groupedCols.length,\n      rowNodeOrder: rowNodeOrder,\n      transactions: rowNodeTransactions,\n      // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n      changedPath: changedPath\n    };\n    return details;\n  };\n\n  GroupStage.prototype.handleTransaction = function (details) {\n    var _this = this;\n\n    details.transactions.forEach(function (tran) {\n      // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,\n      // as the order is important when a record with the same id is added and removed in the same\n      // transaction.\n      if (_.existsAndNotEmpty(tran.add)) {\n        _this.insertNodes(tran.add, details, false);\n      }\n\n      if (_.existsAndNotEmpty(tran.remove)) {\n        _this.removeNodes(tran.remove, details);\n      }\n\n      if (_.existsAndNotEmpty(tran.update)) {\n        _this.moveNodesInWrongPath(tran.update, details);\n      }\n    });\n\n    if (details.rowNodeOrder) {\n      this.sortChildren(details);\n    }\n  }; // this is used when doing delta updates, eg Redux, keeps nodes in right order\n\n\n  GroupStage.prototype.sortChildren = function (details) {\n    details.changedPath.forEachChangedNodeDepthFirst(function (rowNode) {\n      _.sortRowNodesByOrder(rowNode.childrenAfterGroup, details.rowNodeOrder);\n    });\n  };\n\n  GroupStage.prototype.sortGroupsWithComparator = function (rootNode) {\n    // we don't do group sorting for tree data\n    if (this.usingTreeData) {\n      return;\n    }\n\n    var comparator = this.gridOptionsWrapper.getDefaultGroupSortComparator();\n\n    if (_.exists(comparator)) {\n      recursiveSort(rootNode);\n    }\n\n    function recursiveSort(rowNode) {\n      var doSort = _.exists(rowNode.childrenAfterGroup) && // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n      !rowNode.leafGroup;\n\n      if (doSort) {\n        rowNode.childrenAfterGroup.sort(comparator);\n        rowNode.childrenAfterGroup.forEach(function (childNode) {\n          return recursiveSort(childNode);\n        });\n      }\n    }\n  };\n\n  GroupStage.prototype.getExistingPathForNode = function (node, details) {\n    var res = []; // when doing tree data, the node is part of the path,\n    // but when doing grid grouping, the node is not part of the path so we start with the parent.\n\n    var pointer = this.usingTreeData ? node : node.parent;\n\n    while (pointer && pointer !== details.rootNode) {\n      res.push({\n        key: pointer.key,\n        rowGroupColumn: pointer.rowGroupColumn,\n        field: pointer.field\n      });\n      pointer = pointer.parent;\n    }\n\n    res.reverse();\n    return res;\n  };\n\n  GroupStage.prototype.moveNodesInWrongPath = function (childNodes, details) {\n    var _this = this;\n\n    childNodes.forEach(function (childNode) {\n      // we add node, even if parent has not changed, as the data could have\n      // changed, hence aggregations will be wrong\n      if (details.changedPath.isActive()) {\n        details.changedPath.addParentNode(childNode.parent);\n      }\n\n      var infoToKeyMapper = function infoToKeyMapper(item) {\n        return item.key;\n      };\n\n      var oldPath = _this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n\n      var newPath = _this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n\n      var nodeInCorrectPath = _.areEqual(oldPath, newPath);\n\n      if (!nodeInCorrectPath) {\n        _this.moveNode(childNode, details);\n      }\n    });\n  };\n\n  GroupStage.prototype.moveNode = function (childNode, details) {\n    this.removeNodesInStages([childNode], details);\n    this.insertOneNode(childNode, details, true); // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n    // refreshed into the gui.\n    // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n    // then will get each cell in the row to refresh - which is what we need as we don't know which\n    // columns will be displaying the rowNode.key info.\n\n    childNode.setData(childNode.data); // we add both old and new parents to changed path, as both will need to be refreshed.\n    // we already added the old parent (in calling method), so just add the new parent here\n\n    if (details.changedPath.isActive()) {\n      var newParent = childNode.parent;\n      details.changedPath.addParentNode(newParent);\n    }\n  };\n\n  GroupStage.prototype.removeNodes = function (leafRowNodes, details) {\n    this.removeNodesInStages(leafRowNodes, details);\n\n    if (details.changedPath.isActive()) {\n      leafRowNodes.forEach(function (rowNode) {\n        return details.changedPath.addParentNode(rowNode.parent);\n      });\n    }\n  };\n\n  GroupStage.prototype.removeNodesInStages = function (leafRowNodes, details) {\n    this.removeNodesFromParents(leafRowNodes, details);\n    this.postRemoveCreateFillerNodes(leafRowNodes, details);\n    this.postRemoveRemoveEmptyGroups(leafRowNodes, details);\n  };\n\n  GroupStage.prototype.forEachParentGroup = function (details, child, callback) {\n    var pointer = child.parent;\n\n    while (pointer && pointer !== details.rootNode) {\n      callback(pointer);\n      pointer = pointer.parent;\n    }\n  };\n\n  GroupStage.prototype.removeNodesFromParents = function (nodesToRemove, details) {\n    var _this = this;\n\n    var batchRemover = new BatchRemover();\n    nodesToRemove.forEach(function (nodeToRemove) {\n      _this.removeFromParent(nodeToRemove, batchRemover); // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as\n      // the ClientSideNodeManager is responsible for the Root Node.\n\n\n      _this.forEachParentGroup(details, nodeToRemove, function (parentNode) {\n        batchRemover.removeFromAllLeafChildren(parentNode, nodeToRemove);\n      });\n    });\n    batchRemover.flush();\n  };\n\n  GroupStage.prototype.postRemoveCreateFillerNodes = function (nodesToRemove, details) {\n    var _this = this;\n\n    nodesToRemove.forEach(function (nodeToRemove) {\n      // if not group, and children are present, need to move children to a group.\n      // otherwise if no children, we can just remove without replacing.\n      var replaceWithGroup = nodeToRemove.hasChildren();\n\n      if (replaceWithGroup) {\n        var oldPath = _this.getExistingPathForNode(nodeToRemove, details); // because we just removed the userGroup, this will always return new support group\n\n\n        var newGroupNode_1 = _this.findParentForNode(nodeToRemove, oldPath, details); // these properties are the ones that will be incorrect in the newly created group,\n        // so copy them from the old childNode\n\n\n        newGroupNode_1.expanded = nodeToRemove.expanded;\n        newGroupNode_1.allLeafChildren = nodeToRemove.allLeafChildren;\n        newGroupNode_1.childrenAfterGroup = nodeToRemove.childrenAfterGroup;\n        newGroupNode_1.childrenMapped = nodeToRemove.childrenMapped;\n        newGroupNode_1.childrenAfterGroup.forEach(function (rowNode) {\n          return rowNode.parent = newGroupNode_1;\n        });\n      }\n    });\n  };\n\n  GroupStage.prototype.postRemoveRemoveEmptyGroups = function (nodesToRemove, details) {\n    var _this = this; // we do this multiple times, as when we remove groups, that means the parent of just removed\n    // group can then be empty. to get around this, if we remove, then we check everything again for\n    // newly emptied groups. the max number of times this will execute is the depth of the group tree.\n\n\n    var checkAgain = true;\n\n    var groupShouldBeRemoved = function groupShouldBeRemoved(rowNode) {\n      // because of the while loop below, it's possible we already moved the node,\n      // so double check before trying to remove again.\n      var mapKey = _this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);\n\n      var parentRowNode = rowNode.parent;\n      var groupAlreadyRemoved = parentRowNode && parentRowNode.childrenMapped ? !parentRowNode.childrenMapped[mapKey] : true;\n\n      if (groupAlreadyRemoved) {\n        // if not linked, then group was already removed\n        return false;\n      } else {\n        // if still not removed, then we remove if this group is empty\n        return rowNode.isEmptyRowGroupNode();\n      }\n    };\n\n    var _loop_1 = function _loop_1() {\n      checkAgain = false;\n      var batchRemover = new BatchRemover();\n      nodesToRemove.forEach(function (nodeToRemove) {\n        // remove empty groups\n        _this.forEachParentGroup(details, nodeToRemove, function (rowNode) {\n          if (groupShouldBeRemoved(rowNode)) {\n            checkAgain = true;\n\n            _this.removeFromParent(rowNode, batchRemover); // we remove selection on filler nodes here, as the selection would not be removed\n            // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager\n\n\n            rowNode.setSelected(false);\n          }\n        });\n      });\n      batchRemover.flush();\n    };\n\n    while (checkAgain) {\n      _loop_1();\n    }\n  }; // removes the node from the parent by:\n  // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)\n  // b) removing from childrenMapped (immediately)\n  // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed\n\n\n  GroupStage.prototype.removeFromParent = function (child, batchRemover) {\n    if (child.parent) {\n      if (batchRemover) {\n        batchRemover.removeFromChildrenAfterGroup(child.parent, child);\n      } else {\n        _.removeFromArray(child.parent.childrenAfterGroup, child);\n      }\n    }\n\n    var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n\n    if (child.parent && child.parent.childrenMapped) {\n      child.parent.childrenMapped[mapKey] = undefined;\n    } // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n    // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n\n\n    child.setRowTop(null);\n  };\n\n  GroupStage.prototype.addToParent = function (child, parent) {\n    var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n\n    if (parent) {\n      if (parent.childrenMapped) {\n        parent.childrenMapped[mapKey] = child;\n      }\n\n      parent.childrenAfterGroup.push(child);\n    }\n  };\n\n  GroupStage.prototype.areGroupColsEqual = function (d1, d2) {\n    if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {\n      return false;\n    }\n\n    return _.areEqual(d1.groupedCols, d2.groupedCols);\n  };\n\n  GroupStage.prototype.shotgunResetEverything = function (details, afterColumnsChanged) {\n    var skipStage = afterColumnsChanged ? this.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails) : false;\n    this.oldGroupingDetails = details;\n\n    if (skipStage) {\n      return;\n    } // because we are not creating the root node each time, we have the logic\n    // here to change leafGroup once.\n    // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n    // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n\n\n    details.rootNode.leafGroup = this.usingTreeData ? false : details.groupedCols.length === 0; // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n\n    details.rootNode.childrenAfterGroup = [];\n    details.rootNode.childrenMapped = {};\n    this.insertNodes(details.rootNode.allLeafChildren, details, false);\n  };\n\n  GroupStage.prototype.insertNodes = function (newRowNodes, details, isMove) {\n    var _this = this;\n\n    newRowNodes.forEach(function (rowNode) {\n      _this.insertOneNode(rowNode, details, isMove);\n\n      if (details.changedPath.isActive()) {\n        details.changedPath.addParentNode(rowNode.parent);\n      }\n    });\n  };\n\n  GroupStage.prototype.insertOneNode = function (childNode, details, isMove) {\n    var path = this.getGroupInfo(childNode, details);\n    var parentGroup = this.findParentForNode(childNode, path, details);\n\n    if (!parentGroup.group) {\n      console.warn(\"ag-Grid: duplicate group keys for row data, keys should be unique\", [parentGroup.data, childNode.data]);\n    }\n\n    if (this.usingTreeData) {\n      this.swapGroupWithUserNode(parentGroup, childNode, isMove);\n    } else {\n      childNode.parent = parentGroup;\n      childNode.level = path.length;\n      parentGroup.childrenAfterGroup.push(childNode);\n    }\n  };\n\n  GroupStage.prototype.findParentForNode = function (childNode, path, details) {\n    var _this = this;\n\n    var nextNode = details.rootNode;\n    path.forEach(function (groupInfo, level) {\n      nextNode = _this.getOrCreateNextNode(nextNode, groupInfo, level, details); // node gets added to all group nodes.\n      // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n\n      nextNode.allLeafChildren.push(childNode);\n    });\n    return nextNode;\n  };\n\n  GroupStage.prototype.swapGroupWithUserNode = function (fillerGroup, userGroup, isMove) {\n    userGroup.parent = fillerGroup.parent;\n    userGroup.key = fillerGroup.key;\n    userGroup.field = fillerGroup.field;\n    userGroup.groupData = fillerGroup.groupData;\n    userGroup.level = fillerGroup.level; // AG-3441 - preserve the existing expanded status of the node if we're moving it, so that\n    // you can drag a sub tree from one parent to another without changing its expansion\n\n    if (!isMove) {\n      userGroup.expanded = fillerGroup.expanded;\n    } // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n    // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n\n\n    userGroup.leafGroup = fillerGroup.leafGroup; // always null for userGroups, as row grouping is not allowed when doing tree data\n\n    userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;\n    userGroup.allLeafChildren = fillerGroup.allLeafChildren;\n    userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;\n    userGroup.childrenMapped = fillerGroup.childrenMapped;\n    this.removeFromParent(fillerGroup);\n    userGroup.childrenAfterGroup.forEach(function (rowNode) {\n      return rowNode.parent = userGroup;\n    });\n    this.addToParent(userGroup, fillerGroup.parent);\n  };\n\n  GroupStage.prototype.getOrCreateNextNode = function (parentGroup, groupInfo, level, details) {\n    var mapKey = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n    var nextNode = parentGroup.childrenMapped ? parentGroup.childrenMapped[mapKey] : undefined;\n\n    if (!nextNode) {\n      nextNode = this.createGroup(groupInfo, parentGroup, level, details); // attach the new group to the parent\n\n      this.addToParent(nextNode, parentGroup);\n    }\n\n    return nextNode;\n  };\n\n  GroupStage.prototype.createGroup = function (groupInfo, parent, level, details) {\n    var _this = this;\n\n    var groupNode = new RowNode();\n    this.context.createBean(groupNode);\n    groupNode.group = true;\n    groupNode.field = groupInfo.field;\n    groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n    groupNode.groupData = {};\n    var groupDisplayCols = this.columnController.getGroupDisplayColumns();\n    groupDisplayCols.forEach(function (col) {\n      // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n      // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n      var displayGroupForCol = _this.usingTreeData || (groupNode.rowGroupColumn ? col.isRowGroupDisplayed(groupNode.rowGroupColumn.getId()) : false);\n\n      if (displayGroupForCol) {\n        groupNode.groupData[col.getColId()] = groupInfo.key;\n      }\n    }); // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'\n    // for top pinned and bottom pinned rows.\n\n    groupNode.id = RowNode.ID_PREFIX_ROW_GROUP + this.groupIdSequence.next();\n    groupNode.key = groupInfo.key;\n    groupNode.level = level;\n    groupNode.leafGroup = this.usingTreeData ? false : level === details.groupedColCount - 1; // if doing pivoting, then the leaf group is never expanded,\n    // as we do not show leaf rows\n\n    if (details.pivotMode && groupNode.leafGroup) {\n      groupNode.expanded = false;\n    } else {\n      groupNode.expanded = this.isExpanded(details.expandByDefault, level);\n    }\n\n    groupNode.allLeafChildren = []; // why is this done here? we are not updating the children could as we go,\n    // i suspect this is updated in the filter stage\n\n    groupNode.setAllChildrenCount(0);\n    groupNode.rowGroupIndex = this.usingTreeData ? null : level;\n    groupNode.childrenAfterGroup = [];\n    groupNode.childrenMapped = {};\n    groupNode.parent = details.includeParents ? parent : null;\n    return groupNode;\n  };\n\n  GroupStage.prototype.getChildrenMappedKey = function (key, rowGroupColumn) {\n    if (rowGroupColumn) {\n      // grouping by columns\n      return rowGroupColumn.getId() + '-' + key;\n    } else {\n      // tree data - we don't have rowGroupColumns\n      return key;\n    }\n  };\n\n  GroupStage.prototype.isExpanded = function (expandByDefault, level) {\n    if (expandByDefault === -1) {\n      return true;\n    } else {\n      return level < expandByDefault;\n    }\n  };\n\n  GroupStage.prototype.getGroupInfo = function (rowNode, details) {\n    if (this.usingTreeData) {\n      return this.getGroupInfoFromCallback(rowNode);\n    } else {\n      return this.getGroupInfoFromGroupColumns(rowNode, details);\n    }\n  };\n\n  GroupStage.prototype.getGroupInfoFromCallback = function (rowNode) {\n    var keys = this.getDataPath ? this.getDataPath(rowNode.data) : null;\n\n    if (keys === null || keys === undefined || keys.length === 0) {\n      _.doOnce(function () {\n        return console.warn(\"getDataPath() should not return an empty path for data\", rowNode.data);\n      }, 'groupStage.getGroupInfoFromCallback');\n    }\n\n    var groupInfoMapper = function groupInfoMapper(key) {\n      return {\n        key: key,\n        field: null,\n        rowGroupColumn: null\n      };\n    };\n\n    return keys ? keys.map(groupInfoMapper) : [];\n  };\n\n  GroupStage.prototype.getGroupInfoFromGroupColumns = function (rowNode, details) {\n    var _this = this;\n\n    var res = [];\n    details.groupedCols.forEach(function (groupCol) {\n      var key = _this.valueService.getKeyForNode(groupCol, rowNode);\n\n      var keyExists = key !== null && key !== undefined; // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n      // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n      // this keeps the tree balanced and hence can be represented as a group.\n\n      if (details.pivotMode && !keyExists) {\n        key = ' ';\n        keyExists = true;\n      }\n\n      if (keyExists) {\n        var item = {\n          key: key,\n          field: groupCol.getColDef().field,\n          rowGroupColumn: groupCol\n        };\n        res.push(item);\n      }\n    });\n    return res;\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], GroupStage.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('columnController')], GroupStage.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('selectableService')], GroupStage.prototype, \"selectableService\", void 0);\n\n  __decorate([Autowired('valueService')], GroupStage.prototype, \"valueService\", void 0);\n\n  __decorate([PostConstruct], GroupStage.prototype, \"postConstruct\", null);\n\n  GroupStage = __decorate([Bean('groupStage')], GroupStage);\n  return GroupStage;\n}(BeanStub);\n\nexport { GroupStage }; // doing _.removeFromArray() multiple times on a large list can be a bottleneck.\n// when doing large deletes (eg removing 1,000 rows) then we would be calling _.removeFromArray()\n// a thousands of times, in particular RootNode.allGroupChildren could be a large list, and\n// 1,000 removes is time consuming as each one requires traversing the full list.\n// to get around this, we do all the removes in a batch. this class manages the batch.\n//\n// This problem was brought to light by a client (AG-2879), with dataset of 20,000\n// in 10,000 groups (2 items per group), then deleting all rows with transaction,\n// it took about 20 seconds to delete. with the BathRemoved, the reduced to less than 1 second.\n\nvar BatchRemover =\n/** @class */\nfunction () {\n  function BatchRemover() {\n    this.allSets = {};\n    this.allParents = [];\n  }\n\n  BatchRemover.prototype.removeFromChildrenAfterGroup = function (parent, child) {\n    var set = this.getSet(parent);\n    set.removeFromChildrenAfterGroup[child.id] = true;\n  };\n\n  BatchRemover.prototype.removeFromAllLeafChildren = function (parent, child) {\n    var set = this.getSet(parent);\n    set.removeFromAllLeafChildren[child.id] = true;\n  };\n\n  BatchRemover.prototype.getSet = function (parent) {\n    if (!this.allSets[parent.id]) {\n      this.allSets[parent.id] = {\n        removeFromAllLeafChildren: {},\n        removeFromChildrenAfterGroup: {}\n      };\n      this.allParents.push(parent);\n    }\n\n    return this.allSets[parent.id];\n  };\n\n  BatchRemover.prototype.flush = function () {\n    var _this = this;\n\n    this.allParents.forEach(function (parent) {\n      var nodeDetails = _this.allSets[parent.id];\n      parent.childrenAfterGroup = parent.childrenAfterGroup.filter(function (child) {\n        var res = !nodeDetails.removeFromChildrenAfterGroup[child.id];\n        return res;\n      });\n      parent.allLeafChildren = parent.allLeafChildren.filter(function (child) {\n        return !nodeDetails.removeFromAllLeafChildren[child.id];\n      });\n    });\n    this.allSets = {};\n    this.allParents.length = 0;\n  };\n\n  return BatchRemover;\n}();","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-enterprise/row-grouping/dist/es6/rowGrouping/groupStage.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Autowired","Bean","BeanStub","NumberSequence","PostConstruct","RowNode","_","GroupStage","_super","_this","apply","groupIdSequence","postConstruct","usingTreeData","gridOptionsWrapper","isTreeData","getDataPath","getDataPathFunc","execute","params","details","createGroupingDetails","transactions","handleTransaction","afterColsChanged","afterColumnsChanged","shotgunResetEverything","sortGroupsWithComparator","rootNode","selectableService","updateSelectableAfterGrouping","rowNode","changedPath","rowNodeTransactions","rowNodeOrder","groupedCols","columnController","getRowGroupColumns","includeParents","isSuppressParentsInRowNodes","expandByDefault","isGroupSuppressRow","getGroupDefaultExpanded","pivotMode","isPivotMode","groupedColCount","forEach","tran","existsAndNotEmpty","add","insertNodes","remove","removeNodes","update","moveNodesInWrongPath","sortChildren","forEachChangedNodeDepthFirst","sortRowNodesByOrder","childrenAfterGroup","comparator","getDefaultGroupSortComparator","exists","recursiveSort","doSort","leafGroup","sort","childNode","getExistingPathForNode","node","res","pointer","parent","push","rowGroupColumn","field","reverse","childNodes","isActive","addParentNode","infoToKeyMapper","item","oldPath","map","newPath","getGroupInfo","nodeInCorrectPath","areEqual","moveNode","removeNodesInStages","insertOneNode","setData","data","newParent","leafRowNodes","removeNodesFromParents","postRemoveCreateFillerNodes","postRemoveRemoveEmptyGroups","forEachParentGroup","child","callback","nodesToRemove","batchRemover","BatchRemover","nodeToRemove","removeFromParent","parentNode","removeFromAllLeafChildren","flush","replaceWithGroup","hasChildren","newGroupNode_1","findParentForNode","expanded","allLeafChildren","childrenMapped","checkAgain","groupShouldBeRemoved","mapKey","getChildrenMappedKey","parentRowNode","groupAlreadyRemoved","isEmptyRowGroupNode","_loop_1","setSelected","removeFromChildrenAfterGroup","removeFromArray","undefined","setRowTop","addToParent","areGroupColsEqual","d1","d2","skipStage","oldGroupingDetails","newRowNodes","isMove","path","parentGroup","group","console","warn","swapGroupWithUserNode","level","nextNode","groupInfo","getOrCreateNextNode","fillerGroup","userGroup","groupData","rowGroupIndex","createGroup","groupNode","context","createBean","groupDisplayCols","getGroupDisplayColumns","col","displayGroupForCol","isRowGroupDisplayed","getId","getColId","id","ID_PREFIX_ROW_GROUP","next","isExpanded","setAllChildrenCount","getGroupInfoFromCallback","getGroupInfoFromGroupColumns","keys","doOnce","groupInfoMapper","groupCol","valueService","getKeyForNode","keyExists","getColDef","allSets","allParents","set","getSet","nodeDetails","filter"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, BeanStub, NumberSequence, PostConstruct, RowNode, _ } from \"@ag-grid-community/core\";\nvar GroupStage = /** @class */ (function (_super) {\n    __extends(GroupStage, _super);\n    function GroupStage() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // we use a sequence variable so that each time we do a grouping, we don't\n        // reuse the ids - otherwise the rowRenderer will confuse rowNodes between redraws\n        // when it tries to animate between rows.\n        _this.groupIdSequence = new NumberSequence();\n        return _this;\n    }\n    GroupStage.prototype.postConstruct = function () {\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.usingTreeData) {\n            this.getDataPath = this.gridOptionsWrapper.getDataPathFunc();\n        }\n    };\n    GroupStage.prototype.execute = function (params) {\n        var details = this.createGroupingDetails(params);\n        if (details.transactions) {\n            this.handleTransaction(details);\n        }\n        else {\n            var afterColsChanged = params.afterColumnsChanged === true;\n            this.shotgunResetEverything(details, afterColsChanged);\n        }\n        this.sortGroupsWithComparator(details.rootNode);\n        this.selectableService.updateSelectableAfterGrouping(details.rootNode);\n    };\n    GroupStage.prototype.createGroupingDetails = function (params) {\n        var rowNode = params.rowNode, changedPath = params.changedPath, rowNodeTransactions = params.rowNodeTransactions, rowNodeOrder = params.rowNodeOrder;\n        var groupedCols = this.usingTreeData ? null : this.columnController.getRowGroupColumns();\n        var details = {\n            // someone complained that the parent attribute was causing some change detection\n            // to break is some angular add-on - which i never used. taking the parent out breaks\n            // a cyclic dependency, hence this flag got introduced.\n            includeParents: !this.gridOptionsWrapper.isSuppressParentsInRowNodes(),\n            expandByDefault: this.gridOptionsWrapper.isGroupSuppressRow() ?\n                -1 : this.gridOptionsWrapper.getGroupDefaultExpanded(),\n            groupedCols: groupedCols,\n            rootNode: rowNode,\n            pivotMode: this.columnController.isPivotMode(),\n            groupedColCount: this.usingTreeData || !groupedCols ? 0 : groupedCols.length,\n            rowNodeOrder: rowNodeOrder,\n            transactions: rowNodeTransactions,\n            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n            changedPath: changedPath\n        };\n        return details;\n    };\n    GroupStage.prototype.handleTransaction = function (details) {\n        var _this = this;\n        details.transactions.forEach(function (tran) {\n            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,\n            // as the order is important when a record with the same id is added and removed in the same\n            // transaction.\n            if (_.existsAndNotEmpty(tran.add)) {\n                _this.insertNodes(tran.add, details, false);\n            }\n            if (_.existsAndNotEmpty(tran.remove)) {\n                _this.removeNodes(tran.remove, details);\n            }\n            if (_.existsAndNotEmpty(tran.update)) {\n                _this.moveNodesInWrongPath(tran.update, details);\n            }\n        });\n        if (details.rowNodeOrder) {\n            this.sortChildren(details);\n        }\n    };\n    // this is used when doing delta updates, eg Redux, keeps nodes in right order\n    GroupStage.prototype.sortChildren = function (details) {\n        details.changedPath.forEachChangedNodeDepthFirst(function (rowNode) {\n            _.sortRowNodesByOrder(rowNode.childrenAfterGroup, details.rowNodeOrder);\n        });\n    };\n    GroupStage.prototype.sortGroupsWithComparator = function (rootNode) {\n        // we don't do group sorting for tree data\n        if (this.usingTreeData) {\n            return;\n        }\n        var comparator = this.gridOptionsWrapper.getDefaultGroupSortComparator();\n        if (_.exists(comparator)) {\n            recursiveSort(rootNode);\n        }\n        function recursiveSort(rowNode) {\n            var doSort = _.exists(rowNode.childrenAfterGroup) &&\n                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n                !rowNode.leafGroup;\n            if (doSort) {\n                rowNode.childrenAfterGroup.sort(comparator);\n                rowNode.childrenAfterGroup.forEach(function (childNode) { return recursiveSort(childNode); });\n            }\n        }\n    };\n    GroupStage.prototype.getExistingPathForNode = function (node, details) {\n        var res = [];\n        // when doing tree data, the node is part of the path,\n        // but when doing grid grouping, the node is not part of the path so we start with the parent.\n        var pointer = this.usingTreeData ? node : node.parent;\n        while (pointer && pointer !== details.rootNode) {\n            res.push({\n                key: pointer.key,\n                rowGroupColumn: pointer.rowGroupColumn,\n                field: pointer.field\n            });\n            pointer = pointer.parent;\n        }\n        res.reverse();\n        return res;\n    };\n    GroupStage.prototype.moveNodesInWrongPath = function (childNodes, details) {\n        var _this = this;\n        childNodes.forEach(function (childNode) {\n            // we add node, even if parent has not changed, as the data could have\n            // changed, hence aggregations will be wrong\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(childNode.parent);\n            }\n            var infoToKeyMapper = function (item) { return item.key; };\n            var oldPath = _this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n            var newPath = _this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n            var nodeInCorrectPath = _.areEqual(oldPath, newPath);\n            if (!nodeInCorrectPath) {\n                _this.moveNode(childNode, details);\n            }\n        });\n    };\n    GroupStage.prototype.moveNode = function (childNode, details) {\n        this.removeNodesInStages([childNode], details);\n        this.insertOneNode(childNode, details, true);\n        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n        // refreshed into the gui.\n        // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n        // then will get each cell in the row to refresh - which is what we need as we don't know which\n        // columns will be displaying the rowNode.key info.\n        childNode.setData(childNode.data);\n        // we add both old and new parents to changed path, as both will need to be refreshed.\n        // we already added the old parent (in calling method), so just add the new parent here\n        if (details.changedPath.isActive()) {\n            var newParent = childNode.parent;\n            details.changedPath.addParentNode(newParent);\n        }\n    };\n    GroupStage.prototype.removeNodes = function (leafRowNodes, details) {\n        this.removeNodesInStages(leafRowNodes, details);\n        if (details.changedPath.isActive()) {\n            leafRowNodes.forEach(function (rowNode) { return details.changedPath.addParentNode(rowNode.parent); });\n        }\n    };\n    GroupStage.prototype.removeNodesInStages = function (leafRowNodes, details) {\n        this.removeNodesFromParents(leafRowNodes, details);\n        this.postRemoveCreateFillerNodes(leafRowNodes, details);\n        this.postRemoveRemoveEmptyGroups(leafRowNodes, details);\n    };\n    GroupStage.prototype.forEachParentGroup = function (details, child, callback) {\n        var pointer = child.parent;\n        while (pointer && pointer !== details.rootNode) {\n            callback(pointer);\n            pointer = pointer.parent;\n        }\n    };\n    GroupStage.prototype.removeNodesFromParents = function (nodesToRemove, details) {\n        var _this = this;\n        var batchRemover = new BatchRemover();\n        nodesToRemove.forEach(function (nodeToRemove) {\n            _this.removeFromParent(nodeToRemove, batchRemover);\n            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as\n            // the ClientSideNodeManager is responsible for the Root Node.\n            _this.forEachParentGroup(details, nodeToRemove, function (parentNode) {\n                batchRemover.removeFromAllLeafChildren(parentNode, nodeToRemove);\n            });\n        });\n        batchRemover.flush();\n    };\n    GroupStage.prototype.postRemoveCreateFillerNodes = function (nodesToRemove, details) {\n        var _this = this;\n        nodesToRemove.forEach(function (nodeToRemove) {\n            // if not group, and children are present, need to move children to a group.\n            // otherwise if no children, we can just remove without replacing.\n            var replaceWithGroup = nodeToRemove.hasChildren();\n            if (replaceWithGroup) {\n                var oldPath = _this.getExistingPathForNode(nodeToRemove, details);\n                // because we just removed the userGroup, this will always return new support group\n                var newGroupNode_1 = _this.findParentForNode(nodeToRemove, oldPath, details);\n                // these properties are the ones that will be incorrect in the newly created group,\n                // so copy them from the old childNode\n                newGroupNode_1.expanded = nodeToRemove.expanded;\n                newGroupNode_1.allLeafChildren = nodeToRemove.allLeafChildren;\n                newGroupNode_1.childrenAfterGroup = nodeToRemove.childrenAfterGroup;\n                newGroupNode_1.childrenMapped = nodeToRemove.childrenMapped;\n                newGroupNode_1.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = newGroupNode_1; });\n            }\n        });\n    };\n    GroupStage.prototype.postRemoveRemoveEmptyGroups = function (nodesToRemove, details) {\n        var _this = this;\n        // we do this multiple times, as when we remove groups, that means the parent of just removed\n        // group can then be empty. to get around this, if we remove, then we check everything again for\n        // newly emptied groups. the max number of times this will execute is the depth of the group tree.\n        var checkAgain = true;\n        var groupShouldBeRemoved = function (rowNode) {\n            // because of the while loop below, it's possible we already moved the node,\n            // so double check before trying to remove again.\n            var mapKey = _this.getChildrenMappedKey(rowNode.key, rowNode.rowGroupColumn);\n            var parentRowNode = rowNode.parent;\n            var groupAlreadyRemoved = (parentRowNode && parentRowNode.childrenMapped) ?\n                !parentRowNode.childrenMapped[mapKey] : true;\n            if (groupAlreadyRemoved) {\n                // if not linked, then group was already removed\n                return false;\n            }\n            else {\n                // if still not removed, then we remove if this group is empty\n                return rowNode.isEmptyRowGroupNode();\n            }\n        };\n        var _loop_1 = function () {\n            checkAgain = false;\n            var batchRemover = new BatchRemover();\n            nodesToRemove.forEach(function (nodeToRemove) {\n                // remove empty groups\n                _this.forEachParentGroup(details, nodeToRemove, function (rowNode) {\n                    if (groupShouldBeRemoved(rowNode)) {\n                        checkAgain = true;\n                        _this.removeFromParent(rowNode, batchRemover);\n                        // we remove selection on filler nodes here, as the selection would not be removed\n                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager\n                        rowNode.setSelected(false);\n                    }\n                });\n            });\n            batchRemover.flush();\n        };\n        while (checkAgain) {\n            _loop_1();\n        }\n    };\n    // removes the node from the parent by:\n    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)\n    // b) removing from childrenMapped (immediately)\n    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed\n    GroupStage.prototype.removeFromParent = function (child, batchRemover) {\n        if (child.parent) {\n            if (batchRemover) {\n                batchRemover.removeFromChildrenAfterGroup(child.parent, child);\n            }\n            else {\n                _.removeFromArray(child.parent.childrenAfterGroup, child);\n            }\n        }\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        if (child.parent && child.parent.childrenMapped) {\n            child.parent.childrenMapped[mapKey] = undefined;\n        }\n        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n        // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n        child.setRowTop(null);\n    };\n    GroupStage.prototype.addToParent = function (child, parent) {\n        var mapKey = this.getChildrenMappedKey(child.key, child.rowGroupColumn);\n        if (parent) {\n            if (parent.childrenMapped) {\n                parent.childrenMapped[mapKey] = child;\n            }\n            parent.childrenAfterGroup.push(child);\n        }\n    };\n    GroupStage.prototype.areGroupColsEqual = function (d1, d2) {\n        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) {\n            return false;\n        }\n        return _.areEqual(d1.groupedCols, d2.groupedCols);\n    };\n    GroupStage.prototype.shotgunResetEverything = function (details, afterColumnsChanged) {\n        var skipStage = afterColumnsChanged ?\n            this.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails)\n            : false;\n        this.oldGroupingDetails = details;\n        if (skipStage) {\n            return;\n        }\n        // because we are not creating the root node each time, we have the logic\n        // here to change leafGroup once.\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        details.rootNode.leafGroup = this.usingTreeData ? false : details.groupedCols.length === 0;\n        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n        details.rootNode.childrenAfterGroup = [];\n        details.rootNode.childrenMapped = {};\n        this.insertNodes(details.rootNode.allLeafChildren, details, false);\n    };\n    GroupStage.prototype.insertNodes = function (newRowNodes, details, isMove) {\n        var _this = this;\n        newRowNodes.forEach(function (rowNode) {\n            _this.insertOneNode(rowNode, details, isMove);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(rowNode.parent);\n            }\n        });\n    };\n    GroupStage.prototype.insertOneNode = function (childNode, details, isMove) {\n        var path = this.getGroupInfo(childNode, details);\n        var parentGroup = this.findParentForNode(childNode, path, details);\n        if (!parentGroup.group) {\n            console.warn(\"ag-Grid: duplicate group keys for row data, keys should be unique\", [parentGroup.data, childNode.data]);\n        }\n        if (this.usingTreeData) {\n            this.swapGroupWithUserNode(parentGroup, childNode, isMove);\n        }\n        else {\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            parentGroup.childrenAfterGroup.push(childNode);\n        }\n    };\n    GroupStage.prototype.findParentForNode = function (childNode, path, details) {\n        var _this = this;\n        var nextNode = details.rootNode;\n        path.forEach(function (groupInfo, level) {\n            nextNode = _this.getOrCreateNextNode(nextNode, groupInfo, level, details);\n            // node gets added to all group nodes.\n            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n            nextNode.allLeafChildren.push(childNode);\n        });\n        return nextNode;\n    };\n    GroupStage.prototype.swapGroupWithUserNode = function (fillerGroup, userGroup, isMove) {\n        userGroup.parent = fillerGroup.parent;\n        userGroup.key = fillerGroup.key;\n        userGroup.field = fillerGroup.field;\n        userGroup.groupData = fillerGroup.groupData;\n        userGroup.level = fillerGroup.level;\n        // AG-3441 - preserve the existing expanded status of the node if we're moving it, so that\n        // you can drag a sub tree from one parent to another without changing its expansion\n        if (!isMove) {\n            userGroup.expanded = fillerGroup.expanded;\n        }\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        userGroup.leafGroup = fillerGroup.leafGroup;\n        // always null for userGroups, as row grouping is not allowed when doing tree data\n        userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;\n        userGroup.allLeafChildren = fillerGroup.allLeafChildren;\n        userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;\n        userGroup.childrenMapped = fillerGroup.childrenMapped;\n        this.removeFromParent(fillerGroup);\n        userGroup.childrenAfterGroup.forEach(function (rowNode) { return rowNode.parent = userGroup; });\n        this.addToParent(userGroup, fillerGroup.parent);\n    };\n    GroupStage.prototype.getOrCreateNextNode = function (parentGroup, groupInfo, level, details) {\n        var mapKey = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n        var nextNode = parentGroup.childrenMapped ? parentGroup.childrenMapped[mapKey] : undefined;\n        if (!nextNode) {\n            nextNode = this.createGroup(groupInfo, parentGroup, level, details);\n            // attach the new group to the parent\n            this.addToParent(nextNode, parentGroup);\n        }\n        return nextNode;\n    };\n    GroupStage.prototype.createGroup = function (groupInfo, parent, level, details) {\n        var _this = this;\n        var groupNode = new RowNode();\n        this.context.createBean(groupNode);\n        groupNode.group = true;\n        groupNode.field = groupInfo.field;\n        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n        groupNode.groupData = {};\n        var groupDisplayCols = this.columnController.getGroupDisplayColumns();\n        groupDisplayCols.forEach(function (col) {\n            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n            var displayGroupForCol = _this.usingTreeData || (groupNode.rowGroupColumn ? col.isRowGroupDisplayed(groupNode.rowGroupColumn.getId()) : false);\n            if (displayGroupForCol) {\n                groupNode.groupData[col.getColId()] = groupInfo.key;\n            }\n        });\n        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'\n        // for top pinned and bottom pinned rows.\n        groupNode.id = RowNode.ID_PREFIX_ROW_GROUP + this.groupIdSequence.next();\n        groupNode.key = groupInfo.key;\n        groupNode.level = level;\n        groupNode.leafGroup = this.usingTreeData ? false : level === (details.groupedColCount - 1);\n        // if doing pivoting, then the leaf group is never expanded,\n        // as we do not show leaf rows\n        if (details.pivotMode && groupNode.leafGroup) {\n            groupNode.expanded = false;\n        }\n        else {\n            groupNode.expanded = this.isExpanded(details.expandByDefault, level);\n        }\n        groupNode.allLeafChildren = [];\n        // why is this done here? we are not updating the children could as we go,\n        // i suspect this is updated in the filter stage\n        groupNode.setAllChildrenCount(0);\n        groupNode.rowGroupIndex = this.usingTreeData ? null : level;\n        groupNode.childrenAfterGroup = [];\n        groupNode.childrenMapped = {};\n        groupNode.parent = details.includeParents ? parent : null;\n        return groupNode;\n    };\n    GroupStage.prototype.getChildrenMappedKey = function (key, rowGroupColumn) {\n        if (rowGroupColumn) {\n            // grouping by columns\n            return rowGroupColumn.getId() + '-' + key;\n        }\n        else {\n            // tree data - we don't have rowGroupColumns\n            return key;\n        }\n    };\n    GroupStage.prototype.isExpanded = function (expandByDefault, level) {\n        if (expandByDefault === -1) {\n            return true;\n        }\n        else {\n            return level < expandByDefault;\n        }\n    };\n    GroupStage.prototype.getGroupInfo = function (rowNode, details) {\n        if (this.usingTreeData) {\n            return this.getGroupInfoFromCallback(rowNode);\n        }\n        else {\n            return this.getGroupInfoFromGroupColumns(rowNode, details);\n        }\n    };\n    GroupStage.prototype.getGroupInfoFromCallback = function (rowNode) {\n        var keys = this.getDataPath ? this.getDataPath(rowNode.data) : null;\n        if (keys === null || keys === undefined || keys.length === 0) {\n            _.doOnce(function () { return console.warn(\"getDataPath() should not return an empty path for data\", rowNode.data); }, 'groupStage.getGroupInfoFromCallback');\n        }\n        var groupInfoMapper = function (key) { return ({ key: key, field: null, rowGroupColumn: null }); };\n        return keys ? keys.map(groupInfoMapper) : [];\n    };\n    GroupStage.prototype.getGroupInfoFromGroupColumns = function (rowNode, details) {\n        var _this = this;\n        var res = [];\n        details.groupedCols.forEach(function (groupCol) {\n            var key = _this.valueService.getKeyForNode(groupCol, rowNode);\n            var keyExists = key !== null && key !== undefined;\n            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n            // this keeps the tree balanced and hence can be represented as a group.\n            if (details.pivotMode && !keyExists) {\n                key = ' ';\n                keyExists = true;\n            }\n            if (keyExists) {\n                var item = {\n                    key: key,\n                    field: groupCol.getColDef().field,\n                    rowGroupColumn: groupCol\n                };\n                res.push(item);\n            }\n        });\n        return res;\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], GroupStage.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('columnController')\n    ], GroupStage.prototype, \"columnController\", void 0);\n    __decorate([\n        Autowired('selectableService')\n    ], GroupStage.prototype, \"selectableService\", void 0);\n    __decorate([\n        Autowired('valueService')\n    ], GroupStage.prototype, \"valueService\", void 0);\n    __decorate([\n        PostConstruct\n    ], GroupStage.prototype, \"postConstruct\", null);\n    GroupStage = __decorate([\n        Bean('groupStage')\n    ], GroupStage);\n    return GroupStage;\n}(BeanStub));\nexport { GroupStage };\n// doing _.removeFromArray() multiple times on a large list can be a bottleneck.\n// when doing large deletes (eg removing 1,000 rows) then we would be calling _.removeFromArray()\n// a thousands of times, in particular RootNode.allGroupChildren could be a large list, and\n// 1,000 removes is time consuming as each one requires traversing the full list.\n// to get around this, we do all the removes in a batch. this class manages the batch.\n//\n// This problem was brought to light by a client (AG-2879), with dataset of 20,000\n// in 10,000 groups (2 items per group), then deleting all rows with transaction,\n// it took about 20 seconds to delete. with the BathRemoved, the reduced to less than 1 second.\nvar BatchRemover = /** @class */ (function () {\n    function BatchRemover() {\n        this.allSets = {};\n        this.allParents = [];\n    }\n    BatchRemover.prototype.removeFromChildrenAfterGroup = function (parent, child) {\n        var set = this.getSet(parent);\n        set.removeFromChildrenAfterGroup[child.id] = true;\n    };\n    BatchRemover.prototype.removeFromAllLeafChildren = function (parent, child) {\n        var set = this.getSet(parent);\n        set.removeFromAllLeafChildren[child.id] = true;\n    };\n    BatchRemover.prototype.getSet = function (parent) {\n        if (!this.allSets[parent.id]) {\n            this.allSets[parent.id] = {\n                removeFromAllLeafChildren: {},\n                removeFromChildrenAfterGroup: {}\n            };\n            this.allParents.push(parent);\n        }\n        return this.allSets[parent.id];\n    };\n    BatchRemover.prototype.flush = function () {\n        var _this = this;\n        this.allParents.forEach(function (parent) {\n            var nodeDetails = _this.allSets[parent.id];\n            parent.childrenAfterGroup = parent.childrenAfterGroup.filter(function (child) {\n                var res = !nodeDetails.removeFromChildrenAfterGroup[child.id];\n                return res;\n            });\n            parent.allLeafChildren = parent.allLeafChildren.filter(function (child) { return !nodeDetails.removeFromAllLeafChildren[child.id]; });\n        });\n        this.allSets = {};\n        this.allParents.length = 0;\n    };\n    return BatchRemover;\n}());\n"]},"metadata":{},"sourceType":"module"}