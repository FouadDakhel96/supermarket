{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { _, Autowired, NumberSequence, Qualifier, RowNodeCache } from \"@ag-grid-community/core\";\nimport { ServerSideBlock } from \"./serverSideBlock\";\n\nvar ServerSideCache =\n/** @class */\nfunction (_super) {\n  __extends(ServerSideCache, _super);\n\n  function ServerSideCache(cacheParams, parentRowNode) {\n    var _this = _super.call(this, cacheParams) || this; // this will always be zero for the top level cache only,\n    // all the other ones change as the groups open and close\n\n\n    _this.displayIndexStart = 0;\n    _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n\n    _this.cacheTop = 0;\n    _this.blockHeights = {};\n    _this.parentRowNode = parentRowNode;\n    return _this;\n  }\n\n  ServerSideCache.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ServerSideCache');\n  };\n\n  ServerSideCache.prototype.getRowBounds = function (index) {\n    // this.logger.log(`getRowBounds(${index})`);\n    var _this = this; // we return null if row not found\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be RowBounds\n\n\n    var result;\n    var blockFound = false; // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var lastBlock = null;\n    this.forEachBlockInOrder(function (block) {\n      if (blockFound) {\n        return;\n      }\n\n      if (block.isDisplayIndexInBlock(index)) {\n        result = block.getRowBounds(index, _this.getVirtualRowCount());\n        blockFound = true;\n      } else if (block.isBlockBefore(index)) {\n        lastBlock = block;\n      }\n    });\n\n    if (!blockFound) {\n      var nextRowTop = void 0;\n      var nextRowIndex = void 0;\n\n      if (lastBlock !== null) {\n        nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n        nextRowIndex = lastBlock.getDisplayIndexEnd();\n      } else {\n        nextRowTop = this.cacheTop;\n        nextRowIndex = this.displayIndexStart;\n      }\n\n      var rowsBetween = index - nextRowIndex;\n      result = {\n        rowHeight: this.cacheParams.rowHeight,\n        rowTop: nextRowTop + rowsBetween * this.cacheParams.rowHeight\n      };\n    } // NOTE: what about purged blocks\n    // this.logger.log(`getRowBounds(${index}), result = ${result}`);\n\n\n    return result;\n  };\n\n  ServerSideCache.prototype.destroyBlock = function (block) {\n    _super.prototype.destroyBlock.call(this, block);\n  };\n\n  ServerSideCache.prototype.getRowIndexAtPixel = function (pixel) {\n    // this.logger.log(`getRowIndexAtPixel(${pixel})`);\n    var _this = this; // we return null if row not found\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be number\n\n\n    var result;\n    var blockFound = false; // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var lastBlock;\n    this.forEachBlockInOrder(function (block) {\n      if (blockFound) {\n        return;\n      }\n\n      if (block.isPixelInRange(pixel)) {\n        result = block.getRowIndexAtPixel(pixel, _this.getVirtualRowCount());\n        blockFound = true;\n      } else if (block.getBlockTop() < pixel) {\n        lastBlock = block;\n      }\n    });\n\n    if (!blockFound) {\n      var nextRowTop = void 0;\n      var nextRowIndex = void 0;\n\n      if (lastBlock) {\n        nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n        nextRowIndex = lastBlock.getDisplayIndexEnd();\n      } else {\n        nextRowTop = this.cacheTop;\n        nextRowIndex = this.displayIndexStart;\n      }\n\n      var pixelsBetween = pixel - nextRowTop;\n      var rowsBetween = pixelsBetween / this.cacheParams.rowHeight | 0;\n      result = nextRowIndex + rowsBetween;\n    }\n\n    var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n\n    if (result > lastAllowedIndex) {\n      result = lastAllowedIndex;\n    } //NOTE: purged\n    // this.logger.log(`getRowIndexAtPixel(${pixel}) result = ${result}`);\n\n\n    return result;\n  };\n\n  ServerSideCache.prototype.clearDisplayIndexes = function () {\n    var _this = this;\n\n    this.displayIndexStart = undefined;\n    this.displayIndexEnd = undefined;\n    this.forEachBlockInOrder(function (block) {\n      return block.clearDisplayIndexes(_this.getVirtualRowCount());\n    });\n  };\n\n  ServerSideCache.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n    var _this = this;\n\n    this.displayIndexStart = displayIndexSeq.peek();\n    this.cacheTop = nextRowTop.value;\n    var lastBlockId = -1;\n    var blockSize = this.getBlockSize();\n    this.forEachBlockInOrder(function (currentBlock, blockId) {\n      // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n      // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n      // the cache if any row nodes are open.\n      var blocksSkippedCount = blockId - lastBlockId - 1;\n      var rowsSkippedCount = blocksSkippedCount * blockSize;\n\n      if (rowsSkippedCount > 0) {\n        displayIndexSeq.skip(rowsSkippedCount);\n      }\n\n      for (var i = 1; i <= blocksSkippedCount; i++) {\n        var blockToAddId = blockId - i;\n\n        if (_.exists(_this.blockHeights[blockToAddId])) {\n          nextRowTop.value += _this.blockHeights[blockToAddId];\n        } else {\n          nextRowTop.value += blockSize * _this.cacheParams.rowHeight;\n        }\n      }\n\n      lastBlockId = blockId;\n      currentBlock.setDisplayIndexes(displayIndexSeq, _this.getVirtualRowCount(), nextRowTop);\n      _this.blockHeights[blockId] = currentBlock.getBlockHeight();\n    }); // if any blocks missing at the end, need to increase the row index for them also\n    // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n    // last row was ejected from cache), then:\n    // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n\n    var lastVisitedRow = (lastBlockId + 1) * blockSize - 1;\n    var rowCount = this.getVirtualRowCount();\n    var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n\n    if (rowsNotAccountedFor > 0) {\n      displayIndexSeq.skip(rowsNotAccountedFor);\n      nextRowTop.value += rowsNotAccountedFor * this.cacheParams.rowHeight;\n    }\n\n    this.displayIndexEnd = displayIndexSeq.peek();\n    this.cacheHeight = nextRowTop.value - this.cacheTop;\n  }; // gets called in a) init() above and b) by the grid\n\n\n  ServerSideCache.prototype.getRow = function (displayRowIndex, dontCreateBlock) {\n    if (dontCreateBlock === void 0) {\n      dontCreateBlock = false;\n    } // this can happen if asking for a row that doesn't exist in the model,\n    // eg if a cell range is selected, and the user filters so rows no longer\n    // exist\n\n\n    if (!this.isDisplayIndexInCache(displayRowIndex)) {\n      return null;\n    } // if we have the block, then this is the block\n\n\n    var block = null; // this is the last block that we have BEFORE the right block\n    // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n    // should be ServerSideBlock\n\n    var beforeBlock = null;\n    this.forEachBlockInOrder(function (currentBlock) {\n      if (currentBlock.isDisplayIndexInBlock(displayRowIndex)) {\n        block = currentBlock;\n      } else if (currentBlock.isBlockBefore(displayRowIndex)) {\n        // this will get assigned many times, but the last time will\n        // be the closest block to the required block that is BEFORE\n        beforeBlock = currentBlock;\n      }\n    }); // when we are moving rows around, we don't want to trigger loads\n\n    if (_.missing(block) && dontCreateBlock) {\n      return null;\n    }\n\n    var blockSize = this.getBlockSize(); // if block not found, we need to load it\n\n    if (_.missing(block)) {\n      var blockNumber = void 0;\n      var displayIndexStart_1;\n      var nextRowTop = void 0; // because missing blocks are always fully closed, we can work out\n      // the start index of the block we want by hopping from the closest block,\n      // as we know the row count in closed blocks is equal to the page size\n\n      if (beforeBlock) {\n        blockNumber = beforeBlock.getBlockNumber() + 1;\n        displayIndexStart_1 = beforeBlock.getDisplayIndexEnd();\n        nextRowTop = beforeBlock.getBlockHeight() + beforeBlock.getBlockTop();\n\n        var isInRange = function () {\n          return displayRowIndex >= displayIndexStart_1 && displayRowIndex < displayIndexStart_1 + blockSize;\n        };\n\n        while (!isInRange()) {\n          displayIndexStart_1 += blockSize;\n          var cachedBlockHeight = this.blockHeights[blockNumber];\n\n          if (_.exists(cachedBlockHeight)) {\n            nextRowTop += cachedBlockHeight;\n          } else {\n            nextRowTop += this.cacheParams.rowHeight * blockSize;\n          }\n\n          blockNumber++;\n        }\n      } else {\n        var localIndex = displayRowIndex - this.displayIndexStart;\n        blockNumber = Math.floor(localIndex / blockSize);\n        displayIndexStart_1 = this.displayIndexStart + blockNumber * blockSize;\n        nextRowTop = this.cacheTop + blockNumber * blockSize * this.cacheParams.rowHeight;\n      }\n\n      block = this.createBlock(blockNumber, displayIndexStart_1, {\n        value: nextRowTop\n      });\n      this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart_1);\n    }\n\n    return block ? block.getRow(displayRowIndex) : null;\n  };\n\n  ServerSideCache.prototype.getBlockSize = function () {\n    return this.cacheParams.blockSize ? this.cacheParams.blockSize : ServerSideBlock.DefaultBlockSize;\n  };\n\n  ServerSideCache.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n    var blockSize = this.getBlockSize();\n    var blockId = Math.floor(topLevelIndex / blockSize);\n    var block = this.getBlock(blockId);\n\n    if (block) {\n      // if we found a block, means row is in memory, so we can report the row index directly\n      var rowNode = block.getRowUsingLocalIndex(topLevelIndex, true);\n      return rowNode.rowIndex;\n    } else {\n      // otherwise we need to calculate it from the previous block\n      var blockBefore_1;\n      this.forEachBlockInOrder(function (currentBlock, currentId) {\n        if (blockId > currentId) {\n          // this will get assigned many times, but the last time will\n          // be the closest block to the required block that is BEFORE\n          blockBefore_1 = currentBlock;\n        }\n      });\n\n      if (blockBefore_1) {\n        // note: the local index is the same as the top level index, two terms for same thing\n        //\n        // get index of the last row before this row\n        // eg if blocksize = 100, then:\n        //   last row of first block is 99 (100 * 1) -1;\n        //   last row of second block is 199 (100 * 2) -1;\n        var lastRowTopLevelIndex = blockSize * (blockBefore_1.getBlockNumber() + 1) - 1; // get the last top level node in the block before the wanted block. this will be the last\n        // loaded displayed top level node.\n\n        var lastRowNode = blockBefore_1.getRowUsingLocalIndex(lastRowTopLevelIndex, true); // we want the index of the last displayed node, not just the top level node, so if the last top level node\n        // is open, we get the index of the last displayed child node.\n\n        var lastDisplayedNodeIndexInBlockBefore = void 0;\n\n        if (lastRowNode.expanded && lastRowNode.childrenCache) {\n          var serverSideCache = lastRowNode.childrenCache;\n          lastDisplayedNodeIndexInBlockBefore = serverSideCache.getDisplayIndexEnd() - 1;\n        } else if (lastRowNode.expanded && lastRowNode.detailNode) {\n          lastDisplayedNodeIndexInBlockBefore = lastRowNode.detailNode.rowIndex;\n        } else {\n          lastDisplayedNodeIndexInBlockBefore = lastRowNode.rowIndex;\n        } // we are guaranteed no rows are open. so the difference between the topTopIndex will be the\n        // same as the difference between the displayed index\n\n\n        var indexDiff = topLevelIndex - lastRowTopLevelIndex;\n        return lastDisplayedNodeIndexInBlockBefore + indexDiff;\n      } else {\n        return topLevelIndex;\n      }\n    }\n  };\n\n  ServerSideCache.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n    var newBlock = new ServerSideBlock(blockNumber, this.parentRowNode, this.cacheParams, this);\n    this.createBean(newBlock);\n    var displayIndexSequence = new NumberSequence(displayIndex);\n    newBlock.setDisplayIndexes(displayIndexSequence, this.getVirtualRowCount(), nextRowTop);\n    this.postCreateBlock(newBlock);\n    return newBlock;\n  };\n\n  ServerSideCache.prototype.getDisplayIndexEnd = function () {\n    return this.displayIndexEnd;\n  };\n\n  ServerSideCache.prototype.isDisplayIndexInCache = function (displayIndex) {\n    if (this.getVirtualRowCount() === 0) {\n      return false;\n    }\n\n    return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n  };\n\n  ServerSideCache.prototype.getChildCache = function (keys) {\n    var _this = this;\n\n    if (_.missingOrEmpty(keys)) {\n      return this;\n    }\n\n    var nextKey = keys[0];\n    var nextServerSideCache = null;\n    this.forEachBlockInOrder(function (block) {\n      // callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number\n      block.forEachNodeShallow(function (rowNode) {\n        if (rowNode.key === nextKey) {\n          nextServerSideCache = rowNode.childrenCache;\n        }\n      }, new NumberSequence(), _this.getVirtualRowCount());\n    });\n\n    if (nextServerSideCache) {\n      var keyListForNextLevel = keys.slice(1, keys.length);\n      return nextServerSideCache ? nextServerSideCache.getChildCache(keyListForNextLevel) : null;\n    } else {\n      return null;\n    }\n  };\n\n  ServerSideCache.prototype.isPixelInRange = function (pixel) {\n    if (this.getVirtualRowCount() === 0) {\n      return false;\n    }\n\n    return pixel >= this.cacheTop && pixel < this.cacheTop + this.cacheHeight;\n  };\n\n  ServerSideCache.prototype.refreshCacheAfterSort = function (changedColumnsInSort, rowGroupColIds) {\n    var _this = this;\n\n    var level = this.parentRowNode.level + 1;\n    var grouping = level < this.cacheParams.rowGroupCols.length;\n    var shouldPurgeCache;\n\n    if (grouping) {\n      var groupColVo = this.cacheParams.rowGroupCols[level];\n      var rowGroupBlock = rowGroupColIds.indexOf(groupColVo.id) > -1;\n      var sortingByGroup = changedColumnsInSort.indexOf(groupColVo.id) > -1;\n      shouldPurgeCache = rowGroupBlock && sortingByGroup;\n    } else {\n      shouldPurgeCache = true;\n    }\n\n    if (shouldPurgeCache) {\n      this.purgeCache();\n    } else {\n      this.forEachBlockInOrder(function (block) {\n        if (block.isGroupLevel()) {\n          var callback = function (rowNode) {\n            var nextCache = rowNode.childrenCache;\n\n            if (nextCache) {\n              nextCache.refreshCacheAfterSort(changedColumnsInSort, rowGroupColIds);\n            }\n          };\n\n          block.forEachNodeShallow(callback, new NumberSequence(), _this.getVirtualRowCount());\n        }\n      });\n    }\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], ServerSideCache.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], ServerSideCache.prototype, \"setBeans\", null);\n\n  return ServerSideCache;\n}(RowNodeCache);\n\nexport { ServerSideCache };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-enterprise/server-side-row-model/dist/es6/serverSideRowModel/serverSideCache.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","_","Autowired","NumberSequence","Qualifier","RowNodeCache","ServerSideBlock","ServerSideCache","_super","cacheParams","parentRowNode","_this","call","displayIndexStart","displayIndexEnd","cacheTop","blockHeights","setBeans","loggerFactory","logger","getRowBounds","index","result","blockFound","lastBlock","forEachBlockInOrder","block","isDisplayIndexInBlock","getVirtualRowCount","isBlockBefore","nextRowTop","nextRowIndex","getBlockTop","getBlockHeight","getDisplayIndexEnd","rowsBetween","rowHeight","rowTop","destroyBlock","getRowIndexAtPixel","pixel","isPixelInRange","pixelsBetween","lastAllowedIndex","clearDisplayIndexes","undefined","setDisplayIndexes","displayIndexSeq","peek","value","lastBlockId","blockSize","getBlockSize","currentBlock","blockId","blocksSkippedCount","rowsSkippedCount","skip","blockToAddId","exists","lastVisitedRow","rowCount","rowsNotAccountedFor","cacheHeight","getRow","displayRowIndex","dontCreateBlock","isDisplayIndexInCache","beforeBlock","missing","blockNumber","displayIndexStart_1","getBlockNumber","isInRange","cachedBlockHeight","localIndex","Math","floor","createBlock","log","DefaultBlockSize","getTopLevelRowDisplayedIndex","topLevelIndex","getBlock","rowNode","getRowUsingLocalIndex","rowIndex","blockBefore_1","currentId","lastRowTopLevelIndex","lastRowNode","lastDisplayedNodeIndexInBlockBefore","expanded","childrenCache","serverSideCache","detailNode","indexDiff","displayIndex","newBlock","createBean","displayIndexSequence","postCreateBlock","getChildCache","keys","missingOrEmpty","nextKey","nextServerSideCache","forEachNodeShallow","keyListForNextLevel","slice","refreshCacheAfterSort","changedColumnsInSort","rowGroupColIds","level","grouping","rowGroupCols","shouldPurgeCache","groupColVo","rowGroupBlock","indexOf","id","sortingByGroup","purgeCache","isGroupLevel","callback","nextCache"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { _, Autowired, NumberSequence, Qualifier, RowNodeCache } from \"@ag-grid-community/core\";\nimport { ServerSideBlock } from \"./serverSideBlock\";\nvar ServerSideCache = /** @class */ (function (_super) {\n    __extends(ServerSideCache, _super);\n    function ServerSideCache(cacheParams, parentRowNode) {\n        var _this = _super.call(this, cacheParams) || this;\n        // this will always be zero for the top level cache only,\n        // all the other ones change as the groups open and close\n        _this.displayIndexStart = 0;\n        _this.displayIndexEnd = 0; // not sure if setting this one to zero is necessary\n        _this.cacheTop = 0;\n        _this.blockHeights = {};\n        _this.parentRowNode = parentRowNode;\n        return _this;\n    }\n    ServerSideCache.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ServerSideCache');\n    };\n    ServerSideCache.prototype.getRowBounds = function (index) {\n        // this.logger.log(`getRowBounds(${index})`);\n        var _this = this;\n        // we return null if row not found\n        // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n        // should be RowBounds\n        var result;\n        var blockFound = false;\n        // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n        // should be ServerSideBlock\n        var lastBlock = null;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound) {\n                return;\n            }\n            if (block.isDisplayIndexInBlock(index)) {\n                result = block.getRowBounds(index, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.isBlockBefore(index)) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock !== null) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var rowsBetween = index - nextRowIndex;\n            result = {\n                rowHeight: this.cacheParams.rowHeight,\n                rowTop: nextRowTop + rowsBetween * this.cacheParams.rowHeight\n            };\n        }\n        // NOTE: what about purged blocks\n        // this.logger.log(`getRowBounds(${index}), result = ${result}`);\n        return result;\n    };\n    ServerSideCache.prototype.destroyBlock = function (block) {\n        _super.prototype.destroyBlock.call(this, block);\n    };\n    ServerSideCache.prototype.getRowIndexAtPixel = function (pixel) {\n        // this.logger.log(`getRowIndexAtPixel(${pixel})`);\n        var _this = this;\n        // we return null if row not found\n        // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n        // should be number\n        var result;\n        var blockFound = false;\n        // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n        // should be ServerSideBlock\n        var lastBlock;\n        this.forEachBlockInOrder(function (block) {\n            if (blockFound) {\n                return;\n            }\n            if (block.isPixelInRange(pixel)) {\n                result = block.getRowIndexAtPixel(pixel, _this.getVirtualRowCount());\n                blockFound = true;\n            }\n            else if (block.getBlockTop() < pixel) {\n                lastBlock = block;\n            }\n        });\n        if (!blockFound) {\n            var nextRowTop = void 0;\n            var nextRowIndex = void 0;\n            if (lastBlock) {\n                nextRowTop = lastBlock.getBlockTop() + lastBlock.getBlockHeight();\n                nextRowIndex = lastBlock.getDisplayIndexEnd();\n            }\n            else {\n                nextRowTop = this.cacheTop;\n                nextRowIndex = this.displayIndexStart;\n            }\n            var pixelsBetween = pixel - nextRowTop;\n            var rowsBetween = (pixelsBetween / this.cacheParams.rowHeight) | 0;\n            result = nextRowIndex + rowsBetween;\n        }\n        var lastAllowedIndex = this.getDisplayIndexEnd() - 1;\n        if (result > lastAllowedIndex) {\n            result = lastAllowedIndex;\n        }\n        //NOTE: purged\n        // this.logger.log(`getRowIndexAtPixel(${pixel}) result = ${result}`);\n        return result;\n    };\n    ServerSideCache.prototype.clearDisplayIndexes = function () {\n        var _this = this;\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.forEachBlockInOrder(function (block) { return block.clearDisplayIndexes(_this.getVirtualRowCount()); });\n    };\n    ServerSideCache.prototype.setDisplayIndexes = function (displayIndexSeq, nextRowTop) {\n        var _this = this;\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.cacheTop = nextRowTop.value;\n        var lastBlockId = -1;\n        var blockSize = this.getBlockSize();\n        this.forEachBlockInOrder(function (currentBlock, blockId) {\n            // if we skipped blocks, then we need to skip the row indexes. we assume that all missing\n            // blocks are made up of closed RowNodes only (if they were groups), as we never expire from\n            // the cache if any row nodes are open.\n            var blocksSkippedCount = blockId - lastBlockId - 1;\n            var rowsSkippedCount = blocksSkippedCount * blockSize;\n            if (rowsSkippedCount > 0) {\n                displayIndexSeq.skip(rowsSkippedCount);\n            }\n            for (var i = 1; i <= blocksSkippedCount; i++) {\n                var blockToAddId = blockId - i;\n                if (_.exists(_this.blockHeights[blockToAddId])) {\n                    nextRowTop.value += _this.blockHeights[blockToAddId];\n                }\n                else {\n                    nextRowTop.value += blockSize * _this.cacheParams.rowHeight;\n                }\n            }\n            lastBlockId = blockId;\n            currentBlock.setDisplayIndexes(displayIndexSeq, _this.getVirtualRowCount(), nextRowTop);\n            _this.blockHeights[blockId] = currentBlock.getBlockHeight();\n        });\n        // if any blocks missing at the end, need to increase the row index for them also\n        // eg if block size = 10, we have total rows of 25 (indexes 0 .. 24), but first 2 blocks loaded (because\n        // last row was ejected from cache), then:\n        // lastVisitedRow = 19, virtualRowCount = 25, rows not accounted for = 5 (24 - 19)\n        var lastVisitedRow = ((lastBlockId + 1) * blockSize) - 1;\n        var rowCount = this.getVirtualRowCount();\n        var rowsNotAccountedFor = rowCount - lastVisitedRow - 1;\n        if (rowsNotAccountedFor > 0) {\n            displayIndexSeq.skip(rowsNotAccountedFor);\n            nextRowTop.value += rowsNotAccountedFor * this.cacheParams.rowHeight;\n        }\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.cacheHeight = nextRowTop.value - this.cacheTop;\n    };\n    // gets called in a) init() above and b) by the grid\n    ServerSideCache.prototype.getRow = function (displayRowIndex, dontCreateBlock) {\n        if (dontCreateBlock === void 0) { dontCreateBlock = false; }\n        // this can happen if asking for a row that doesn't exist in the model,\n        // eg if a cell range is selected, and the user filters so rows no longer\n        // exist\n        if (!this.isDisplayIndexInCache(displayRowIndex)) {\n            return null;\n        }\n        // if we have the block, then this is the block\n        var block = null;\n        // this is the last block that we have BEFORE the right block\n        // note - cast to \"any\" due to https://github.com/Microsoft/TypeScript/issues/11498\n        // should be ServerSideBlock\n        var beforeBlock = null;\n        this.forEachBlockInOrder(function (currentBlock) {\n            if (currentBlock.isDisplayIndexInBlock(displayRowIndex)) {\n                block = currentBlock;\n            }\n            else if (currentBlock.isBlockBefore(displayRowIndex)) {\n                // this will get assigned many times, but the last time will\n                // be the closest block to the required block that is BEFORE\n                beforeBlock = currentBlock;\n            }\n        });\n        // when we are moving rows around, we don't want to trigger loads\n        if (_.missing(block) && dontCreateBlock) {\n            return null;\n        }\n        var blockSize = this.getBlockSize();\n        // if block not found, we need to load it\n        if (_.missing(block)) {\n            var blockNumber = void 0;\n            var displayIndexStart_1;\n            var nextRowTop = void 0;\n            // because missing blocks are always fully closed, we can work out\n            // the start index of the block we want by hopping from the closest block,\n            // as we know the row count in closed blocks is equal to the page size\n            if (beforeBlock) {\n                blockNumber = beforeBlock.getBlockNumber() + 1;\n                displayIndexStart_1 = beforeBlock.getDisplayIndexEnd();\n                nextRowTop = beforeBlock.getBlockHeight() + beforeBlock.getBlockTop();\n                var isInRange = function () {\n                    return displayRowIndex >= displayIndexStart_1 && displayRowIndex < (displayIndexStart_1 + blockSize);\n                };\n                while (!isInRange()) {\n                    displayIndexStart_1 += blockSize;\n                    var cachedBlockHeight = this.blockHeights[blockNumber];\n                    if (_.exists(cachedBlockHeight)) {\n                        nextRowTop += cachedBlockHeight;\n                    }\n                    else {\n                        nextRowTop += this.cacheParams.rowHeight * blockSize;\n                    }\n                    blockNumber++;\n                }\n            }\n            else {\n                var localIndex = displayRowIndex - this.displayIndexStart;\n                blockNumber = Math.floor(localIndex / blockSize);\n                displayIndexStart_1 = this.displayIndexStart + (blockNumber * blockSize);\n                nextRowTop = this.cacheTop + (blockNumber * blockSize * this.cacheParams.rowHeight);\n            }\n            block = this.createBlock(blockNumber, displayIndexStart_1, { value: nextRowTop });\n            this.logger.log(\"block missing, rowIndex = \" + displayRowIndex + \", creating #\" + blockNumber + \", displayIndexStart = \" + displayIndexStart_1);\n        }\n        return block ? block.getRow(displayRowIndex) : null;\n    };\n    ServerSideCache.prototype.getBlockSize = function () {\n        return this.cacheParams.blockSize ? this.cacheParams.blockSize : ServerSideBlock.DefaultBlockSize;\n    };\n    ServerSideCache.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var blockSize = this.getBlockSize();\n        var blockId = Math.floor(topLevelIndex / blockSize);\n        var block = this.getBlock(blockId);\n        if (block) {\n            // if we found a block, means row is in memory, so we can report the row index directly\n            var rowNode = block.getRowUsingLocalIndex(topLevelIndex, true);\n            return rowNode.rowIndex;\n        }\n        else {\n            // otherwise we need to calculate it from the previous block\n            var blockBefore_1;\n            this.forEachBlockInOrder(function (currentBlock, currentId) {\n                if (blockId > currentId) {\n                    // this will get assigned many times, but the last time will\n                    // be the closest block to the required block that is BEFORE\n                    blockBefore_1 = currentBlock;\n                }\n            });\n            if (blockBefore_1) {\n                // note: the local index is the same as the top level index, two terms for same thing\n                //\n                // get index of the last row before this row\n                // eg if blocksize = 100, then:\n                //   last row of first block is 99 (100 * 1) -1;\n                //   last row of second block is 199 (100 * 2) -1;\n                var lastRowTopLevelIndex = (blockSize * (blockBefore_1.getBlockNumber() + 1)) - 1;\n                // get the last top level node in the block before the wanted block. this will be the last\n                // loaded displayed top level node.\n                var lastRowNode = blockBefore_1.getRowUsingLocalIndex(lastRowTopLevelIndex, true);\n                // we want the index of the last displayed node, not just the top level node, so if the last top level node\n                // is open, we get the index of the last displayed child node.\n                var lastDisplayedNodeIndexInBlockBefore = void 0;\n                if (lastRowNode.expanded && lastRowNode.childrenCache) {\n                    var serverSideCache = lastRowNode.childrenCache;\n                    lastDisplayedNodeIndexInBlockBefore = serverSideCache.getDisplayIndexEnd() - 1;\n                }\n                else if (lastRowNode.expanded && lastRowNode.detailNode) {\n                    lastDisplayedNodeIndexInBlockBefore = lastRowNode.detailNode.rowIndex;\n                }\n                else {\n                    lastDisplayedNodeIndexInBlockBefore = lastRowNode.rowIndex;\n                }\n                // we are guaranteed no rows are open. so the difference between the topTopIndex will be the\n                // same as the difference between the displayed index\n                var indexDiff = topLevelIndex - lastRowTopLevelIndex;\n                return lastDisplayedNodeIndexInBlockBefore + indexDiff;\n            }\n            else {\n                return topLevelIndex;\n            }\n        }\n    };\n    ServerSideCache.prototype.createBlock = function (blockNumber, displayIndex, nextRowTop) {\n        var newBlock = new ServerSideBlock(blockNumber, this.parentRowNode, this.cacheParams, this);\n        this.createBean(newBlock);\n        var displayIndexSequence = new NumberSequence(displayIndex);\n        newBlock.setDisplayIndexes(displayIndexSequence, this.getVirtualRowCount(), nextRowTop);\n        this.postCreateBlock(newBlock);\n        return newBlock;\n    };\n    ServerSideCache.prototype.getDisplayIndexEnd = function () {\n        return this.displayIndexEnd;\n    };\n    ServerSideCache.prototype.isDisplayIndexInCache = function (displayIndex) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart && displayIndex < this.displayIndexEnd;\n    };\n    ServerSideCache.prototype.getChildCache = function (keys) {\n        var _this = this;\n        if (_.missingOrEmpty(keys)) {\n            return this;\n        }\n        var nextKey = keys[0];\n        var nextServerSideCache = null;\n        this.forEachBlockInOrder(function (block) {\n            // callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number\n            block.forEachNodeShallow(function (rowNode) {\n                if (rowNode.key === nextKey) {\n                    nextServerSideCache = rowNode.childrenCache;\n                }\n            }, new NumberSequence(), _this.getVirtualRowCount());\n        });\n        if (nextServerSideCache) {\n            var keyListForNextLevel = keys.slice(1, keys.length);\n            return nextServerSideCache ? nextServerSideCache.getChildCache(keyListForNextLevel) : null;\n        }\n        else {\n            return null;\n        }\n    };\n    ServerSideCache.prototype.isPixelInRange = function (pixel) {\n        if (this.getVirtualRowCount() === 0) {\n            return false;\n        }\n        return pixel >= this.cacheTop && pixel < (this.cacheTop + this.cacheHeight);\n    };\n    ServerSideCache.prototype.refreshCacheAfterSort = function (changedColumnsInSort, rowGroupColIds) {\n        var _this = this;\n        var level = this.parentRowNode.level + 1;\n        var grouping = level < this.cacheParams.rowGroupCols.length;\n        var shouldPurgeCache;\n        if (grouping) {\n            var groupColVo = this.cacheParams.rowGroupCols[level];\n            var rowGroupBlock = rowGroupColIds.indexOf(groupColVo.id) > -1;\n            var sortingByGroup = changedColumnsInSort.indexOf(groupColVo.id) > -1;\n            shouldPurgeCache = rowGroupBlock && sortingByGroup;\n        }\n        else {\n            shouldPurgeCache = true;\n        }\n        if (shouldPurgeCache) {\n            this.purgeCache();\n        }\n        else {\n            this.forEachBlockInOrder(function (block) {\n                if (block.isGroupLevel()) {\n                    var callback = function (rowNode) {\n                        var nextCache = rowNode.childrenCache;\n                        if (nextCache) {\n                            nextCache.refreshCacheAfterSort(changedColumnsInSort, rowGroupColIds);\n                        }\n                    };\n                    block.forEachNodeShallow(callback, new NumberSequence(), _this.getVirtualRowCount());\n                }\n            });\n        }\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], ServerSideCache.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], ServerSideCache.prototype, \"setBeans\", null);\n    return ServerSideCache;\n}(RowNodeCache));\nexport { ServerSideCache };\n"]},"metadata":{},"sourceType":"module"}