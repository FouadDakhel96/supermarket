{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Autowired, Bean, ChangedPath, Constants as constants, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, RowNode, BeanStub, _ } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n\n(function (RecursionType) {\n  RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n  RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n  RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n  RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\n\nvar ClientSideRowModel =\n/** @class */\nfunction (_super) {\n  __extends(ClientSideRowModel, _super);\n\n  function ClientSideRowModel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ClientSideRowModel.prototype.init = function () {\n    var refreshEverythingFunc = this.refreshModel.bind(this, {\n      step: Constants.STEP_EVERYTHING\n    });\n    var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n      step: Constants.STEP_EVERYTHING,\n      afterColumnsChanged: true,\n      keepRenderedRows: true\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_EVERYTHING_CHANGED, refreshEverythingAfterColsChangedFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, {\n      step: Constants.STEP_PIVOT\n    }));\n    this.addManagedListener(this.eventService, Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n    var refreshMapListener = this.refreshModel.bind(this, {\n      step: Constants.STEP_MAP,\n      keepRenderedRows: true,\n      animate: true\n    });\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n    this.rootNode = new RowNode();\n    this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.getContext(), this.eventService, this.columnController, this.gridApi, this.columnApi, this.selectionController);\n    this.createBean(this.rootNode);\n  };\n\n  ClientSideRowModel.prototype.start = function () {\n    var rowData = this.gridOptionsWrapper.getRowData();\n\n    if (rowData) {\n      this.setRowData(rowData);\n    }\n  };\n\n  ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n    var atLeastOneChange;\n    var res = false; // we do this multiple times as changing the row heights can also change the first and last rows,\n    // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n    // more rows.\n\n    do {\n      atLeastOneChange = false;\n      var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n      var rowAtEndPixel = this.getRowIndexAtPixel(endPixel); // keep check to current page if doing pagination\n\n      var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n      var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n\n      for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n        var rowNode = this.getRow(rowIndex);\n\n        if (rowNode.rowHeightEstimated) {\n          var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n          rowNode.setRowHeight(rowHeight.height);\n          atLeastOneChange = true;\n          res = true;\n        }\n      }\n\n      if (atLeastOneChange) {\n        this.setRowTops();\n      }\n    } while (atLeastOneChange);\n\n    return res;\n  };\n\n  ClientSideRowModel.prototype.setRowTops = function () {\n    var nextRowTop = 0;\n\n    for (var i = 0; i < this.rowsToDisplay.length; i++) {\n      // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n      // with these two layouts.\n      var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n      var rowNode = this.rowsToDisplay[i];\n\n      if (_.missing(rowNode.rowHeight)) {\n        var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate);\n        rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n      }\n\n      rowNode.setRowTop(nextRowTop);\n      rowNode.setRowIndex(i);\n      nextRowTop += rowNode.rowHeight;\n    }\n  };\n\n  ClientSideRowModel.prototype.resetRowTops = function (rowNode, changedPath) {\n    rowNode.clearRowTop();\n\n    if (rowNode.hasChildren()) {\n      if (rowNode.childrenAfterGroup) {\n        // if a changedPath is active, it means we are here because of a transaction update or\n        // a change detection. neither of these impacts the open/closed state of groups. so if\n        // a group is not open this time, it was not open last time. so we know all closed groups\n        // already have their top positions cleared. so there is no need to traverse all the way\n        // when changedPath is active and the rowNode is not expanded.\n        var skipChildren = changedPath.isActive() && !rowNode.expanded;\n\n        if (!skipChildren) {\n          for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n            this.resetRowTops(rowNode.childrenAfterGroup[i], changedPath);\n          }\n        }\n      }\n\n      if (rowNode.sibling) {\n        rowNode.sibling.clearRowTop();\n      }\n    }\n\n    if (rowNode.detailNode) {\n      rowNode.detailNode.clearRowTop();\n    }\n  }; // returns false if row was moved, otherwise true\n\n\n  ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n    var _this = this;\n\n    if (increment === void 0) {\n      increment = 0;\n    }\n\n    var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n    var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n\n    if (rowNodeAtPixelNow === rowNodes[0]) {\n      return false;\n    }\n\n    rowNodes.forEach(function (rowNode) {\n      _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n    });\n    rowNodes.forEach(function (rowNode, idx) {\n      _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, indexAtPixelNow + increment + idx);\n    });\n    this.refreshModel({\n      step: Constants.STEP_EVERYTHING,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    return true;\n  };\n\n  ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n    var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n    var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n\n    if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n      if (this.lastHighlightedRow) {\n        this.lastHighlightedRow.setHighlighted(null);\n        this.lastHighlightedRow = null;\n      }\n\n      return;\n    }\n\n    var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n\n    if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n      this.lastHighlightedRow.setHighlighted(null);\n      this.lastHighlightedRow = null;\n    }\n\n    rowNodeAtPixelNow.setHighlighted(highlight);\n    this.lastHighlightedRow = rowNodeAtPixelNow;\n  };\n\n  ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n    if (!rowNode) {\n      var index = this.getRowIndexAtPixel(pixel);\n      rowNode = this.getRow(index || 0);\n\n      if (!rowNode) {\n        return 'below';\n      }\n    }\n\n    var rowTop = rowNode.rowTop,\n        rowHeight = rowNode.rowHeight;\n    return pixel - rowTop < rowHeight / 2 ? 'above' : 'below';\n  };\n\n  ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n    return this.lastHighlightedRow;\n  };\n\n  ClientSideRowModel.prototype.isLastRowFound = function () {\n    return true;\n  };\n\n  ClientSideRowModel.prototype.getRowCount = function () {\n    if (this.rowsToDisplay) {\n      return this.rowsToDisplay.length;\n    }\n\n    return 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return 1;\n    }\n\n    return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n  };\n\n  ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n    var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n    if (showingRootNode) {\n      return topLevelIndex;\n    }\n\n    var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n\n    if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n      while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n        rowNode = rowNode.childrenAfterSort[0];\n      }\n    }\n\n    return rowNode.rowIndex;\n  };\n\n  ClientSideRowModel.prototype.getRowBounds = function (index) {\n    if (_.missing(this.rowsToDisplay)) {\n      return null;\n    }\n\n    var rowNode = this.rowsToDisplay[index];\n\n    if (rowNode) {\n      return {\n        rowTop: rowNode.rowTop,\n        rowHeight: rowNode.rowHeight\n      };\n    }\n\n    return null;\n  };\n\n  ClientSideRowModel.prototype.onRowGroupOpened = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: Constants.STEP_MAP,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onFilterChanged = function (event) {\n    if (event.afterDataChange) {\n      return;\n    }\n\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: Constants.STEP_FILTER,\n      keepRenderedRows: true,\n      animate: animate\n    });\n  };\n\n  ClientSideRowModel.prototype.onSortChanged = function () {\n    var animate = this.gridOptionsWrapper.isAnimateRows();\n    this.refreshModel({\n      step: Constants.STEP_SORT,\n      keepRenderedRows: true,\n      animate: animate,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.getType = function () {\n    return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n  };\n\n  ClientSideRowModel.prototype.onValueChanged = function () {\n    if (this.columnController.isPivotActive()) {\n      this.refreshModel({\n        step: Constants.STEP_PIVOT\n      });\n    } else {\n      this.refreshModel({\n        step: Constants.STEP_AGGREGATE\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n    // for updates, if the row is updated at all, then we re-calc all the values\n    // in that row. we could compare each value to each old value, however if we\n    // did this, we would be calling the valueService twice, once on the old value\n    // and once on the new value. so it's less valueGetter calls if we just assume\n    // each column is different. that way the changedPath is used so that only\n    // the impacted parent rows are recalculated, parents who's children have\n    // not changed are not impacted.\n    var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n\n    var changedPath = new ChangedPath(false, this.rootNode);\n\n    if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n      changedPath.setInactive();\n    }\n\n    return changedPath;\n  };\n\n  ClientSideRowModel.prototype.refreshModel = function (params) {\n    // this goes through the pipeline of stages. what's in my head is similar\n    // to the diagram on this page:\n    // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n    // however we want to keep the results of each stage, hence we manually call\n    // each step rather than have them chain each other.\n    var _this = this; // fallthrough in below switch is on purpose,\n    // eg if STEP_FILTER, then all steps below this\n    // step get done\n    // let start: number;\n    // console.log('======= start =======');\n\n\n    var changedPath = this.createChangePath(params.rowNodeTransactions);\n\n    switch (params.step) {\n      case constants.STEP_EVERYTHING:\n        // start = new Date().getTime();\n        this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, params.afterColumnsChanged);\n      // console.log('rowGrouping = ' + (new Date().getTime() - start));\n\n      case constants.STEP_FILTER:\n        // start = new Date().getTime();\n        this.doFilter(changedPath);\n      // console.log('filter = ' + (new Date().getTime() - start));\n\n      case constants.STEP_PIVOT:\n        this.doPivot(changedPath);\n\n      case constants.STEP_AGGREGATE:\n        // depends on agg fields\n        // start = new Date().getTime();\n        this.doAggregate(changedPath);\n      // console.log('aggregation = ' + (new Date().getTime() - start));\n\n      case constants.STEP_SORT:\n        // start = new Date().getTime();\n        this.doSort(params.rowNodeTransactions, changedPath);\n      // console.log('sort = ' + (new Date().getTime() - start));\n\n      case constants.STEP_MAP:\n        // start = new Date().getTime();\n        this.doRowsToDisplay();\n      // console.log('rowsToDisplay = ' + (new Date().getTime() - start));\n    } // set all row tops to null, then set row tops on all visible rows. if we don't\n    // do this, then the algorithm below only sets row tops, old row tops from old rows\n    // will still lie around\n\n\n    this.resetRowTops(this.rootNode, changedPath);\n    this.setRowTops();\n    var event = {\n      type: Events.EVENT_MODEL_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      animate: params.animate,\n      keepRenderedRows: params.keepRenderedRows,\n      newData: params.newData,\n      newPage: false\n    };\n    this.eventService.dispatchEvent(event);\n\n    if (this.$scope) {\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  ClientSideRowModel.prototype.isEmpty = function () {\n    var rowsMissing;\n\n    var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n\n    if (doingLegacyTreeData) {\n      rowsMissing = _.missing(this.rootNode.childrenAfterGroup) || this.rootNode.childrenAfterGroup.length === 0;\n    } else {\n      rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n    }\n\n    var empty = _.missing(this.rootNode) || rowsMissing || !this.columnController.isReady();\n    return empty;\n  };\n\n  ClientSideRowModel.prototype.isRowsToRender = function () {\n    return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n  };\n\n  ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n    // if lastSelectedNode is missing, we start at the first row\n    var firstRowHit = !lastInRange;\n    var lastRowHit = false;\n    var lastRow;\n    var result = [];\n    var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n    this.forEachNodeAfterFilterAndSort(function (rowNode) {\n      var lookingForLastRow = firstRowHit && !lastRowHit; // check if we need to flip the select switch\n\n      if (!firstRowHit) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          firstRowHit = true;\n        }\n      }\n\n      var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n\n      if (!skipThisGroupNode) {\n        var inRange = firstRowHit && !lastRowHit;\n        var childOfLastRow = rowNode.isParentOfNode(lastRow);\n\n        if (inRange || childOfLastRow) {\n          result.push(rowNode);\n        }\n      }\n\n      if (lookingForLastRow) {\n        if (rowNode === lastInRange || rowNode === firstInRange) {\n          lastRowHit = true;\n\n          if (rowNode === lastInRange) {\n            lastRow = lastInRange;\n          } else {\n            lastRow = firstInRange;\n          }\n        }\n      }\n    });\n    return result;\n  };\n\n  ClientSideRowModel.prototype.setDatasource = function (datasource) {\n    console.error('ag-Grid: should never call setDatasource on clientSideRowController');\n  };\n\n  ClientSideRowModel.prototype.getTopLevelNodes = function () {\n    return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n  };\n\n  ClientSideRowModel.prototype.getRootNode = function () {\n    return this.rootNode;\n  };\n\n  ClientSideRowModel.prototype.getRow = function (index) {\n    return this.rowsToDisplay[index];\n  };\n\n  ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n    return this.rowsToDisplay.indexOf(rowNode) >= 0;\n  };\n\n  ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n    if (this.isEmpty()) {\n      return -1;\n    } // do binary search of tree\n    // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n\n\n    var bottomPointer = 0;\n    var topPointer = this.rowsToDisplay.length - 1; // quick check, if the pixel is out of bounds, then return last row\n\n    if (pixelToMatch <= 0) {\n      // if pixel is less than or equal zero, it's always the first row\n      return 0;\n    }\n\n    var lastNode = _.last(this.rowsToDisplay);\n\n    if (lastNode.rowTop <= pixelToMatch) {\n      return this.rowsToDisplay.length - 1;\n    }\n\n    while (true) {\n      var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n      var currentRowNode = this.rowsToDisplay[midPointer];\n\n      if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n        return midPointer;\n      }\n\n      if (currentRowNode.rowTop < pixelToMatch) {\n        bottomPointer = midPointer + 1;\n      } else if (currentRowNode.rowTop > pixelToMatch) {\n        topPointer = midPointer - 1;\n      }\n    }\n  };\n\n  ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n    var topPixel = rowNode.rowTop;\n    var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n    var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n    return pixelInRow;\n  };\n\n  ClientSideRowModel.prototype.getCurrentPageHeight = function () {\n    if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {\n      var lastRow = _.last(this.rowsToDisplay);\n\n      var lastPixel = lastRow.rowTop + lastRow.rowHeight;\n      return lastPixel;\n    }\n\n    return 0;\n  };\n\n  ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n    if (this.rootNode.allLeafChildren) {\n      this.rootNode.allLeafChildren.forEach(function (rowNode, index) {\n        return callback(rowNode, index);\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.forEachNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n    this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n  };\n\n  ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n    this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n  }; // iterates through each item in memory, and calls the callback function\n  // nodes - the rowNodes to traverse\n  // callback - the user provided callback\n  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n  // index - works similar to the index in forEach in javascript's array function\n\n\n  ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n    if (!nodes) {\n      return index;\n    }\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      callback(node, index++); // go to the next level if it is a group\n\n      if (node.hasChildren()) {\n        // depending on the recursion type, we pick a difference set of children\n        var nodeChildren = null;\n\n        switch (recursionType) {\n          case RecursionType.Normal:\n            nodeChildren = node.childrenAfterGroup;\n            break;\n\n          case RecursionType.AfterFilter:\n            nodeChildren = node.childrenAfterFilter;\n            break;\n\n          case RecursionType.AfterFilterAndSort:\n            nodeChildren = node.childrenAfterSort;\n            break;\n\n          case RecursionType.PivotNodes:\n            // for pivot, we don't go below leafGroup levels\n            nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n            break;\n        }\n\n        if (nodeChildren) {\n          index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n        }\n      }\n    }\n\n    return index;\n  }; // it's possible to recompute the aggregate without doing the other parts\n  // + gridApi.recomputeAggregates()\n\n\n  ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n    if (this.aggregationStage) {\n      this.aggregationStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  }; // + gridApi.expandAll()\n  // + gridApi.collapseAll()\n\n\n  ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n    var usingTreeData = this.gridOptionsWrapper.isTreeData();\n\n    if (this.rootNode) {\n      recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n    }\n\n    function recursiveExpandOrCollapse(rowNodes) {\n      if (!rowNodes) {\n        return;\n      }\n\n      rowNodes.forEach(function (rowNode) {\n        var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n\n        if (shouldExpandOrCollapse) {\n          rowNode.expanded = expand;\n          recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n        }\n      });\n    }\n\n    this.refreshModel({\n      step: Constants.STEP_MAP\n    });\n    var eventSource = expand ? 'expandAll' : 'collapseAll';\n    var event = {\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n      source: eventSource\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n    this.sortStage.execute({\n      rowNode: this.rootNode,\n      rowNodeTransactions: rowNodeTransactions,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n    // grouping is enterprise only, so if service missing, skip the step\n    var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n\n    if (doingLegacyTreeData) {\n      return;\n    }\n\n    if (this.groupStage) {\n      if (rowNodeTransactions) {\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          rowNodeTransactions: rowNodeTransactions,\n          rowNodeOrder: rowNodeOrder,\n          changedPath: changedPath\n        });\n      } else {\n        // groups are about to get disposed, so need to deselect any that are selected\n        this.selectionController.removeGroupsFromSelection();\n        this.groupStage.execute({\n          rowNode: this.rootNode,\n          changedPath: changedPath,\n          afterColumnsChanged: afterColumnsChanged\n        }); // set open/closed state on groups\n\n        this.restoreGroupState(groupState);\n      }\n\n      if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n        this.selectionController.updateGroupsFromChildrenSelections(changedPath);\n      }\n    } else {\n      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n    }\n  };\n\n  ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n    if (!groupState) {\n      return;\n    }\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      // if the group was open last time, then open it this time. however\n      // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n      // setting will take effect.\n      if (typeof groupState[key] === 'boolean') {\n        node.expanded = groupState[key];\n      }\n    });\n  };\n\n  ClientSideRowModel.prototype.doFilter = function (changedPath) {\n    this.filterStage.execute({\n      rowNode: this.rootNode,\n      changedPath: changedPath\n    });\n  };\n\n  ClientSideRowModel.prototype.doPivot = function (changedPath) {\n    if (this.pivotStage) {\n      this.pivotStage.execute({\n        rowNode: this.rootNode,\n        changedPath: changedPath\n      });\n    }\n  };\n\n  ClientSideRowModel.prototype.getGroupState = function () {\n    if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n      return null;\n    }\n\n    var result = {};\n\n    _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n      return result[key] = node.expanded;\n    });\n\n    return result;\n  };\n\n  ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n    return this.nodeManager.getCopyOfNodesMap();\n  };\n\n  ClientSideRowModel.prototype.getRowNode = function (id) {\n    return this.nodeManager.getRowNode(id);\n  }; // rows: the rows to put into the model\n\n\n  ClientSideRowModel.prototype.setRowData = function (rowData) {\n    // no need to invalidate cache, as the cache is stored on the rowNode,\n    // so new rowNodes means the cache is wiped anyway.\n    // remember group state, so we can expand groups that should be expanded\n    var groupState = this.getGroupState();\n    this.nodeManager.setRowData(rowData); // this event kicks off:\n    // - clears selection\n    // - updates filters\n    // - shows 'no rows' overlay if needed\n\n    var rowDataChangedEvent = {\n      type: Events.EVENT_ROW_DATA_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(rowDataChangedEvent);\n    this.refreshModel({\n      step: Constants.STEP_EVERYTHING,\n      groupState: groupState,\n      newData: true\n    });\n  };\n\n  ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n    var _this = this;\n\n    if (!this.rowDataTransactionBatch) {\n      this.rowDataTransactionBatch = [];\n      var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n      window.setTimeout(function () {\n        _this.executeBatchUpdateRowData();\n\n        _this.rowDataTransactionBatch = null;\n      }, waitMillis);\n    }\n\n    this.rowDataTransactionBatch.push({\n      rowDataTransaction: rowDataTransaction,\n      callback: callback\n    });\n  };\n\n  ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n    var _this = this;\n\n    this.valueCache.onDataChanged();\n    var callbackFuncsBound = [];\n    var rowNodeTrans = [];\n\n    if (this.rowDataTransactionBatch) {\n      this.rowDataTransactionBatch.forEach(function (tranItem) {\n        var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, null);\n\n        rowNodeTrans.push(rowNodeTran);\n\n        if (tranItem.callback) {\n          callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n        }\n      });\n    }\n\n    this.commonUpdateRowData(rowNodeTrans); // do callbacks in next VM turn so it's async\n\n    if (callbackFuncsBound.length > 0) {\n      window.setTimeout(function () {\n        callbackFuncsBound.forEach(function (func) {\n          return func();\n        });\n      }, 0);\n    }\n  };\n\n  ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n    this.valueCache.onDataChanged();\n    var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n    this.commonUpdateRowData([rowNodeTran], rowNodeOrder);\n    return rowNodeTran;\n  }; // common to updateRowData and batchUpdateRowData\n\n\n  ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder) {\n    this.refreshModel({\n      step: Constants.STEP_EVERYTHING,\n      rowNodeTransactions: rowNodeTrans,\n      rowNodeOrder: rowNodeOrder,\n      keepRenderedRows: true,\n      animate: true,\n      keepEditingRows: true\n    });\n    var event = {\n      type: Events.EVENT_ROW_DATA_UPDATED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ClientSideRowModel.prototype.doRowsToDisplay = function () {\n    this.rowsToDisplay = this.flattenStage.execute({\n      rowNode: this.rootNode\n    });\n  };\n\n  ClientSideRowModel.prototype.onRowHeightChanged = function () {\n    this.refreshModel({\n      step: Constants.STEP_MAP,\n      keepRenderedRows: true,\n      keepEditingRows: true\n    });\n  };\n\n  ClientSideRowModel.prototype.resetRowHeights = function () {\n    this.forEachNode(function (rowNode) {\n      rowNode.setRowHeight(null); // forEachNode doesn't go through detail rows, so need to check\n      // for detail nodes explicitly.\n\n      if (rowNode.detailNode) {\n        rowNode.detailNode.setRowHeight(null);\n      }\n    });\n    this.onRowHeightChanged();\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], ClientSideRowModel.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('columnController')], ClientSideRowModel.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('filterManager')], ClientSideRowModel.prototype, \"filterManager\", void 0);\n\n  __decorate([Autowired('$scope')], ClientSideRowModel.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired('selectionController')], ClientSideRowModel.prototype, \"selectionController\", void 0);\n\n  __decorate([Autowired('valueService')], ClientSideRowModel.prototype, \"valueService\", void 0);\n\n  __decorate([Autowired('valueCache')], ClientSideRowModel.prototype, \"valueCache\", void 0);\n\n  __decorate([Autowired('columnApi')], ClientSideRowModel.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], ClientSideRowModel.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('filterStage')], ClientSideRowModel.prototype, \"filterStage\", void 0);\n\n  __decorate([Autowired('sortStage')], ClientSideRowModel.prototype, \"sortStage\", void 0);\n\n  __decorate([Autowired('flattenStage')], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n\n  __decorate([Optional('groupStage')], ClientSideRowModel.prototype, \"groupStage\", void 0);\n\n  __decorate([Optional('aggregationStage')], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n\n  __decorate([Optional('pivotStage')], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n\n  __decorate([PostConstruct], ClientSideRowModel.prototype, \"init\", null);\n\n  ClientSideRowModel = __decorate([Bean('rowModel')], ClientSideRowModel);\n  return ClientSideRowModel;\n}(BeanStub);\n\nexport { ClientSideRowModel };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/client-side-row-model/dist/es6/clientSideRowModel/clientSideRowModel.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Autowired","Bean","ChangedPath","Constants","constants","Events","GridOptionsWrapper","Optional","PostConstruct","RowNode","BeanStub","_","ClientSideNodeManager","RecursionType","ClientSideRowModel","_super","apply","init","refreshEverythingFunc","refreshModel","bind","step","STEP_EVERYTHING","refreshEverythingAfterColsChangedFunc","afterColumnsChanged","keepRenderedRows","addManagedListener","eventService","EVENT_COLUMN_EVERYTHING_CHANGED","EVENT_COLUMN_ROW_GROUP_CHANGED","EVENT_COLUMN_VALUE_CHANGED","onValueChanged","EVENT_COLUMN_PIVOT_CHANGED","STEP_PIVOT","EVENT_ROW_GROUP_OPENED","onRowGroupOpened","EVENT_FILTER_CHANGED","onFilterChanged","EVENT_SORT_CHANGED","onSortChanged","EVENT_COLUMN_PIVOT_MODE_CHANGED","refreshMapListener","STEP_MAP","animate","gridOptionsWrapper","PROP_GROUP_REMOVE_SINGLE_CHILDREN","PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN","rootNode","nodeManager","getContext","columnController","gridApi","columnApi","selectionController","createBean","start","rowData","getRowData","setRowData","ensureRowHeightsValid","startPixel","endPixel","startLimitIndex","endLimitIndex","atLeastOneChange","res","rowAtStartPixel","getRowIndexAtPixel","rowAtEndPixel","firstRow","Math","max","lastRow","min","rowIndex","rowNode","getRow","rowHeightEstimated","rowHeight","getRowHeightForNode","setRowHeight","height","setRowTops","nextRowTop","rowsToDisplay","allowEstimate","getDomLayout","DOM_LAYOUT_NORMAL","missing","estimated","setRowTop","setRowIndex","resetRowTops","changedPath","clearRowTop","hasChildren","childrenAfterGroup","skipChildren","isActive","expanded","sibling","detailNode","ensureRowsAtPixel","rowNodes","pixel","increment","_this","indexAtPixelNow","rowNodeAtPixelNow","forEach","removeFromArray","allLeafChildren","idx","insertIntoArray","keepEditingRows","highlightRowAtPixel","lastHighlightedRow","setHighlighted","highlight","getHighlightPosition","index","rowTop","getLastHighlightedRowNode","isLastRowFound","getRowCount","getTopLevelRowCount","showingRootNode","childrenAfterFilter","getTopLevelRowDisplayedIndex","topLevelIndex","childrenAfterSort","isGroupHideOpenParents","getRowBounds","isAnimateRows","event","afterDataChange","STEP_FILTER","STEP_SORT","getType","ROW_MODEL_TYPE_CLIENT_SIDE","isPivotActive","STEP_AGGREGATE","createChangePath","rowNodeTransactions","noTransactions","missingOrEmpty","isTreeData","setInactive","params","doRowGrouping","groupState","rowNodeOrder","doFilter","doPivot","doAggregate","doSort","doRowsToDisplay","type","EVENT_MODEL_UPDATED","api","newData","newPage","dispatchEvent","$scope","window","setTimeout","$apply","isEmpty","rowsMissing","doingLegacyTreeData","exists","getNodeChildDetailsFunc","empty","isReady","isRowsToRender","getNodesInRangeForSelection","firstInRange","lastInRange","firstRowHit","lastRowHit","result","groupsSelectChildren","isGroupSelectsChildren","forEachNodeAfterFilterAndSort","lookingForLastRow","skipThisGroupNode","group","inRange","childOfLastRow","isParentOfNode","push","setDatasource","datasource","console","error","getTopLevelNodes","getRootNode","isRowPresent","indexOf","pixelToMatch","bottomPointer","topPointer","lastNode","last","midPointer","floor","currentRowNode","isRowInPixel","topPixel","bottomPixel","pixelInRow","getCurrentPageHeight","lastPixel","forEachLeafNode","callback","forEachNode","recursivelyWalkNodesAndCallback","Normal","forEachNodeAfterFilter","AfterFilter","AfterFilterAndSort","forEachPivotNode","PivotNodes","nodes","recursionType","node","nodeChildren","leafGroup","aggregationStage","execute","expandOrCollapseAll","expand","usingTreeData","recursiveExpandOrCollapse","shouldExpandOrCollapse","eventSource","EVENT_EXPAND_COLLAPSE_ALL","source","sortStage","groupStage","removeGroupsFromSelection","restoreGroupState","updateGroupsFromChildrenSelections","traverseNodesWithKey","filterStage","pivotStage","getGroupState","isRememberGroupStateWhenNewData","getCopyOfNodesMap","getRowNode","id","rowDataChangedEvent","EVENT_ROW_DATA_CHANGED","batchUpdateRowData","rowDataTransaction","rowDataTransactionBatch","waitMillis","getAsyncTransactionWaitMillis","executeBatchUpdateRowData","valueCache","onDataChanged","callbackFuncsBound","rowNodeTrans","tranItem","rowNodeTran","updateRowData","commonUpdateRowData","func","rowDataTran","EVENT_ROW_DATA_UPDATED","flattenStage","onRowHeightChanged","resetRowHeights"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Autowired, Bean, ChangedPath, Constants as constants, Constants, Events, GridOptionsWrapper, Optional, PostConstruct, RowNode, BeanStub, _ } from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\nvar RecursionType;\n(function (RecursionType) {\n    RecursionType[RecursionType[\"Normal\"] = 0] = \"Normal\";\n    RecursionType[RecursionType[\"AfterFilter\"] = 1] = \"AfterFilter\";\n    RecursionType[RecursionType[\"AfterFilterAndSort\"] = 2] = \"AfterFilterAndSort\";\n    RecursionType[RecursionType[\"PivotNodes\"] = 3] = \"PivotNodes\";\n})(RecursionType || (RecursionType = {}));\nvar ClientSideRowModel = /** @class */ (function (_super) {\n    __extends(ClientSideRowModel, _super);\n    function ClientSideRowModel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ClientSideRowModel.prototype.init = function () {\n        var refreshEverythingFunc = this.refreshModel.bind(this, { step: Constants.STEP_EVERYTHING });\n        var refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, { step: Constants.STEP_EVERYTHING, afterColumnsChanged: true, keepRenderedRows: true });\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_EVERYTHING_CHANGED, refreshEverythingAfterColsChangedFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: Constants.STEP_PIVOT }));\n        this.addManagedListener(this.eventService, Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        var refreshMapListener = this.refreshModel.bind(this, {\n            step: Constants.STEP_MAP,\n            keepRenderedRows: true,\n            animate: true\n        });\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_SINGLE_CHILDREN, refreshMapListener);\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_GROUP_REMOVE_LOWEST_SINGLE_CHILDREN, refreshMapListener);\n        this.rootNode = new RowNode();\n        this.nodeManager = new ClientSideNodeManager(this.rootNode, this.gridOptionsWrapper, this.getContext(), this.eventService, this.columnController, this.gridApi, this.columnApi, this.selectionController);\n        this.createBean(this.rootNode);\n    };\n    ClientSideRowModel.prototype.start = function () {\n        var rowData = this.gridOptionsWrapper.getRowData();\n        if (rowData) {\n            this.setRowData(rowData);\n        }\n    };\n    ClientSideRowModel.prototype.ensureRowHeightsValid = function (startPixel, endPixel, startLimitIndex, endLimitIndex) {\n        var atLeastOneChange;\n        var res = false;\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n            var rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            var rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n            // keep check to current page if doing pagination\n            var firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            var lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n            for (var rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                var rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n            if (atLeastOneChange) {\n                this.setRowTops();\n            }\n        } while (atLeastOneChange);\n        return res;\n    };\n    ClientSideRowModel.prototype.setRowTops = function () {\n        var nextRowTop = 0;\n        for (var i = 0; i < this.rowsToDisplay.length; i++) {\n            // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n            // with these two layouts.\n            var allowEstimate = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n            var rowNode = this.rowsToDisplay[i];\n            if (_.missing(rowNode.rowHeight)) {\n                var rowHeight = this.gridOptionsWrapper.getRowHeightForNode(rowNode, allowEstimate);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight;\n        }\n    };\n    ClientSideRowModel.prototype.resetRowTops = function (rowNode, changedPath) {\n        rowNode.clearRowTop();\n        if (rowNode.hasChildren()) {\n            if (rowNode.childrenAfterGroup) {\n                // if a changedPath is active, it means we are here because of a transaction update or\n                // a change detection. neither of these impacts the open/closed state of groups. so if\n                // a group is not open this time, it was not open last time. so we know all closed groups\n                // already have their top positions cleared. so there is no need to traverse all the way\n                // when changedPath is active and the rowNode is not expanded.\n                var skipChildren = changedPath.isActive() && !rowNode.expanded;\n                if (!skipChildren) {\n                    for (var i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                        this.resetRowTops(rowNode.childrenAfterGroup[i], changedPath);\n                    }\n                }\n            }\n            if (rowNode.sibling) {\n                rowNode.sibling.clearRowTop();\n            }\n        }\n        if (rowNode.detailNode) {\n            rowNode.detailNode.clearRowTop();\n        }\n    };\n    // returns false if row was moved, otherwise true\n    ClientSideRowModel.prototype.ensureRowsAtPixel = function (rowNodes, pixel, increment) {\n        var _this = this;\n        if (increment === void 0) { increment = 0; }\n        var indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        var rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n        rowNodes.forEach(function (rowNode) {\n            _.removeFromArray(_this.rootNode.allLeafChildren, rowNode);\n        });\n        rowNodes.forEach(function (rowNode, idx) {\n            _.insertIntoArray(_this.rootNode.allLeafChildren, rowNode, indexAtPixelNow + increment + idx);\n        });\n        this.refreshModel({\n            step: Constants.STEP_EVERYTHING,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        return true;\n    };\n    ClientSideRowModel.prototype.highlightRowAtPixel = function (rowNode, pixel) {\n        var indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        var rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n        var highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    };\n    ClientSideRowModel.prototype.getHighlightPosition = function (pixel, rowNode) {\n        if (!rowNode) {\n            var index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n            if (!rowNode) {\n                return 'below';\n            }\n        }\n        var rowTop = rowNode.rowTop, rowHeight = rowNode.rowHeight;\n        return pixel - rowTop < rowHeight / 2 ? 'above' : 'below';\n    };\n    ClientSideRowModel.prototype.getLastHighlightedRowNode = function () {\n        return this.lastHighlightedRow;\n    };\n    ClientSideRowModel.prototype.isLastRowFound = function () {\n        return true;\n    };\n    ClientSideRowModel.prototype.getRowCount = function () {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n        return 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowCount = function () {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return 1;\n        }\n        return this.rootNode.childrenAfterFilter ? this.rootNode.childrenAfterFilter.length : 0;\n    };\n    ClientSideRowModel.prototype.getTopLevelRowDisplayedIndex = function (topLevelIndex) {\n        var showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n        var rowNode = this.rootNode.childrenAfterSort[topLevelIndex];\n        if (this.gridOptionsWrapper.isGroupHideOpenParents()) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n        return rowNode.rowIndex;\n    };\n    ClientSideRowModel.prototype.getRowBounds = function (index) {\n        if (_.missing(this.rowsToDisplay)) {\n            return null;\n        }\n        var rowNode = this.rowsToDisplay[index];\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop,\n                rowHeight: rowNode.rowHeight\n            };\n        }\n        return null;\n    };\n    ClientSideRowModel.prototype.onRowGroupOpened = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: Constants.STEP_MAP, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onFilterChanged = function (event) {\n        if (event.afterDataChange) {\n            return;\n        }\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: Constants.STEP_FILTER, keepRenderedRows: true, animate: animate });\n    };\n    ClientSideRowModel.prototype.onSortChanged = function () {\n        var animate = this.gridOptionsWrapper.isAnimateRows();\n        this.refreshModel({ step: Constants.STEP_SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.getType = function () {\n        return Constants.ROW_MODEL_TYPE_CLIENT_SIDE;\n    };\n    ClientSideRowModel.prototype.onValueChanged = function () {\n        if (this.columnController.isPivotActive()) {\n            this.refreshModel({ step: Constants.STEP_PIVOT });\n        }\n        else {\n            this.refreshModel({ step: Constants.STEP_AGGREGATE });\n        }\n    };\n    ClientSideRowModel.prototype.createChangePath = function (rowNodeTransactions) {\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n        var noTransactions = _.missingOrEmpty(rowNodeTransactions);\n        var changedPath = new ChangedPath(false, this.rootNode);\n        if (noTransactions || this.gridOptionsWrapper.isTreeData()) {\n            changedPath.setInactive();\n        }\n        return changedPath;\n    };\n    ClientSideRowModel.prototype.refreshModel = function (params) {\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n        var _this = this;\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n        var changedPath = this.createChangePath(params.rowNodeTransactions);\n        switch (params.step) {\n            case constants.STEP_EVERYTHING:\n                // start = new Date().getTime();\n                this.doRowGrouping(params.groupState, params.rowNodeTransactions, params.rowNodeOrder, changedPath, params.afterColumnsChanged);\n            // console.log('rowGrouping = ' + (new Date().getTime() - start));\n            case constants.STEP_FILTER:\n                // start = new Date().getTime();\n                this.doFilter(changedPath);\n            // console.log('filter = ' + (new Date().getTime() - start));\n            case constants.STEP_PIVOT:\n                this.doPivot(changedPath);\n            case constants.STEP_AGGREGATE: // depends on agg fields\n                // start = new Date().getTime();\n                this.doAggregate(changedPath);\n            // console.log('aggregation = ' + (new Date().getTime() - start));\n            case constants.STEP_SORT:\n                // start = new Date().getTime();\n                this.doSort(params.rowNodeTransactions, changedPath);\n            // console.log('sort = ' + (new Date().getTime() - start));\n            case constants.STEP_MAP:\n                // start = new Date().getTime();\n                this.doRowsToDisplay();\n            // console.log('rowsToDisplay = ' + (new Date().getTime() - start));\n        }\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        this.resetRowTops(this.rootNode, changedPath);\n        this.setRowTops();\n        var event = {\n            type: Events.EVENT_MODEL_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false\n        };\n        this.eventService.dispatchEvent(event);\n        if (this.$scope) {\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.isEmpty = function () {\n        var rowsMissing;\n        var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            rowsMissing = _.missing(this.rootNode.childrenAfterGroup) || this.rootNode.childrenAfterGroup.length === 0;\n        }\n        else {\n            rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        }\n        var empty = _.missing(this.rootNode) || rowsMissing || !this.columnController.isReady();\n        return empty;\n    };\n    ClientSideRowModel.prototype.isRowsToRender = function () {\n        return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    };\n    ClientSideRowModel.prototype.getNodesInRangeForSelection = function (firstInRange, lastInRange) {\n        // if lastSelectedNode is missing, we start at the first row\n        var firstRowHit = !lastInRange;\n        var lastRowHit = false;\n        var lastRow;\n        var result = [];\n        var groupsSelectChildren = this.gridOptionsWrapper.isGroupSelectsChildren();\n        this.forEachNodeAfterFilterAndSort(function (rowNode) {\n            var lookingForLastRow = firstRowHit && !lastRowHit;\n            // check if we need to flip the select switch\n            if (!firstRowHit) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    firstRowHit = true;\n                }\n            }\n            var skipThisGroupNode = rowNode.group && groupsSelectChildren;\n            if (!skipThisGroupNode) {\n                var inRange = firstRowHit && !lastRowHit;\n                var childOfLastRow = rowNode.isParentOfNode(lastRow);\n                if (inRange || childOfLastRow) {\n                    result.push(rowNode);\n                }\n            }\n            if (lookingForLastRow) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    lastRowHit = true;\n                    if (rowNode === lastInRange) {\n                        lastRow = lastInRange;\n                    }\n                    else {\n                        lastRow = firstInRange;\n                    }\n                }\n            }\n        });\n        return result;\n    };\n    ClientSideRowModel.prototype.setDatasource = function (datasource) {\n        console.error('ag-Grid: should never call setDatasource on clientSideRowController');\n    };\n    ClientSideRowModel.prototype.getTopLevelNodes = function () {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    };\n    ClientSideRowModel.prototype.getRootNode = function () {\n        return this.rootNode;\n    };\n    ClientSideRowModel.prototype.getRow = function (index) {\n        return this.rowsToDisplay[index];\n    };\n    ClientSideRowModel.prototype.isRowPresent = function (rowNode) {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    };\n    ClientSideRowModel.prototype.getRowIndexAtPixel = function (pixelToMatch) {\n        if (this.isEmpty()) {\n            return -1;\n        }\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        var bottomPointer = 0;\n        var topPointer = this.rowsToDisplay.length - 1;\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        var lastNode = _.last(this.rowsToDisplay);\n        if (lastNode.rowTop <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n        while (true) {\n            var midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            var currentRowNode = this.rowsToDisplay[midPointer];\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n            if (currentRowNode.rowTop < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            }\n            else if (currentRowNode.rowTop > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n        }\n    };\n    ClientSideRowModel.prototype.isRowInPixel = function (rowNode, pixelToMatch) {\n        var topPixel = rowNode.rowTop;\n        var bottomPixel = rowNode.rowTop + rowNode.rowHeight;\n        var pixelInRow = topPixel <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    };\n    ClientSideRowModel.prototype.getCurrentPageHeight = function () {\n        if (this.rowsToDisplay && this.rowsToDisplay.length > 0) {\n            var lastRow = _.last(this.rowsToDisplay);\n            var lastPixel = lastRow.rowTop + lastRow.rowHeight;\n            return lastPixel;\n        }\n        return 0;\n    };\n    ClientSideRowModel.prototype.forEachLeafNode = function (callback) {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach(function (rowNode, index) { return callback(rowNode, index); });\n        }\n    };\n    ClientSideRowModel.prototype.forEachNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterGroup, callback, RecursionType.Normal, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilter = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterFilter, callback, RecursionType.AfterFilter, 0);\n    };\n    ClientSideRowModel.prototype.forEachNodeAfterFilterAndSort = function (callback) {\n        this.recursivelyWalkNodesAndCallback(this.rootNode.childrenAfterSort, callback, RecursionType.AfterFilterAndSort, 0);\n    };\n    ClientSideRowModel.prototype.forEachPivotNode = function (callback) {\n        this.recursivelyWalkNodesAndCallback([this.rootNode], callback, RecursionType.PivotNodes, 0);\n    };\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    ClientSideRowModel.prototype.recursivelyWalkNodesAndCallback = function (nodes, callback, recursionType, index) {\n        if (!nodes) {\n            return index;\n        }\n        for (var i = 0; i < nodes.length; i++) {\n            var node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren()) {\n                // depending on the recursion type, we pick a difference set of children\n                var nodeChildren = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback(nodeChildren, callback, recursionType, index);\n                }\n            }\n        }\n        return index;\n    };\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    ClientSideRowModel.prototype.doAggregate = function (changedPath) {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    ClientSideRowModel.prototype.expandOrCollapseAll = function (expand) {\n        var usingTreeData = this.gridOptionsWrapper.isTreeData();\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n        function recursiveExpandOrCollapse(rowNodes) {\n            if (!rowNodes) {\n                return;\n            }\n            rowNodes.forEach(function (rowNode) {\n                var shouldExpandOrCollapse = usingTreeData ? _.exists(rowNode.childrenAfterGroup) : rowNode.group;\n                if (shouldExpandOrCollapse) {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                }\n            });\n        }\n        this.refreshModel({ step: Constants.STEP_MAP });\n        var eventSource = expand ? 'expandAll' : 'collapseAll';\n        var event = {\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doSort = function (rowNodeTransactions, changedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath\n        });\n    };\n    ClientSideRowModel.prototype.doRowGrouping = function (groupState, rowNodeTransactions, rowNodeOrder, changedPath, afterColumnsChanged) {\n        // grouping is enterprise only, so if service missing, skip the step\n        var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            return;\n        }\n        if (this.groupStage) {\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath\n                });\n            }\n            else {\n                // groups are about to get disposed, so need to deselect any that are selected\n                this.selectionController.removeGroupsFromSelection();\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged\n                });\n                // set open/closed state on groups\n                this.restoreGroupState(groupState);\n            }\n            if (this.gridOptionsWrapper.isGroupSelectsChildren()) {\n                this.selectionController.updateGroupsFromChildrenSelections(changedPath);\n            }\n        }\n        else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n        }\n    };\n    ClientSideRowModel.prototype.restoreGroupState = function (groupState) {\n        if (!groupState) {\n            return;\n        }\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) {\n            // if the group was open last time, then open it this time. however\n            // if was not open last time, then don't touch the group, so the 'groupDefaultExpanded'\n            // setting will take effect.\n            if (typeof groupState[key] === 'boolean') {\n                node.expanded = groupState[key];\n            }\n        });\n    };\n    ClientSideRowModel.prototype.doFilter = function (changedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    };\n    ClientSideRowModel.prototype.doPivot = function (changedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    };\n    ClientSideRowModel.prototype.getGroupState = function () {\n        if (!this.rootNode.childrenAfterGroup || !this.gridOptionsWrapper.isRememberGroupStateWhenNewData()) {\n            return null;\n        }\n        var result = {};\n        _.traverseNodesWithKey(this.rootNode.childrenAfterGroup, function (node, key) { return result[key] = node.expanded; });\n        return result;\n    };\n    ClientSideRowModel.prototype.getCopyOfNodesMap = function () {\n        return this.nodeManager.getCopyOfNodesMap();\n    };\n    ClientSideRowModel.prototype.getRowNode = function (id) {\n        return this.nodeManager.getRowNode(id);\n    };\n    // rows: the rows to put into the model\n    ClientSideRowModel.prototype.setRowData = function (rowData) {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        // remember group state, so we can expand groups that should be expanded\n        var groupState = this.getGroupState();\n        this.nodeManager.setRowData(rowData);\n        // this event kicks off:\n        // - clears selection\n        // - updates filters\n        // - shows 'no rows' overlay if needed\n        var rowDataChangedEvent = {\n            type: Events.EVENT_ROW_DATA_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(rowDataChangedEvent);\n        this.refreshModel({\n            step: Constants.STEP_EVERYTHING,\n            groupState: groupState,\n            newData: true\n        });\n    };\n    ClientSideRowModel.prototype.batchUpdateRowData = function (rowDataTransaction, callback) {\n        var _this = this;\n        if (!this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch = [];\n            var waitMillis = this.gridOptionsWrapper.getAsyncTransactionWaitMillis();\n            window.setTimeout(function () {\n                _this.executeBatchUpdateRowData();\n                _this.rowDataTransactionBatch = null;\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    };\n    ClientSideRowModel.prototype.executeBatchUpdateRowData = function () {\n        var _this = this;\n        this.valueCache.onDataChanged();\n        var callbackFuncsBound = [];\n        var rowNodeTrans = [];\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach(function (tranItem) {\n                var rowNodeTran = _this.nodeManager.updateRowData(tranItem.rowDataTransaction, null);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n            });\n        }\n        this.commonUpdateRowData(rowNodeTrans);\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(function () {\n                callbackFuncsBound.forEach(function (func) { return func(); });\n            }, 0);\n        }\n    };\n    ClientSideRowModel.prototype.updateRowData = function (rowDataTran, rowNodeOrder) {\n        this.valueCache.onDataChanged();\n        var rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder);\n        return rowNodeTran;\n    };\n    // common to updateRowData and batchUpdateRowData\n    ClientSideRowModel.prototype.commonUpdateRowData = function (rowNodeTrans, rowNodeOrder) {\n        this.refreshModel({\n            step: Constants.STEP_EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            animate: true,\n            keepEditingRows: true\n        });\n        var event = {\n            type: Events.EVENT_ROW_DATA_UPDATED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ClientSideRowModel.prototype.doRowsToDisplay = function () {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });\n    };\n    ClientSideRowModel.prototype.onRowHeightChanged = function () {\n        this.refreshModel({ step: Constants.STEP_MAP, keepRenderedRows: true, keepEditingRows: true });\n    };\n    ClientSideRowModel.prototype.resetRowHeights = function () {\n        this.forEachNode(function (rowNode) {\n            rowNode.setRowHeight(null);\n            // forEachNode doesn't go through detail rows, so need to check\n            // for detail nodes explicitly.\n            if (rowNode.detailNode) {\n                rowNode.detailNode.setRowHeight(null);\n            }\n        });\n        this.onRowHeightChanged();\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], ClientSideRowModel.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('columnController')\n    ], ClientSideRowModel.prototype, \"columnController\", void 0);\n    __decorate([\n        Autowired('filterManager')\n    ], ClientSideRowModel.prototype, \"filterManager\", void 0);\n    __decorate([\n        Autowired('$scope')\n    ], ClientSideRowModel.prototype, \"$scope\", void 0);\n    __decorate([\n        Autowired('selectionController')\n    ], ClientSideRowModel.prototype, \"selectionController\", void 0);\n    __decorate([\n        Autowired('valueService')\n    ], ClientSideRowModel.prototype, \"valueService\", void 0);\n    __decorate([\n        Autowired('valueCache')\n    ], ClientSideRowModel.prototype, \"valueCache\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], ClientSideRowModel.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], ClientSideRowModel.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('filterStage')\n    ], ClientSideRowModel.prototype, \"filterStage\", void 0);\n    __decorate([\n        Autowired('sortStage')\n    ], ClientSideRowModel.prototype, \"sortStage\", void 0);\n    __decorate([\n        Autowired('flattenStage')\n    ], ClientSideRowModel.prototype, \"flattenStage\", void 0);\n    __decorate([\n        Optional('groupStage')\n    ], ClientSideRowModel.prototype, \"groupStage\", void 0);\n    __decorate([\n        Optional('aggregationStage')\n    ], ClientSideRowModel.prototype, \"aggregationStage\", void 0);\n    __decorate([\n        Optional('pivotStage')\n    ], ClientSideRowModel.prototype, \"pivotStage\", void 0);\n    __decorate([\n        PostConstruct\n    ], ClientSideRowModel.prototype, \"init\", null);\n    ClientSideRowModel = __decorate([\n        Bean('rowModel')\n    ], ClientSideRowModel);\n    return ClientSideRowModel;\n}(BeanStub));\nexport { ClientSideRowModel };\n"]},"metadata":{},"sourceType":"module"}