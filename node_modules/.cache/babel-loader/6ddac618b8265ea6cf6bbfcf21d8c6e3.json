{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar FUNCTION_STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar FUNCTION_ARGUMENT_NAMES = /([^\\s,]+)/g;\nvar doOnceFlags = {};\n/**\n * If the key was passed before, then doesn't execute the func\n * @param {Function} func\n * @param {string} key\n */\n\nexport function doOnce(func, key) {\n  if (doOnceFlags[key]) {\n    return;\n  }\n\n  func();\n  doOnceFlags[key] = true;\n}\n/** @deprecated */\n\nexport function getFunctionParameters(func) {\n  var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');\n  return fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES) || [];\n}\nexport function isFunction(val) {\n  return !!(val && val.constructor && val.call && val.apply);\n}\nexport function executeInAWhile(funcs) {\n  executeAfter(funcs, 400);\n}\nexport function executeNextVMTurn(funcs) {\n  executeAfter(funcs, 0);\n}\nexport function executeAfter(funcs, milliseconds) {\n  if (milliseconds === void 0) {\n    milliseconds = 0;\n  }\n\n  if (funcs.length > 0) {\n    window.setTimeout(function () {\n      return funcs.forEach(function (func) {\n        return func();\n      });\n    }, milliseconds);\n  }\n}\n/**\n * from https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript\n * @param {Function} func The function to be debounced\n * @param {number} wait The time in ms to debounce\n * @param {boolean} immediate If it should run immediately or wait for the initial debounce delay\n * @return {Function} The debounced function\n */\n\nexport function debounce(func, wait, immediate) {\n  if (immediate === void 0) {\n    immediate = false;\n  } // 'private' variable for instance\n  // The returned function will be able to reference this due to closure.\n  // Each call to the returned function will share this common timer.\n\n\n  var timeout; // Calling debounce returns a new anonymous function\n\n  return function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    } // reference the context and args for the setTimeout function\n\n\n    var context = this; // Should the function be called now? If immediate is true\n    //   and not already in a timeout then the answer is: Yes\n\n    var callNow = immediate && !timeout; // This is the basic debounce behaviour where you can call this\n    //   function several times, but it will only execute once\n    //   [before or after imposing a delay].\n    //   Each time the returned function is called, the timer starts over.\n\n    window.clearTimeout(timeout); // Set the new timeout\n\n    timeout = window.setTimeout(function () {\n      // Inside the timeout function, clear the timeout variable\n      // which will let the next execution run when in 'immediate' mode\n      timeout = null; // Check if the function already ran with the immediate flag\n\n      if (!immediate) {\n        // Call the original function with apply\n        // apply lets you define the 'this' object as well as the arguments\n        //    (both captured before setTimeout)\n        func.apply(context, args);\n      }\n    }, wait); // Immediate mode and no wait timer? Execute the function..\n\n    if (callNow) {\n      func.apply(context, args);\n    }\n  };\n}\nexport function compose() {\n  var fns = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    fns[_i] = arguments[_i];\n  }\n\n  return function (arg) {\n    return fns.reduce(function (composed, f) {\n      return f(composed);\n    }, arg);\n  };\n}\nexport function callIfPresent(func) {\n  if (func) {\n    func();\n  }\n}","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/utils/function.js"],"names":["FUNCTION_STRIP_COMMENTS","FUNCTION_ARGUMENT_NAMES","doOnceFlags","doOnce","func","key","getFunctionParameters","fnStr","toString","replace","slice","indexOf","match","isFunction","val","constructor","call","apply","executeInAWhile","funcs","executeAfter","executeNextVMTurn","milliseconds","length","window","setTimeout","forEach","debounce","wait","immediate","timeout","args","_i","arguments","context","callNow","clearTimeout","compose","fns","arg","reduce","composed","f","callIfPresent"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar FUNCTION_STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar FUNCTION_ARGUMENT_NAMES = /([^\\s,]+)/g;\nvar doOnceFlags = {};\n/**\n * If the key was passed before, then doesn't execute the func\n * @param {Function} func\n * @param {string} key\n */\nexport function doOnce(func, key) {\n    if (doOnceFlags[key]) {\n        return;\n    }\n    func();\n    doOnceFlags[key] = true;\n}\n/** @deprecated */\nexport function getFunctionParameters(func) {\n    var fnStr = func.toString().replace(FUNCTION_STRIP_COMMENTS, '');\n    return fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(FUNCTION_ARGUMENT_NAMES) || [];\n}\nexport function isFunction(val) {\n    return !!(val && val.constructor && val.call && val.apply);\n}\nexport function executeInAWhile(funcs) {\n    executeAfter(funcs, 400);\n}\nexport function executeNextVMTurn(funcs) {\n    executeAfter(funcs, 0);\n}\nexport function executeAfter(funcs, milliseconds) {\n    if (milliseconds === void 0) { milliseconds = 0; }\n    if (funcs.length > 0) {\n        window.setTimeout(function () { return funcs.forEach(function (func) { return func(); }); }, milliseconds);\n    }\n}\n/**\n * from https://stackoverflow.com/questions/24004791/can-someone-explain-the-debounce-function-in-javascript\n * @param {Function} func The function to be debounced\n * @param {number} wait The time in ms to debounce\n * @param {boolean} immediate If it should run immediately or wait for the initial debounce delay\n * @return {Function} The debounced function\n */\nexport function debounce(func, wait, immediate) {\n    if (immediate === void 0) { immediate = false; }\n    // 'private' variable for instance\n    // The returned function will be able to reference this due to closure.\n    // Each call to the returned function will share this common timer.\n    var timeout;\n    // Calling debounce returns a new anonymous function\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // reference the context and args for the setTimeout function\n        var context = this;\n        // Should the function be called now? If immediate is true\n        //   and not already in a timeout then the answer is: Yes\n        var callNow = immediate && !timeout;\n        // This is the basic debounce behaviour where you can call this\n        //   function several times, but it will only execute once\n        //   [before or after imposing a delay].\n        //   Each time the returned function is called, the timer starts over.\n        window.clearTimeout(timeout);\n        // Set the new timeout\n        timeout = window.setTimeout(function () {\n            // Inside the timeout function, clear the timeout variable\n            // which will let the next execution run when in 'immediate' mode\n            timeout = null;\n            // Check if the function already ran with the immediate flag\n            if (!immediate) {\n                // Call the original function with apply\n                // apply lets you define the 'this' object as well as the arguments\n                //    (both captured before setTimeout)\n                func.apply(context, args);\n            }\n        }, wait);\n        // Immediate mode and no wait timer? Execute the function..\n        if (callNow) {\n            func.apply(context, args);\n        }\n    };\n}\nexport function compose() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return function (arg) { return fns.reduce(function (composed, f) { return f(composed); }, arg); };\n}\nexport function callIfPresent(func) {\n    if (func) {\n        func();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}