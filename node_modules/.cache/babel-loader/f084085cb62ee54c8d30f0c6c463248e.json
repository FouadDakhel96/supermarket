{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowComp } from \"./rowComp\";\nimport { Column } from \"../entities/column\";\nimport { Events } from \"../events\";\nimport { Constants } from \"../constants\";\nimport { CellComp } from \"./cellComp\";\nimport { Autowired, Bean, Optional, Qualifier } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { _ } from \"../utils\";\n\nvar RowRenderer =\n/** @class */\nfunction (_super) {\n  __extends(RowRenderer, _super);\n\n  function RowRenderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.destroyFuncsForColumnListeners = []; // map of row ids to row objects. keeps track of which elements\n    // are rendered for which rows in the dom.\n\n    _this.rowCompsByIndex = {};\n    _this.floatingTopRowComps = [];\n    _this.floatingBottomRowComps = []; // we only allow one refresh at a time, otherwise the internal memory structure here\n    // will get messed up. this can happen if the user has a cellRenderer, and inside the\n    // renderer they call an API method that results in another pass of the refresh,\n    // then it will be trying to draw rows in the middle of a refresh.\n\n    _this.refreshInProgress = false;\n    return _this;\n  }\n\n  RowRenderer.prototype.registerGridCore = function (gridCore) {\n    this.gridCore = gridCore;\n  };\n\n  RowRenderer.prototype.getGridCore = function () {\n    return this.gridCore;\n  };\n\n  RowRenderer.prototype.agWire = function (loggerFactory) {\n    this.logger = loggerFactory.create(\"RowRenderer\");\n  };\n\n  RowRenderer.prototype.registerGridComp = function (gridPanel) {\n    this.gridPanel = gridPanel;\n    this.rowContainers = this.gridPanel.getRowContainers();\n    this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n    this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n    this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n    this.registerCellEventListeners();\n    this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n    this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n    this.redrawAfterModelUpdate();\n  }; // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n  // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n  // all active cells.\n\n\n  RowRenderer.prototype.registerCellEventListeners = function () {\n    var _this = this;\n\n    this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, function (event) {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onCellFocused(event);\n      });\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, function (event) {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onFlashCells(event);\n      });\n    });\n    this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n      _this.forEachCellComp(function (cellComp) {\n        return cellComp.onColumnHover();\n      });\n    }); // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n    // then changing the width of the containers will impact left position. eg the center cols all have their\n    // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n    // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n    // in different containers so doesn't impact.\n\n    this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n      if (_this.printLayout) {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.onLeftChanged();\n        });\n      }\n    });\n    var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n\n    if (rangeSelectionEnabled) {\n      this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.onRangeSelectionChanged();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n      this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, function () {\n        _this.forEachCellComp(function (cellComp) {\n          return cellComp.updateRangeBordersIfRangeCount();\n        });\n      });\n    } // add listeners to the grid columns\n\n\n    this.refreshListenersToColumnsForCellComps(); // if the grid columns change, then refresh the listeners again\n\n    this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n    this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n  }; // executes all functions in destroyFuncsForColumnListeners and then clears the list\n\n\n  RowRenderer.prototype.removeGridColumnListeners = function () {\n    this.destroyFuncsForColumnListeners.forEach(function (func) {\n      return func();\n    });\n    this.destroyFuncsForColumnListeners.length = 0;\n  }; // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n  // once instead.\n\n\n  RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n    var _this = this;\n\n    this.removeGridColumnListeners();\n    var cols = this.columnController.getAllGridColumns();\n\n    if (!cols) {\n      return;\n    }\n\n    cols.forEach(function (col) {\n      var forEachCellWithThisCol = function (callback) {\n        _this.forEachCellComp(function (cellComp) {\n          if (cellComp.getColumn() === col) {\n            callback(cellComp);\n          }\n        });\n      };\n\n      var leftChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onLeftChanged();\n        });\n      };\n\n      var widthChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onWidthChanged();\n        });\n      };\n\n      var firstRightPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onFirstRightPinnedChanged();\n        });\n      };\n\n      var lastLeftPinnedChangedListener = function () {\n        forEachCellWithThisCol(function (cellComp) {\n          return cellComp.onLastLeftPinnedChanged();\n        });\n      };\n\n      col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n      col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n      col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n      col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n\n      _this.destroyFuncsForColumnListeners.push(function () {\n        col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n        col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n        col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n        col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n      });\n    });\n  };\n\n  RowRenderer.prototype.onDomLayoutChanged = function () {\n    var printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n    var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows(); // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n    // out using absolute positioning when doing print layout\n\n    var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n    this.printLayout = printLayout;\n    this.embedFullWidthRows = embedFullWidthRows;\n\n    if (destroyRows) {\n      this.redrawAfterModelUpdate();\n    }\n  }; // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n\n\n  RowRenderer.prototype.datasourceChanged = function () {\n    this.firstRenderedRow = 0;\n    this.lastRenderedRow = -1;\n    var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n    this.removeRowComps(rowIndexesToRemove);\n  };\n\n  RowRenderer.prototype.onPageLoaded = function (refreshEvent) {\n    if (_.missing(refreshEvent)) {\n      refreshEvent = {\n        type: Events.EVENT_MODEL_UPDATED,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        animate: false,\n        keepRenderedRows: false,\n        newData: false,\n        newPage: false\n      };\n    }\n\n    this.onModelUpdated(refreshEvent);\n  };\n\n  RowRenderer.prototype.getAllCellsForColumn = function (column) {\n    var eCells = [];\n\n    function callback(key, rowComp) {\n      var eCell = rowComp.getCellForCol(column);\n\n      if (eCell) {\n        eCells.push(eCell);\n      }\n    }\n\n    _.iterateObject(this.rowCompsByIndex, callback);\n\n    _.iterateObject(this.floatingBottomRowComps, callback);\n\n    _.iterateObject(this.floatingTopRowComps, callback);\n\n    return eCells;\n  };\n\n  RowRenderer.prototype.refreshFloatingRowComps = function () {\n    this.refreshFloatingRows(this.floatingTopRowComps, this.pinnedRowModel.getPinnedTopRowData(), this.rowContainers.floatingTopPinnedLeft, this.rowContainers.floatingTopPinnedRight, this.rowContainers.floatingTop, this.rowContainers.floatingTopFullWidth);\n    this.refreshFloatingRows(this.floatingBottomRowComps, this.pinnedRowModel.getPinnedBottomRowData(), this.rowContainers.floatingBottomPinnedLeft, this.rowContainers.floatingBottomPinnedRight, this.rowContainers.floatingBottom, this.rowContainers.floatingBottomFullWidth);\n  };\n\n  RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes, pinnedLeftContainerComp, pinnedRightContainerComp, bodyContainerComp, fullWidthContainerComp) {\n    var _this = this;\n\n    rowComps.forEach(function (row) {\n      row.destroy();\n    });\n    rowComps.length = 0;\n\n    if (rowNodes) {\n      rowNodes.forEach(function (node) {\n        var rowComp = new RowComp(_this.$scope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, node, _this.beans, false, false, _this.printLayout, _this.embedFullWidthRows);\n        rowComp.init();\n        rowComps.push(rowComp);\n      });\n    }\n\n    this.flushContainers(rowComps);\n  };\n\n  RowRenderer.prototype.onPinnedRowDataChanged = function () {\n    // recycling rows in order to ensure cell editing is not cancelled\n    var params = {\n      recycleRows: true\n    };\n    this.redrawAfterModelUpdate(params);\n  };\n\n  RowRenderer.prototype.onModelUpdated = function (refreshEvent) {\n    var params = {\n      recycleRows: refreshEvent.keepRenderedRows,\n      animate: refreshEvent.animate,\n      newData: refreshEvent.newData,\n      newPage: refreshEvent.newPage,\n      // because this is a model updated event (not pinned rows), we\n      // can skip updating the pinned rows. this is needed so that if user\n      // is doing transaction updates, the pinned rows are not getting constantly\n      // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n      onlyBody: true\n    };\n    this.redrawAfterModelUpdate(params);\n  }; // if the row nodes are not rendered, no index is returned\n\n\n  RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n    var result = [];\n\n    if (_.missing(rowNodes)) {\n      return result;\n    }\n\n    _.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {\n      var rowNode = renderedRow.getRowNode();\n\n      if (rowNodes.indexOf(rowNode) >= 0) {\n        result.push(index);\n      }\n    });\n\n    return result;\n  };\n\n  RowRenderer.prototype.redrawRows = function (rowNodes) {\n    if (!rowNodes || rowNodes.length == 0) {\n      return;\n    } // we only need to be worried about rendered rows, as this method is\n    // called to what's rendered. if the row isn't rendered, we don't care\n\n\n    var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes); // remove the rows\n\n    this.removeRowComps(indexesToRemove); // add draw them again\n\n    this.redrawAfterModelUpdate({\n      recycleRows: true\n    });\n  };\n\n  RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n    var focusedCell = params.suppressKeepFocus ? null : this.focusController.getFocusCellToUseAfterRefresh();\n\n    if (_.missing(focusedCell)) {\n      return null;\n    } // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n    // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n    // cell itself, then the cell can be registered as having focus, however it's the text field that\n    // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n    // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n    // the focus is lost from the text field. we do not want this.\n\n\n    var activeElement = document.activeElement;\n    var domData = this.gridOptionsWrapper.getDomData(activeElement, CellComp.DOM_DATA_KEY_CELL_COMP);\n\n    var elementIsNotACellDev = _.missing(domData);\n\n    return elementIsNotACellDev ? null : focusedCell;\n  }; // gets called after changes to the model.\n\n\n  RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    this.getLockOnRefresh();\n    var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n    this.sizeContainerToPageHeight();\n    this.scrollToTopIfNewData(params); // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n    // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n\n    var recycleRows = !this.printLayout && params.recycleRows;\n    var animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n    var rowsToRecycle = this.binRowComps(recycleRows);\n    this.redraw(rowsToRecycle, animate);\n\n    if (!params.onlyBody) {\n      this.refreshFloatingRowComps();\n    }\n\n    this.restoreFocusedCell(focusedCell);\n    this.releaseLockOnRefresh();\n  };\n\n  RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n    var scrollToTop = params.newData || params.newPage;\n    var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n\n    if (scrollToTop && !suppressScrollToTop) {\n      this.gridPanel.scrollToTop();\n    }\n  };\n\n  RowRenderer.prototype.sizeContainerToPageHeight = function () {\n    var containers = [this.rowContainers.body, this.rowContainers.fullWidth, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight];\n\n    if (this.printLayout) {\n      containers.forEach(function (container) {\n        return container.setHeight(null);\n      });\n      return;\n    }\n\n    var containerHeight = this.paginationProxy.getCurrentPageHeight(); // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n    // we still want the scroll to be present, otherwise there would be no way to scroll the header\n    // which might be needed us user wants to access columns\n    // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n    // is no way to remove the filter.\n\n    if (containerHeight === 0) {\n      containerHeight = 1;\n    }\n\n    this.maxDivHeightScaler.setModelHeight(containerHeight);\n    var realHeight = this.maxDivHeightScaler.getUiContainerHeight();\n    containers.forEach(function (container) {\n      return container.setHeight(realHeight);\n    });\n  };\n\n  RowRenderer.prototype.getLockOnRefresh = function () {\n    if (this.refreshInProgress) {\n      throw new Error(\"ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" + \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" + \"this, put the API call into a timeout, eg instead of api.refreshView(), \" + \"call setTimeout(function(){api.refreshView(),0}). To see what part of your code \" + \"that caused the refresh check this stacktrace.\");\n    }\n\n    this.refreshInProgress = true;\n  };\n\n  RowRenderer.prototype.releaseLockOnRefresh = function () {\n    this.refreshInProgress = false;\n  }; // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n  // edited cell).\n\n\n  RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n    if (cellPosition) {\n      this.focusController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n    }\n  };\n\n  RowRenderer.prototype.stopEditing = function (cancel) {\n    if (cancel === void 0) {\n      cancel = false;\n    }\n\n    this.forEachRowComp(function (key, rowComp) {\n      rowComp.stopEditing(cancel);\n    });\n  };\n\n  RowRenderer.prototype.forEachCellComp = function (callback) {\n    this.forEachRowComp(function (key, rowComp) {\n      return rowComp.forEachCellComp(callback);\n    });\n  };\n\n  RowRenderer.prototype.forEachRowComp = function (callback) {\n    _.iterateObject(this.rowCompsByIndex, callback);\n\n    _.iterateObject(this.floatingTopRowComps, callback);\n\n    _.iterateObject(this.floatingBottomRowComps, callback);\n  };\n\n  RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n    var rowComp = this.rowCompsByIndex[rowIndex];\n\n    if (rowComp) {\n      rowComp.addEventListener(eventName, callback);\n    }\n  };\n\n  RowRenderer.prototype.flashCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var flashDelay = params.flashDelay,\n        fadeDelay = params.fadeDelay;\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      return cellComp.flashCell({\n        flashDelay: flashDelay,\n        fadeDelay: fadeDelay\n      });\n    });\n  };\n\n  RowRenderer.prototype.refreshCells = function (params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    var refreshCellParams = {\n      forceRefresh: params.force,\n      newData: false,\n      suppressFlash: params.suppressFlash\n    };\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      return cellComp.refreshCell(refreshCellParams);\n    });\n  };\n\n  RowRenderer.prototype.getCellRendererInstances = function (params) {\n    var res = [];\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      var cellRenderer = cellComp.getCellRenderer();\n\n      if (cellRenderer) {\n        res.push(cellRenderer);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getCellEditorInstances = function (params) {\n    var res = [];\n    this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n      var cellEditor = cellComp.getCellEditor();\n\n      if (cellEditor) {\n        res.push(cellEditor);\n      }\n    });\n    return res;\n  };\n\n  RowRenderer.prototype.getEditingCells = function () {\n    var res = [];\n    this.forEachCellComp(function (cellComp) {\n      if (cellComp.isEditing()) {\n        var cellPosition = cellComp.getCellPosition();\n        res.push(cellPosition);\n      }\n    });\n    return res;\n  }; // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n  // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n\n\n  RowRenderer.prototype.forEachCellCompFiltered = function (rowNodes, columns, callback) {\n    var _this = this;\n\n    var rowIdsMap;\n\n    if (_.exists(rowNodes)) {\n      rowIdsMap = {\n        top: {},\n        bottom: {},\n        normal: {}\n      };\n      rowNodes.forEach(function (rowNode) {\n        if (rowNode.rowPinned === Constants.PINNED_TOP) {\n          rowIdsMap.top[rowNode.id] = true;\n        } else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n          rowIdsMap.bottom[rowNode.id] = true;\n        } else {\n          rowIdsMap.normal[rowNode.id] = true;\n        }\n      });\n    }\n\n    var colIdsMap;\n\n    if (_.exists(columns)) {\n      colIdsMap = {};\n      columns.forEach(function (colKey) {\n        var column = _this.columnController.getGridColumn(colKey);\n\n        if (_.exists(column)) {\n          colIdsMap[column.getId()] = true;\n        }\n      });\n    }\n\n    var processRow = function (rowComp) {\n      var rowNode = rowComp.getRowNode();\n      var id = rowNode.id;\n      var floating = rowNode.rowPinned; // skip this row if it is missing from the provided list\n\n      if (_.exists(rowIdsMap)) {\n        if (floating === Constants.PINNED_BOTTOM) {\n          if (!rowIdsMap.bottom[id]) {\n            return;\n          }\n        } else if (floating === Constants.PINNED_TOP) {\n          if (!rowIdsMap.top[id]) {\n            return;\n          }\n        } else {\n          if (!rowIdsMap.normal[id]) {\n            return;\n          }\n        }\n      }\n\n      rowComp.forEachCellComp(function (cellComp) {\n        var colId = cellComp.getColumn().getId();\n        var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n\n        if (excludeColFromRefresh) {\n          return;\n        }\n\n        callback(cellComp);\n      });\n    };\n\n    _.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n      processRow(rowComp);\n    });\n\n    if (this.floatingTopRowComps) {\n      this.floatingTopRowComps.forEach(processRow);\n    }\n\n    if (this.floatingBottomRowComps) {\n      this.floatingBottomRowComps.forEach(processRow);\n    }\n  };\n\n  RowRenderer.prototype.destroy = function () {\n    var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n    this.removeRowComps(rowIndexesToRemove);\n\n    _super.prototype.destroy.call(this);\n  };\n\n  RowRenderer.prototype.binRowComps = function (recycleRows) {\n    var _this = this;\n\n    var rowsToRecycle = {};\n    var indexesToRemove;\n\n    if (recycleRows) {\n      indexesToRemove = [];\n\n      _.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n        var rowNode = rowComp.getRowNode();\n\n        if (_.exists(rowNode.id)) {\n          rowsToRecycle[rowNode.id] = rowComp;\n          delete _this.rowCompsByIndex[index];\n        } else {\n          indexesToRemove.push(index);\n        }\n      });\n    } else {\n      indexesToRemove = Object.keys(this.rowCompsByIndex);\n    }\n\n    this.removeRowComps(indexesToRemove);\n    return rowsToRecycle;\n  }; // takes array of row indexes\n\n\n  RowRenderer.prototype.removeRowComps = function (rowsToRemove) {\n    var _this = this; // if no fromIndex then set to -1, which will refresh everything\n    // let realFromIndex = -1;\n\n\n    rowsToRemove.forEach(function (indexToRemove) {\n      var renderedRow = _this.rowCompsByIndex[indexToRemove];\n      renderedRow.destroy();\n      delete _this.rowCompsByIndex[indexToRemove];\n    });\n  }; // gets called when rows don't change, but viewport does, so after:\n  // 1) height of grid body changes, ie number of displayed rows has changed\n  // 2) grid scrolled to new position\n  // 3) ensure index visible (which is a scroll)\n\n\n  RowRenderer.prototype.redrawAfterScroll = function () {\n    this.getLockOnRefresh();\n    this.redraw(null, false, true);\n    this.releaseLockOnRefresh();\n  };\n\n  RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n    // for speedy lookup, dump into map\n    var indexesToDrawMap = {};\n    indexesToDraw.forEach(function (index) {\n      return indexesToDrawMap[index] = true;\n    });\n    var existingIndexes = Object.keys(this.rowCompsByIndex);\n    var indexesNotToDraw = existingIndexes.filter(function (index) {\n      return !indexesToDrawMap[index];\n    });\n    this.removeRowComps(indexesNotToDraw);\n  };\n\n  RowRenderer.prototype.calculateIndexesToDraw = function (rowsToRecycle) {\n    var _this = this; // all in all indexes in the viewport\n\n\n    var indexesToDraw = _.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n\n    var checkRowToDraw = function (indexStr, rowComp) {\n      var index = Number(indexStr);\n\n      if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n        if (_this.doNotUnVirtualiseRow(rowComp)) {\n          indexesToDraw.push(index);\n        }\n      }\n    }; // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n\n\n    _.iterateObject(this.rowCompsByIndex, checkRowToDraw); // if we are redrawing due to model update, then old rows are in rowsToRecycle\n\n\n    _.iterateObject(rowsToRecycle, checkRowToDraw);\n\n    indexesToDraw.sort(function (a, b) {\n      return a - b;\n    });\n    return indexesToDraw;\n  };\n\n  RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n    var _this = this;\n\n    if (animate === void 0) {\n      animate = false;\n    }\n\n    if (afterScroll === void 0) {\n      afterScroll = false;\n    }\n\n    this.maxDivHeightScaler.updateOffset();\n    this.workOutFirstAndLastRowsToRender(); // the row can already exist and be in the following:\n    // rowsToRecycle -> if model change, then the index may be different, however row may\n    //                         exist here from previous time (mapped by id).\n    // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n    // this is all the indexes we want, including those that already exist, so this method\n    // will end up going through each index and drawing only if the row doesn't already exist\n\n    var indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n    this.removeRowCompsNotToDraw(indexesToDraw); // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n    // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n\n    if (this.printLayout) {\n      animate = false;\n    } // add in new rows\n\n\n    var nextVmTurnFunctions = [];\n    var rowComps = [];\n    indexesToDraw.forEach(function (rowIndex) {\n      var rowComp = _this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);\n\n      if (_.exists(rowComp)) {\n        rowComps.push(rowComp);\n\n        _.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());\n      }\n    });\n    this.flushContainers(rowComps);\n\n    _.executeNextVMTurn(nextVmTurnFunctions);\n\n    var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n\n    if (useAnimationFrame) {\n      this.beans.taskQueue.addDestroyTask(this.destroyRowComps.bind(this, rowsToRecycle, animate));\n    } else {\n      this.destroyRowComps(rowsToRecycle, animate);\n    }\n\n    this.checkAngularCompile();\n    this.gridPanel.updateRowCount();\n  };\n\n  RowRenderer.prototype.flushContainers = function (rowComps) {\n    _.iterateObject(this.rowContainers, function (key, rowContainerComp) {\n      if (rowContainerComp) {\n        rowContainerComp.flushRowTemplates();\n      }\n    });\n\n    rowComps.forEach(function (rowComp) {\n      return rowComp.afterFlush();\n    });\n  };\n\n  RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n    var pinningLeft = this.columnController.isPinningLeft();\n    var pinningRight = this.columnController.isPinningRight();\n    var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n\n    if (atLeastOneChanged) {\n      this.pinningLeft = pinningLeft;\n      this.pinningRight = pinningRight;\n\n      if (this.embedFullWidthRows) {\n        this.redrawFullWidthEmbeddedRows();\n      }\n    }\n  }; // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n  // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n\n\n  RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n    // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n    // embedded, as what appears in each section depends on whether we are pinned or not\n    var rowsToRemove = [];\n\n    _.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n      if (rowComp.isFullWidth()) {\n        var rowIndex = rowComp.getRowNode().rowIndex;\n        rowsToRemove.push(rowIndex.toString());\n      }\n    });\n\n    this.refreshFloatingRowComps();\n    this.removeRowComps(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.refreshFullWidthRows = function () {\n    var rowsToRemove = [];\n\n    _.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n      if (rowComp.isFullWidth()) {\n        var fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n\n        if (!fullWidthRowsRefreshed) {\n          var rowIndex = rowComp.getRowNode().rowIndex;\n          rowsToRemove.push(rowIndex.toString());\n        }\n      }\n    });\n\n    this.removeRowComps(rowsToRemove);\n    this.redrawAfterScroll();\n  };\n\n  RowRenderer.prototype.createOrUpdateRowComp = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n    var rowNode;\n    var rowComp = this.rowCompsByIndex[rowIndex]; // if no row comp, see if we can get it from the previous rowComps\n\n    if (!rowComp) {\n      rowNode = this.paginationProxy.getRow(rowIndex);\n\n      if (_.exists(rowNode) && _.exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n        rowComp = rowsToRecycle[rowNode.id];\n        rowsToRecycle[rowNode.id] = null;\n      }\n    }\n\n    var creatingNewRowComp = !rowComp;\n\n    if (creatingNewRowComp) {\n      // create a new one\n      if (!rowNode) {\n        rowNode = this.paginationProxy.getRow(rowIndex);\n      }\n\n      if (_.exists(rowNode)) {\n        rowComp = this.createRowComp(rowNode, animate, afterScroll);\n      } else {\n        // this should never happen - if somehow we are trying to create\n        // a row for a rowNode that does not exist.\n        return;\n      }\n    } else {\n      // ensure row comp is in right position in DOM\n      rowComp.ensureDomOrder();\n    }\n\n    if (rowNode) {\n      // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n      // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n      rowNode.alreadyRendered = true;\n    }\n\n    this.rowCompsByIndex[rowIndex] = rowComp;\n    return rowComp;\n  };\n\n  RowRenderer.prototype.destroyRowComps = function (rowCompsMap, animate) {\n    var delayedFuncs = [];\n\n    _.iterateObject(rowCompsMap, function (nodeId, rowComp) {\n      // if row was used, then it's null\n      if (!rowComp) {\n        return;\n      }\n\n      rowComp.destroy(animate);\n\n      _.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());\n    });\n\n    _.executeInAWhile(delayedFuncs);\n  };\n\n  RowRenderer.prototype.checkAngularCompile = function () {\n    var _this = this; // if we are doing angular compiling, then do digest the scope here\n\n\n    if (this.gridOptionsWrapper.isAngularCompileRows()) {\n      // we do it in a timeout, in case we are already in an apply\n      window.setTimeout(function () {\n        _this.$scope.$apply();\n      }, 0);\n    }\n  };\n\n  RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n    var _this = this;\n\n    var newFirst;\n    var newLast;\n\n    if (!this.paginationProxy.isRowsToRender()) {\n      newFirst = 0;\n      newLast = -1; // setting to -1 means nothing in range\n    } else if (this.printLayout) {\n      newFirst = this.paginationProxy.getPageFirstRow();\n      newLast = this.paginationProxy.getPageLastRow();\n    } else {\n      var paginationOffset = this.paginationProxy.getPixelOffset();\n      var maxDivHeightScaler = this.maxDivHeightScaler.getOffset();\n      var bodyVRange = this.gridPanel.getVScrollPosition();\n      var bodyTopPixel = bodyVRange.top;\n      var bodyBottomPixel = bodyVRange.bottom;\n      var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n      var firstPixel = bodyTopPixel + paginationOffset + maxDivHeightScaler - bufferPixels;\n      var lastPixel = bodyBottomPixel + paginationOffset + maxDivHeightScaler + bufferPixels;\n      this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n      var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n      var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n      var pageFirstRow = this.paginationProxy.getPageFirstRow();\n      var pageLastRow = this.paginationProxy.getPageLastRow(); // adjust, in case buffer extended actual size\n\n      if (firstRowIndex < pageFirstRow) {\n        firstRowIndex = pageFirstRow;\n      }\n\n      if (lastRowIndex > pageLastRow) {\n        lastRowIndex = pageLastRow;\n      }\n\n      newFirst = firstRowIndex;\n      newLast = lastRowIndex;\n    } // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n    // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n    // killing the browser, we limit the number of rows. just in case some use case we didn't think\n    // of, we also have a property to not do this operation.\n\n\n    var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n    var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n    var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n\n    if (rowLayoutNormal && !suppressRowCountRestriction) {\n      if (newLast - newFirst > rowBufferMaxSize) {\n        newLast = newFirst + rowBufferMaxSize;\n      }\n    }\n\n    var firstDiffers = newFirst !== this.firstRenderedRow;\n    var lastDiffers = newLast !== this.lastRenderedRow;\n\n    if (firstDiffers || lastDiffers) {\n      this.firstRenderedRow = newFirst;\n      this.lastRenderedRow = newLast;\n      var event_1 = {\n        type: Events.EVENT_VIEWPORT_CHANGED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    } // only dispatch firstDataRendered if we have actually rendered some data\n\n\n    if (this.paginationProxy.isRowsToRender()) {\n      var event_2 = {\n        type: Events.EVENT_FIRST_DATA_RENDERED,\n        firstRow: newFirst,\n        lastRow: newLast,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      }; // added a small delay here because in some scenarios this can be fired\n      // before the grid is actually rendered, causing component creation\n      // on EVENT_FIRST_DATA_RENDERED to fail.\n\n      window.setTimeout(function () {\n        return _this.eventService.dispatchEventOnce(event_2);\n      }, 50);\n    }\n  };\n\n  RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n    // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n    // all the other row models just hard code so the method just returns back false\n    var rowHeightsChanged = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n\n    if (rowHeightsChanged) {\n      // if row heights have changed, we need to resize the containers the rows sit it\n      this.sizeContainerToPageHeight(); // we also need to update heightScaler as this has dependency of row container height\n\n      this.maxDivHeightScaler.updateOffset();\n    }\n  };\n\n  RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n    return this.firstRenderedRow;\n  };\n\n  RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n    return this.lastRenderedRow;\n  }; // check that none of the rows to remove are editing or focused as:\n  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n  //    the edit is reset - so we want to keep it rendered.\n  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n  //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n  //    and then ctrl+c, nothing will happen if cell is removed from dom.\n  // c) if detail record of master detail, as users complained that the context of detail rows\n  //    was getting lost when detail row out of view. eg user expands to show detail row,\n  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n  //    after detail panel is scrolled out of / into view.\n\n\n  RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n    var REMOVE_ROW = false;\n    var KEEP_ROW = true;\n    var rowNode = rowComp.getRowNode();\n    var rowHasFocus = this.focusController.isRowNodeFocused(rowNode);\n    var rowIsEditing = rowComp.isEditing();\n    var rowIsDetail = rowNode.detail;\n    var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail; // if we deffo don't want to keep it,\n\n    if (!mightWantToKeepRow) {\n      return REMOVE_ROW;\n    } // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n    // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n    // the context of the editing in process.\n\n\n    var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n    return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n  };\n\n  RowRenderer.prototype.createRowComp = function (rowNode, animate, afterScroll) {\n    var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame(); // we don't use animations frames for printing, so the user can put the grid into print mode\n    // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n    // (via the animation frames) which is awkward to do from code.\n    // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n    // having animation frames for other times makes the grid look 'jumpy'.\n\n    var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n    var rowComp = new RowComp(this.$scope, this.rowContainers.body, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight, this.rowContainers.fullWidth, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout, this.embedFullWidthRows);\n    rowComp.init();\n    return rowComp;\n  };\n\n  RowRenderer.prototype.getRenderedNodes = function () {\n    var renderedRows = this.rowCompsByIndex;\n    return Object.keys(renderedRows).map(function (key) {\n      return renderedRows[key].getRowNode();\n    });\n  }; // we use index for rows, but column object for columns, as the next column (by index) might not\n  // be visible (header grouping) so it's not reliable, so using the column object instead.\n\n\n  RowRenderer.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n    // we keep searching for a next cell until we find one. this is how the group rows get skipped\n    var nextCell = currentCell;\n    var hitEdgeOfGrid = false;\n\n    while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n      // if the current cell is spanning across multiple columns, we need to move\n      // our current position to be the last cell on the right before finding the\n      // the next target.\n      if (this.gridOptionsWrapper.isEnableRtl()) {\n        if (key === Constants.KEY_LEFT) {\n          nextCell = this.getLastCellOfColSpan(nextCell);\n        }\n      } else if (key === Constants.KEY_RIGHT) {\n        nextCell = this.getLastCellOfColSpan(nextCell);\n      }\n\n      nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell); // eg if going down, and nextCell=undefined, means we are gone past the last row\n\n      hitEdgeOfGrid = _.missing(nextCell);\n    }\n\n    if (hitEdgeOfGrid && event.keyCode === Constants.KEY_UP) {\n      nextCell = {\n        rowIndex: -1,\n        rowPinned: null,\n        column: currentCell.column\n      };\n    } // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n    // we allow this, however if processing 'enter after edit' we don't allow override\n\n\n    if (allowUserOverride) {\n      var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n\n      if (_.exists(userFunc)) {\n        var params = {\n          key: key,\n          previousCellPosition: currentCell,\n          nextCellPosition: nextCell ? nextCell : null,\n          event: event\n        };\n        var userCell = userFunc(params);\n\n        if (_.exists(userCell)) {\n          if (userCell.floating) {\n            _.doOnce(function () {\n              console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextCell = {\n            rowPinned: userCell.rowPinned,\n            rowIndex: userCell.rowIndex,\n            column: userCell.column\n          };\n        } else {\n          nextCell = null;\n        }\n      }\n    } // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n\n\n    if (!nextCell) {\n      return;\n    }\n\n    if (nextCell.rowIndex < 0) {\n      var headerLen = this.beans.headerNavigationService.getHeaderRowCount();\n      this.focusController.focusHeaderPosition({\n        headerRowIndex: headerLen + nextCell.rowIndex,\n        column: currentCell.column\n      });\n      return;\n    } // in case we have col spanning we get the cellComp and use it to\n    // get the position. This was we always focus the first cell inside\n    // the spanning.\n\n\n    this.ensureCellVisible(nextCell); // ensureCellVisible first, to make sure nextCell is rendered\n\n    var cellComp = this.getComponentForCell(nextCell); // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n\n    if (!cellComp) {\n      return;\n    }\n\n    nextCell = cellComp.getCellPosition(); // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n    // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n    // last column in the group, however now it's the first column in the group). if we didn't do\n    // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n    // merged cells.\n\n    this.ensureCellVisible(nextCell);\n    this.focusController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.rowPinned, true);\n\n    if (this.rangeController) {\n      this.rangeController.setRangeToCell(nextCell);\n    }\n  };\n\n  RowRenderer.prototype.isValidNavigateCell = function (cell) {\n    var rowNode = this.rowPositionUtils.getRowNode(cell); // we do not allow focusing on detail rows and full width rows\n\n    if (rowNode.detail || rowNode.isFullWidthCell()) {\n      return false;\n    } // if not a group, then we have a valid row, so quit the search\n\n\n    if (!rowNode.group) {\n      return true;\n    } // full width rows cannot be focused, so if it's a group and using full width rows,\n    // we need to skip over the row\n\n\n    var pivotMode = this.columnController.isPivotMode();\n    var usingFullWidthRows = this.gridOptionsWrapper.isGroupUseEntireRow(pivotMode);\n\n    if (!usingFullWidthRows) {\n      return true;\n    }\n\n    return false;\n  };\n\n  RowRenderer.prototype.getLastCellOfColSpan = function (cell) {\n    var cellComp = this.getComponentForCell(cell);\n\n    if (!cellComp) {\n      return cell;\n    }\n\n    var colSpanningList = cellComp.getColSpanningList();\n\n    if (colSpanningList.length === 1) {\n      return cell;\n    }\n\n    return {\n      rowIndex: cell.rowIndex,\n      column: _.last(colSpanningList),\n      rowPinned: cell.rowPinned\n    };\n  };\n\n  RowRenderer.prototype.ensureCellVisible = function (gridCell) {\n    // this scrolls the row into view\n    if (_.missing(gridCell.rowPinned)) {\n      this.gridPanel.ensureIndexVisible(gridCell.rowIndex);\n    }\n\n    if (!gridCell.column.isPinned()) {\n      this.gridPanel.ensureColumnVisible(gridCell.column);\n    } // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n    // floating cell, the scrolls get out of sync\n\n\n    this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter(); // need to flush frames, to make sure the correct cells are rendered\n\n    this.animationFrameService.flushAllFrames();\n  };\n\n  RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {\n    var cell = this.getComponentForCell(gridCell);\n\n    if (cell) {\n      cell.startRowOrCellEdit(keyPress, charPress);\n    }\n  };\n\n  RowRenderer.prototype.getComponentForCell = function (cellPosition) {\n    var rowComponent;\n\n    switch (cellPosition.rowPinned) {\n      case Constants.PINNED_TOP:\n        rowComponent = this.floatingTopRowComps[cellPosition.rowIndex];\n        break;\n\n      case Constants.PINNED_BOTTOM:\n        rowComponent = this.floatingBottomRowComps[cellPosition.rowIndex];\n        break;\n\n      default:\n        rowComponent = this.rowCompsByIndex[cellPosition.rowIndex];\n        break;\n    }\n\n    if (!rowComponent) {\n      return null;\n    }\n\n    var cellComponent = rowComponent.getRenderedCellForColumn(cellPosition.column);\n    return cellComponent;\n  };\n\n  RowRenderer.prototype.getRowNode = function (gridRow) {\n    switch (gridRow.rowPinned) {\n      case Constants.PINNED_TOP:\n        return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n\n      case Constants.PINNED_BOTTOM:\n        return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n\n      default:\n        return this.rowModel.getRow(gridRow.rowIndex);\n    }\n  };\n\n  RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {\n    var backwards = keyboardEvent.shiftKey;\n    var success = this.moveToCellAfter(previousRenderedCell, backwards);\n\n    if (success) {\n      keyboardEvent.preventDefault();\n    } else if (keyboardEvent.shiftKey) {\n      var cellPosition = previousRenderedCell.getCellPosition();\n\n      if (cellPosition.rowIndex === 0) {\n        keyboardEvent.preventDefault();\n        this.focusController.focusHeaderPosition({\n          headerRowIndex: this.beans.headerNavigationService.getHeaderRowCount() - 1,\n          column: _.last(this.columnController.getAllDisplayedColumns())\n        });\n      }\n    }\n  };\n\n  RowRenderer.prototype.tabToNextCell = function (backwards) {\n    var focusedCell = this.focusController.getFocusedCell(); // if no focus, then cannot navigate\n\n    if (_.missing(focusedCell)) {\n      return false;\n    }\n\n    var renderedCell = this.getComponentForCell(focusedCell); // if cell is not rendered, means user has scrolled away from the cell\n\n    if (_.missing(renderedCell)) {\n      return false;\n    }\n\n    var result = this.moveToCellAfter(renderedCell, backwards);\n    return result;\n  };\n\n  RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {\n    var editing = previousRenderedCell.isEditing();\n    var res;\n\n    if (editing) {\n      if (this.gridOptionsWrapper.isFullRowEdit()) {\n        res = this.moveToNextEditingRow(previousRenderedCell, backwards);\n      } else {\n        res = this.moveToNextEditingCell(previousRenderedCell, backwards);\n      }\n    } else {\n      res = this.moveToNextCellNotEditing(previousRenderedCell, backwards);\n    }\n\n    return res;\n  };\n\n  RowRenderer.prototype.moveToNextEditingCell = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // need to do this before getting next cell to edit, in case the next cell\n    // has editable function (eg colDef.editable=func() ) and it depends on the\n    // result of this cell, so need to save updates from the first edit, in case\n    // the value is referenced in the function.\n\n    previousRenderedCell.stopEditing(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n    var foundCell = _.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      nextRenderedCell.startEditingIfEnabled(null, null, true);\n      nextRenderedCell.focusCell(false);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveToNextEditingRow = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n\n    var foundCell = _.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveToNextCellNotEditing = function (previousRenderedCell, backwards) {\n    var gridCell = previousRenderedCell.getCellPosition(); // find the next cell to start editing\n\n    var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n\n    var foundCell = _.exists(nextRenderedCell); // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n    // to the normal tabbing so user can exit the grid.\n\n\n    if (foundCell) {\n      nextRenderedCell.focusCell(true);\n    }\n\n    return foundCell;\n  };\n\n  RowRenderer.prototype.moveEditToNextCellOrRow = function (previousRenderedCell, nextRenderedCell) {\n    var pGridCell = previousRenderedCell.getCellPosition();\n    var nGridCell = nextRenderedCell.getCellPosition();\n    var rowsMatch = pGridCell.rowIndex === nGridCell.rowIndex && pGridCell.rowPinned === nGridCell.rowPinned;\n\n    if (rowsMatch) {\n      // same row, so we don't start / stop editing, we just move the focus along\n      previousRenderedCell.setFocusOutOnEditor();\n      nextRenderedCell.setFocusInOnEditor();\n    } else {\n      var pRow = previousRenderedCell.getRenderedRow();\n      var nRow = nextRenderedCell.getRenderedRow();\n      previousRenderedCell.setFocusOutOnEditor();\n      pRow.stopEditing();\n      nRow.startRowEditing();\n      nextRenderedCell.setFocusInOnEditor();\n    }\n\n    nextRenderedCell.focusCell();\n  }; // called by the cell, when tab is pressed while editing.\n  // @return: RenderedCell when navigation successful, otherwise null\n\n\n  RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {\n    var nextCell = gridCell;\n\n    while (true) {\n      if (!backwards) {\n        nextCell = this.getLastCellOfColSpan(nextCell);\n      }\n\n      nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards); // allow user to override what cell to go to next\n\n      var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n\n      if (_.exists(userFunc)) {\n        var params = {\n          backwards: backwards,\n          editing: startEditing,\n          previousCellPosition: gridCell,\n          nextCellPosition: nextCell ? nextCell : null\n        };\n        var userCell = userFunc(params);\n\n        if (_.exists(userCell)) {\n          if (userCell.floating) {\n            _.doOnce(function () {\n              console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\");\n            }, 'no floating in userCell');\n\n            userCell.rowPinned = userCell.floating;\n          }\n\n          nextCell = {\n            rowIndex: userCell.rowIndex,\n            column: userCell.column,\n            rowPinned: userCell.rowPinned\n          };\n        } else {\n          nextCell = null;\n        }\n      } // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n      // so bottom right cell going forwards, or top left going backwards\n\n\n      if (!nextCell) {\n        return null;\n      } // if editing, but cell not editable, skip cell. we do this before we do all of\n      // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n      // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n      // (except for the last one) which causes grid to stall for a while.\n\n\n      if (startEditing) {\n        var rowNode = this.lookupRowNodeForCell(nextCell);\n        var cellIsEditable = nextCell.column.isCellEditable(rowNode);\n\n        if (!cellIsEditable) {\n          continue;\n        }\n      } // this scrolls the row into view\n\n\n      var cellIsNotFloating = _.missing(nextCell.rowPinned);\n\n      if (cellIsNotFloating) {\n        this.gridPanel.ensureIndexVisible(nextCell.rowIndex);\n      } // pinned columns don't scroll, so no need to ensure index visible\n\n\n      if (!nextCell.column.isPinned()) {\n        this.gridPanel.ensureColumnVisible(nextCell.column);\n      } // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n      // floating cell, the scrolls get out of sync\n\n\n      this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter(); // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp\n      // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.\n\n      this.animationFrameService.flushAllFrames(); // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n      // or row that is not currently in view, hence the renderedCell would not exist\n\n      var nextCellComp = this.getComponentForCell(nextCell); // if next cell is fullWidth row, then no rendered cell,\n      // as fullWidth rows have no cells, so we skip it\n\n      if (_.missing(nextCellComp)) {\n        continue;\n      }\n\n      if (nextCellComp.isSuppressNavigable()) {\n        continue;\n      } // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n      // consistent, we set into range here also.\n\n\n      if (this.rangeController) {\n        this.rangeController.setRangeToCell(nextCell);\n      } // we successfully tabbed onto a grid cell, so return true\n\n\n      return nextCellComp;\n    }\n  };\n\n  RowRenderer.prototype.lookupRowNodeForCell = function (cell) {\n    if (cell.rowPinned === Constants.PINNED_TOP) {\n      return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n    }\n\n    if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n      return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n    }\n\n    return this.paginationProxy.getRow(cell.rowIndex);\n  };\n\n  __decorate([Autowired(\"paginationProxy\")], RowRenderer.prototype, \"paginationProxy\", void 0);\n\n  __decorate([Autowired(\"columnController\")], RowRenderer.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired(\"gridOptionsWrapper\")], RowRenderer.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired(\"$scope\")], RowRenderer.prototype, \"$scope\", void 0);\n\n  __decorate([Autowired(\"pinnedRowModel\")], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n\n  __decorate([Autowired(\"rowModel\")], RowRenderer.prototype, \"rowModel\", void 0);\n\n  __decorate([Autowired(\"loggerFactory\")], RowRenderer.prototype, \"loggerFactory\", void 0);\n\n  __decorate([Autowired(\"focusController\")], RowRenderer.prototype, \"focusController\", void 0);\n\n  __decorate([Autowired(\"cellNavigationService\")], RowRenderer.prototype, \"cellNavigationService\", void 0);\n\n  __decorate([Autowired(\"columnApi\")], RowRenderer.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired(\"gridApi\")], RowRenderer.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired(\"beans\")], RowRenderer.prototype, \"beans\", void 0);\n\n  __decorate([Autowired(\"maxDivHeightScaler\")], RowRenderer.prototype, \"maxDivHeightScaler\", void 0);\n\n  __decorate([Autowired(\"animationFrameService\")], RowRenderer.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired(\"rowPositionUtils\")], RowRenderer.prototype, \"rowPositionUtils\", void 0);\n\n  __decorate([Optional(\"rangeController\")], RowRenderer.prototype, \"rangeController\", void 0);\n\n  __decorate([__param(0, Qualifier(\"loggerFactory\"))], RowRenderer.prototype, \"agWire\", null);\n\n  RowRenderer = __decorate([Bean(\"rowRenderer\")], RowRenderer);\n  return RowRenderer;\n}(BeanStub);\n\nexport { RowRenderer };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/rendering/rowRenderer.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","GridOptionsWrapper","RowComp","Column","Events","Constants","CellComp","Autowired","Bean","Optional","Qualifier","BeanStub","_","RowRenderer","_super","_this","apply","destroyFuncsForColumnListeners","rowCompsByIndex","floatingTopRowComps","floatingBottomRowComps","refreshInProgress","registerGridCore","gridCore","getGridCore","agWire","loggerFactory","logger","registerGridComp","gridPanel","rowContainers","getRowContainers","addManagedListener","eventService","EVENT_PAGINATION_CHANGED","onPageLoaded","bind","EVENT_PINNED_ROW_DATA_CHANGED","onPinnedRowDataChanged","EVENT_DISPLAYED_COLUMNS_CHANGED","onDisplayedColumnsChanged","EVENT_BODY_SCROLL","redrawAfterScroll","EVENT_BODY_HEIGHT_CHANGED","gridOptionsWrapper","PROP_DOM_LAYOUT","onDomLayoutChanged","registerCellEventListeners","printLayout","getDomLayout","DOM_LAYOUT_PRINT","embedFullWidthRows","isEmbedFullWidthRows","redrawAfterModelUpdate","EVENT_CELL_FOCUSED","event","forEachCellComp","cellComp","onCellFocused","EVENT_FLASH_CELLS","onFlashCells","EVENT_COLUMN_HOVER_CHANGED","onColumnHover","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","onLeftChanged","rangeSelectionEnabled","isEnableRangeSelection","EVENT_RANGE_SELECTION_CHANGED","onRangeSelectionChanged","EVENT_COLUMN_MOVED","updateRangeBordersIfRangeCount","EVENT_COLUMN_PINNED","EVENT_COLUMN_VISIBLE","refreshListenersToColumnsForCellComps","EVENT_GRID_COLUMNS_CHANGED","addDestroyFunc","removeGridColumnListeners","forEach","func","cols","columnController","getAllGridColumns","col","forEachCellWithThisCol","callback","getColumn","leftChangedListener","widthChangedListener","onWidthChanged","firstRightPinnedChangedListener","onFirstRightPinnedChanged","lastLeftPinnedChangedListener","onLastLeftPinnedChanged","addEventListener","EVENT_LEFT_CHANGED","EVENT_WIDTH_CHANGED","EVENT_FIRST_RIGHT_PINNED_CHANGED","EVENT_LAST_LEFT_PINNED_CHANGED","push","removeEventListener","destroyRows","datasourceChanged","firstRenderedRow","lastRenderedRow","rowIndexesToRemove","keys","removeRowComps","refreshEvent","missing","type","EVENT_MODEL_UPDATED","api","gridApi","columnApi","animate","keepRenderedRows","newData","newPage","onModelUpdated","getAllCellsForColumn","column","eCells","rowComp","eCell","getCellForCol","iterateObject","refreshFloatingRowComps","refreshFloatingRows","pinnedRowModel","getPinnedTopRowData","floatingTopPinnedLeft","floatingTopPinnedRight","floatingTop","floatingTopFullWidth","getPinnedBottomRowData","floatingBottomPinnedLeft","floatingBottomPinnedRight","floatingBottom","floatingBottomFullWidth","rowComps","rowNodes","pinnedLeftContainerComp","pinnedRightContainerComp","bodyContainerComp","fullWidthContainerComp","row","destroy","node","$scope","beans","init","flushContainers","params","recycleRows","onlyBody","getRenderedIndexesForRowNodes","result","index","renderedRow","rowNode","getRowNode","indexOf","redrawRows","indexesToRemove","getCellToRestoreFocusToAfterRefresh","focusedCell","suppressKeepFocus","focusController","getFocusCellToUseAfterRefresh","activeElement","document","domData","getDomData","DOM_DATA_KEY_CELL_COMP","elementIsNotACellDev","getLockOnRefresh","sizeContainerToPageHeight","scrollToTopIfNewData","isAnimateRows","rowsToRecycle","binRowComps","redraw","restoreFocusedCell","releaseLockOnRefresh","scrollToTop","suppressScrollToTop","isSuppressScrollOnNewData","containers","body","fullWidth","pinnedLeft","pinnedRight","container","setHeight","containerHeight","paginationProxy","getCurrentPageHeight","maxDivHeightScaler","setModelHeight","realHeight","getUiContainerHeight","Error","cellPosition","setFocusedCell","rowIndex","rowPinned","stopEditing","cancel","forEachRowComp","addRenderedRowListener","eventName","flashCells","flashDelay","fadeDelay","forEachCellCompFiltered","columns","flashCell","refreshCells","refreshCellParams","forceRefresh","force","suppressFlash","refreshCell","getCellRendererInstances","res","cellRenderer","getCellRenderer","getCellEditorInstances","cellEditor","getCellEditor","getEditingCells","isEditing","getCellPosition","rowIdsMap","exists","top","bottom","normal","PINNED_TOP","id","PINNED_BOTTOM","colIdsMap","colKey","getGridColumn","getId","processRow","floating","colId","excludeColFromRefresh","call","rowsToRemove","indexToRemove","removeRowCompsNotToDraw","indexesToDraw","indexesToDrawMap","existingIndexes","indexesNotToDraw","filter","calculateIndexesToDraw","createArrayOfNumbers","checkRowToDraw","indexStr","Number","doNotUnVirtualiseRow","sort","a","afterScroll","updateOffset","workOutFirstAndLastRowsToRender","nextVmTurnFunctions","createOrUpdateRowComp","pushAll","getAndClearNextVMTurnFunctions","executeNextVMTurn","useAnimationFrame","isSuppressAnimationFrame","taskQueue","addDestroyTask","destroyRowComps","checkAngularCompile","updateRowCount","rowContainerComp","flushRowTemplates","afterFlush","pinningLeft","isPinningLeft","pinningRight","isPinningRight","atLeastOneChanged","redrawFullWidthEmbeddedRows","isFullWidth","toString","refreshFullWidthRows","fullWidthRowsRefreshed","refreshFullWidth","getRow","alreadyRendered","creatingNewRowComp","createRowComp","ensureDomOrder","rowCompsMap","delayedFuncs","nodeId","getAndClearDelayedDestroyFunctions","executeInAWhile","isAngularCompileRows","window","setTimeout","$apply","newFirst","newLast","isRowsToRender","getPageFirstRow","getPageLastRow","paginationOffset","getPixelOffset","getOffset","bodyVRange","getVScrollPosition","bodyTopPixel","bodyBottomPixel","bufferPixels","getRowBufferInPixels","firstPixel","lastPixel","ensureAllRowsInRangeHaveHeightsCalculated","firstRowIndex","getRowIndexAtPixel","lastRowIndex","pageFirstRow","pageLastRow","rowLayoutNormal","DOM_LAYOUT_NORMAL","suppressRowCountRestriction","isSuppressMaxRenderedRowRestriction","rowBufferMaxSize","Math","max","getRowBuffer","firstDiffers","lastDiffers","event_1","EVENT_VIEWPORT_CHANGED","firstRow","lastRow","dispatchEvent","event_2","EVENT_FIRST_DATA_RENDERED","dispatchEventOnce","topPixel","bottomPixel","rowHeightsChanged","ensureRowHeightsValid","getFirstVirtualRenderedRow","getLastVirtualRenderedRow","REMOVE_ROW","KEEP_ROW","rowHasFocus","isRowNodeFocused","rowIsEditing","rowIsDetail","detail","mightWantToKeepRow","rowNodePresent","isRowPresent","suppressAnimationFrame","useAnimationFrameForCreate","getRenderedNodes","renderedRows","map","navigateToNextCell","currentCell","allowUserOverride","nextCell","hitEdgeOfGrid","isValidNavigateCell","isEnableRtl","KEY_LEFT","getLastCellOfColSpan","KEY_RIGHT","cellNavigationService","getNextCellToFocus","keyCode","KEY_UP","userFunc","getNavigateToNextCellFunc","previousCellPosition","nextCellPosition","userCell","doOnce","console","warn","headerLen","headerNavigationService","getHeaderRowCount","focusHeaderPosition","headerRowIndex","ensureCellVisible","getComponentForCell","rangeController","setRangeToCell","cell","rowPositionUtils","isFullWidthCell","group","pivotMode","isPivotMode","usingFullWidthRows","isGroupUseEntireRow","colSpanningList","getColSpanningList","last","gridCell","ensureIndexVisible","isPinned","ensureColumnVisible","horizontallyScrollHeaderCenterAndFloatingCenter","animationFrameService","flushAllFrames","startEditingCell","keyPress","charPress","startRowOrCellEdit","rowComponent","cellComponent","getRenderedCellForColumn","gridRow","rowModel","onTabKeyDown","previousRenderedCell","keyboardEvent","backwards","shiftKey","success","moveToCellAfter","preventDefault","getAllDisplayedColumns","tabToNextCell","getFocusedCell","renderedCell","editing","isFullRowEdit","moveToNextEditingRow","moveToNextEditingCell","moveToNextCellNotEditing","nextRenderedCell","findNextCellToFocusOn","foundCell","startEditingIfEnabled","focusCell","moveEditToNextCellOrRow","pGridCell","nGridCell","rowsMatch","setFocusOutOnEditor","setFocusInOnEditor","pRow","getRenderedRow","nRow","startRowEditing","startEditing","getNextTabbedCell","getTabToNextCellFunc","lookupRowNodeForCell","cellIsEditable","isCellEditable","cellIsNotFloating","nextCellComp","isSuppressNavigable","getPinnedTopRow","getPinnedBottomRow"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { GridOptionsWrapper } from \"../gridOptionsWrapper\";\nimport { RowComp } from \"./rowComp\";\nimport { Column } from \"../entities/column\";\nimport { Events } from \"../events\";\nimport { Constants } from \"../constants\";\nimport { CellComp } from \"./cellComp\";\nimport { Autowired, Bean, Optional, Qualifier } from \"../context/context\";\nimport { BeanStub } from \"../context/beanStub\";\nimport { _ } from \"../utils\";\nvar RowRenderer = /** @class */ (function (_super) {\n    __extends(RowRenderer, _super);\n    function RowRenderer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.destroyFuncsForColumnListeners = [];\n        // map of row ids to row objects. keeps track of which elements\n        // are rendered for which rows in the dom.\n        _this.rowCompsByIndex = {};\n        _this.floatingTopRowComps = [];\n        _this.floatingBottomRowComps = [];\n        // we only allow one refresh at a time, otherwise the internal memory structure here\n        // will get messed up. this can happen if the user has a cellRenderer, and inside the\n        // renderer they call an API method that results in another pass of the refresh,\n        // then it will be trying to draw rows in the middle of a refresh.\n        _this.refreshInProgress = false;\n        return _this;\n    }\n    RowRenderer.prototype.registerGridCore = function (gridCore) {\n        this.gridCore = gridCore;\n    };\n    RowRenderer.prototype.getGridCore = function () {\n        return this.gridCore;\n    };\n    RowRenderer.prototype.agWire = function (loggerFactory) {\n        this.logger = loggerFactory.create(\"RowRenderer\");\n    };\n    RowRenderer.prototype.registerGridComp = function (gridPanel) {\n        this.gridPanel = gridPanel;\n        this.rowContainers = this.gridPanel.getRowContainers();\n        this.addManagedListener(this.eventService, Events.EVENT_PAGINATION_CHANGED, this.onPageLoaded.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_PINNED_ROW_DATA_CHANGED, this.onPinnedRowDataChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_CHANGED, this.onDisplayedColumnsChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_SCROLL, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_BODY_HEIGHT_CHANGED, this.redrawAfterScroll.bind(this));\n        this.addManagedListener(this.gridOptionsWrapper, GridOptionsWrapper.PROP_DOM_LAYOUT, this.onDomLayoutChanged.bind(this));\n        this.registerCellEventListeners();\n        this.printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        this.embedFullWidthRows = this.printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        this.redrawAfterModelUpdate();\n    };\n    // in a clean design, each cell would register for each of these events. however when scrolling, all the cells\n    // registering and de-registering for events is a performance bottleneck. so we register here once and inform\n    // all active cells.\n    RowRenderer.prototype.registerCellEventListeners = function () {\n        var _this = this;\n        this.addManagedListener(this.eventService, Events.EVENT_CELL_FOCUSED, function (event) {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onCellFocused(event); });\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_FLASH_CELLS, function (event) {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onFlashCells(event); });\n        });\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_HOVER_CHANGED, function () {\n            _this.forEachCellComp(function (cellComp) { return cellComp.onColumnHover(); });\n        });\n        // only for printLayout - because we are rendering all the cells in the same row, regardless of pinned state,\n        // then changing the width of the containers will impact left position. eg the center cols all have their\n        // left position adjusted by the width of the left pinned column, so if the pinned left column width changes,\n        // all the center cols need to be shifted to accommodate this. when in normal layout, the pinned cols are\n        // in different containers so doesn't impact.\n        this.addManagedListener(this.eventService, Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED, function () {\n            if (_this.printLayout) {\n                _this.forEachCellComp(function (cellComp) { return cellComp.onLeftChanged(); });\n            }\n        });\n        var rangeSelectionEnabled = this.gridOptionsWrapper.isEnableRangeSelection();\n        if (rangeSelectionEnabled) {\n            this.addManagedListener(this.eventService, Events.EVENT_RANGE_SELECTION_CHANGED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.onRangeSelectionChanged(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_MOVED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PINNED, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VISIBLE, function () {\n                _this.forEachCellComp(function (cellComp) { return cellComp.updateRangeBordersIfRangeCount(); });\n            });\n        }\n        // add listeners to the grid columns\n        this.refreshListenersToColumnsForCellComps();\n        // if the grid columns change, then refresh the listeners again\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_COLUMNS_CHANGED, this.refreshListenersToColumnsForCellComps.bind(this));\n        this.addDestroyFunc(this.removeGridColumnListeners.bind(this));\n    };\n    // executes all functions in destroyFuncsForColumnListeners and then clears the list\n    RowRenderer.prototype.removeGridColumnListeners = function () {\n        this.destroyFuncsForColumnListeners.forEach(function (func) { return func(); });\n        this.destroyFuncsForColumnListeners.length = 0;\n    };\n    // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.\n    // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to\n    // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here\n    // once instead.\n    RowRenderer.prototype.refreshListenersToColumnsForCellComps = function () {\n        var _this = this;\n        this.removeGridColumnListeners();\n        var cols = this.columnController.getAllGridColumns();\n        if (!cols) {\n            return;\n        }\n        cols.forEach(function (col) {\n            var forEachCellWithThisCol = function (callback) {\n                _this.forEachCellComp(function (cellComp) {\n                    if (cellComp.getColumn() === col) {\n                        callback(cellComp);\n                    }\n                });\n            };\n            var leftChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onLeftChanged(); });\n            };\n            var widthChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onWidthChanged(); });\n            };\n            var firstRightPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onFirstRightPinnedChanged(); });\n            };\n            var lastLeftPinnedChangedListener = function () {\n                forEachCellWithThisCol(function (cellComp) { return cellComp.onLastLeftPinnedChanged(); });\n            };\n            col.addEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n            col.addEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n            col.addEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n            col.addEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            _this.destroyFuncsForColumnListeners.push(function () {\n                col.removeEventListener(Column.EVENT_LEFT_CHANGED, leftChangedListener);\n                col.removeEventListener(Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n                col.removeEventListener(Column.EVENT_FIRST_RIGHT_PINNED_CHANGED, firstRightPinnedChangedListener);\n                col.removeEventListener(Column.EVENT_LAST_LEFT_PINNED_CHANGED, lastLeftPinnedChangedListener);\n            });\n        });\n    };\n    RowRenderer.prototype.onDomLayoutChanged = function () {\n        var printLayout = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_PRINT;\n        var embedFullWidthRows = printLayout || this.gridOptionsWrapper.isEmbedFullWidthRows();\n        // if moving towards or away from print layout, means we need to destroy all rows, as rows are not laid\n        // out using absolute positioning when doing print layout\n        var destroyRows = embedFullWidthRows !== this.embedFullWidthRows || this.printLayout !== printLayout;\n        this.printLayout = printLayout;\n        this.embedFullWidthRows = embedFullWidthRows;\n        if (destroyRows) {\n            this.redrawAfterModelUpdate();\n        }\n    };\n    // for row models that have datasources, when we update the datasource, we need to force the rowRenderer\n    // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.\n    RowRenderer.prototype.datasourceChanged = function () {\n        this.firstRenderedRow = 0;\n        this.lastRenderedRow = -1;\n        var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n    };\n    RowRenderer.prototype.onPageLoaded = function (refreshEvent) {\n        if (_.missing(refreshEvent)) {\n            refreshEvent = {\n                type: Events.EVENT_MODEL_UPDATED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                animate: false,\n                keepRenderedRows: false,\n                newData: false,\n                newPage: false\n            };\n        }\n        this.onModelUpdated(refreshEvent);\n    };\n    RowRenderer.prototype.getAllCellsForColumn = function (column) {\n        var eCells = [];\n        function callback(key, rowComp) {\n            var eCell = rowComp.getCellForCol(column);\n            if (eCell) {\n                eCells.push(eCell);\n            }\n        }\n        _.iterateObject(this.rowCompsByIndex, callback);\n        _.iterateObject(this.floatingBottomRowComps, callback);\n        _.iterateObject(this.floatingTopRowComps, callback);\n        return eCells;\n    };\n    RowRenderer.prototype.refreshFloatingRowComps = function () {\n        this.refreshFloatingRows(this.floatingTopRowComps, this.pinnedRowModel.getPinnedTopRowData(), this.rowContainers.floatingTopPinnedLeft, this.rowContainers.floatingTopPinnedRight, this.rowContainers.floatingTop, this.rowContainers.floatingTopFullWidth);\n        this.refreshFloatingRows(this.floatingBottomRowComps, this.pinnedRowModel.getPinnedBottomRowData(), this.rowContainers.floatingBottomPinnedLeft, this.rowContainers.floatingBottomPinnedRight, this.rowContainers.floatingBottom, this.rowContainers.floatingBottomFullWidth);\n    };\n    RowRenderer.prototype.refreshFloatingRows = function (rowComps, rowNodes, pinnedLeftContainerComp, pinnedRightContainerComp, bodyContainerComp, fullWidthContainerComp) {\n        var _this = this;\n        rowComps.forEach(function (row) {\n            row.destroy();\n        });\n        rowComps.length = 0;\n        if (rowNodes) {\n            rowNodes.forEach(function (node) {\n                var rowComp = new RowComp(_this.$scope, bodyContainerComp, pinnedLeftContainerComp, pinnedRightContainerComp, fullWidthContainerComp, node, _this.beans, false, false, _this.printLayout, _this.embedFullWidthRows);\n                rowComp.init();\n                rowComps.push(rowComp);\n            });\n        }\n        this.flushContainers(rowComps);\n    };\n    RowRenderer.prototype.onPinnedRowDataChanged = function () {\n        // recycling rows in order to ensure cell editing is not cancelled\n        var params = {\n            recycleRows: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    RowRenderer.prototype.onModelUpdated = function (refreshEvent) {\n        var params = {\n            recycleRows: refreshEvent.keepRenderedRows,\n            animate: refreshEvent.animate,\n            newData: refreshEvent.newData,\n            newPage: refreshEvent.newPage,\n            // because this is a model updated event (not pinned rows), we\n            // can skip updating the pinned rows. this is needed so that if user\n            // is doing transaction updates, the pinned rows are not getting constantly\n            // trashed - or editing cells in pinned rows are not refreshed and put into read mode\n            onlyBody: true\n        };\n        this.redrawAfterModelUpdate(params);\n    };\n    // if the row nodes are not rendered, no index is returned\n    RowRenderer.prototype.getRenderedIndexesForRowNodes = function (rowNodes) {\n        var result = [];\n        if (_.missing(rowNodes)) {\n            return result;\n        }\n        _.iterateObject(this.rowCompsByIndex, function (index, renderedRow) {\n            var rowNode = renderedRow.getRowNode();\n            if (rowNodes.indexOf(rowNode) >= 0) {\n                result.push(index);\n            }\n        });\n        return result;\n    };\n    RowRenderer.prototype.redrawRows = function (rowNodes) {\n        if (!rowNodes || rowNodes.length == 0) {\n            return;\n        }\n        // we only need to be worried about rendered rows, as this method is\n        // called to what's rendered. if the row isn't rendered, we don't care\n        var indexesToRemove = this.getRenderedIndexesForRowNodes(rowNodes);\n        // remove the rows\n        this.removeRowComps(indexesToRemove);\n        // add draw them again\n        this.redrawAfterModelUpdate({\n            recycleRows: true\n        });\n    };\n    RowRenderer.prototype.getCellToRestoreFocusToAfterRefresh = function (params) {\n        var focusedCell = params.suppressKeepFocus ? null : this.focusController.getFocusCellToUseAfterRefresh();\n        if (_.missing(focusedCell)) {\n            return null;\n        }\n        // if the dom is not actually focused on a cell, then we don't try to refocus. the problem this\n        // solves is with editing - if the user is editing, eg focus is on a text field, and not on the\n        // cell itself, then the cell can be registered as having focus, however it's the text field that\n        // has the focus and not the cell div. therefore, when the refresh is finished, the grid will focus\n        // the cell, and not the textfield. that means if the user is in a text field, and the grid refreshes,\n        // the focus is lost from the text field. we do not want this.\n        var activeElement = document.activeElement;\n        var domData = this.gridOptionsWrapper.getDomData(activeElement, CellComp.DOM_DATA_KEY_CELL_COMP);\n        var elementIsNotACellDev = _.missing(domData);\n        return elementIsNotACellDev ? null : focusedCell;\n    };\n    // gets called after changes to the model.\n    RowRenderer.prototype.redrawAfterModelUpdate = function (params) {\n        if (params === void 0) { params = {}; }\n        this.getLockOnRefresh();\n        var focusedCell = this.getCellToRestoreFocusToAfterRefresh(params);\n        this.sizeContainerToPageHeight();\n        this.scrollToTopIfNewData(params);\n        // never recycle rows when print layout, we draw each row again from scratch. this is because print layout\n        // uses normal dom layout to put cells into dom - it doesn't allow reordering rows.\n        var recycleRows = !this.printLayout && params.recycleRows;\n        var animate = params.animate && this.gridOptionsWrapper.isAnimateRows();\n        var rowsToRecycle = this.binRowComps(recycleRows);\n        this.redraw(rowsToRecycle, animate);\n        if (!params.onlyBody) {\n            this.refreshFloatingRowComps();\n        }\n        this.restoreFocusedCell(focusedCell);\n        this.releaseLockOnRefresh();\n    };\n    RowRenderer.prototype.scrollToTopIfNewData = function (params) {\n        var scrollToTop = params.newData || params.newPage;\n        var suppressScrollToTop = this.gridOptionsWrapper.isSuppressScrollOnNewData();\n        if (scrollToTop && !suppressScrollToTop) {\n            this.gridPanel.scrollToTop();\n        }\n    };\n    RowRenderer.prototype.sizeContainerToPageHeight = function () {\n        var containers = [\n            this.rowContainers.body,\n            this.rowContainers.fullWidth,\n            this.rowContainers.pinnedLeft,\n            this.rowContainers.pinnedRight\n        ];\n        if (this.printLayout) {\n            containers.forEach(function (container) { return container.setHeight(null); });\n            return;\n        }\n        var containerHeight = this.paginationProxy.getCurrentPageHeight();\n        // we need at least 1 pixel for the horizontal scroll to work. so if there are now rows,\n        // we still want the scroll to be present, otherwise there would be no way to scroll the header\n        // which might be needed us user wants to access columns\n        // on the RHS - and if that was where the filter was that cause no rows to be presented, there\n        // is no way to remove the filter.\n        if (containerHeight === 0) {\n            containerHeight = 1;\n        }\n        this.maxDivHeightScaler.setModelHeight(containerHeight);\n        var realHeight = this.maxDivHeightScaler.getUiContainerHeight();\n        containers.forEach(function (container) { return container.setHeight(realHeight); });\n    };\n    RowRenderer.prototype.getLockOnRefresh = function () {\n        if (this.refreshInProgress) {\n            throw new Error(\"ag-Grid: cannot get grid to draw rows when it is in the middle of drawing rows. \" +\n                \"Your code probably called a grid API method while the grid was in the render stage. To overcome \" +\n                \"this, put the API call into a timeout, eg instead of api.refreshView(), \" +\n                \"call setTimeout(function(){api.refreshView(),0}). To see what part of your code \" +\n                \"that caused the refresh check this stacktrace.\");\n        }\n        this.refreshInProgress = true;\n    };\n    RowRenderer.prototype.releaseLockOnRefresh = function () {\n        this.refreshInProgress = false;\n    };\n    // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without\n    // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits\n    // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the\n    // edited cell).\n    RowRenderer.prototype.restoreFocusedCell = function (cellPosition) {\n        if (cellPosition) {\n            this.focusController.setFocusedCell(cellPosition.rowIndex, cellPosition.column, cellPosition.rowPinned, true);\n        }\n    };\n    RowRenderer.prototype.stopEditing = function (cancel) {\n        if (cancel === void 0) { cancel = false; }\n        this.forEachRowComp(function (key, rowComp) {\n            rowComp.stopEditing(cancel);\n        });\n    };\n    RowRenderer.prototype.forEachCellComp = function (callback) {\n        this.forEachRowComp(function (key, rowComp) { return rowComp.forEachCellComp(callback); });\n    };\n    RowRenderer.prototype.forEachRowComp = function (callback) {\n        _.iterateObject(this.rowCompsByIndex, callback);\n        _.iterateObject(this.floatingTopRowComps, callback);\n        _.iterateObject(this.floatingBottomRowComps, callback);\n    };\n    RowRenderer.prototype.addRenderedRowListener = function (eventName, rowIndex, callback) {\n        var rowComp = this.rowCompsByIndex[rowIndex];\n        if (rowComp) {\n            rowComp.addEventListener(eventName, callback);\n        }\n    };\n    RowRenderer.prototype.flashCells = function (params) {\n        if (params === void 0) { params = {}; }\n        var flashDelay = params.flashDelay, fadeDelay = params.fadeDelay;\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) { return cellComp.flashCell({ flashDelay: flashDelay, fadeDelay: fadeDelay }); });\n    };\n    RowRenderer.prototype.refreshCells = function (params) {\n        if (params === void 0) { params = {}; }\n        var refreshCellParams = {\n            forceRefresh: params.force,\n            newData: false,\n            suppressFlash: params.suppressFlash\n        };\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) { return cellComp.refreshCell(refreshCellParams); });\n    };\n    RowRenderer.prototype.getCellRendererInstances = function (params) {\n        var res = [];\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n            var cellRenderer = cellComp.getCellRenderer();\n            if (cellRenderer) {\n                res.push(cellRenderer);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.getCellEditorInstances = function (params) {\n        var res = [];\n        this.forEachCellCompFiltered(params.rowNodes, params.columns, function (cellComp) {\n            var cellEditor = cellComp.getCellEditor();\n            if (cellEditor) {\n                res.push(cellEditor);\n            }\n        });\n        return res;\n    };\n    RowRenderer.prototype.getEditingCells = function () {\n        var res = [];\n        this.forEachCellComp(function (cellComp) {\n            if (cellComp.isEditing()) {\n                var cellPosition = cellComp.getCellPosition();\n                res.push(cellPosition);\n            }\n        });\n        return res;\n    };\n    // calls the callback for each cellComp that match the provided rowNodes and columns. eg if one row node\n    // and two columns provided, that identifies 4 cells, so callback gets called 4 times, once for each cell.\n    RowRenderer.prototype.forEachCellCompFiltered = function (rowNodes, columns, callback) {\n        var _this = this;\n        var rowIdsMap;\n        if (_.exists(rowNodes)) {\n            rowIdsMap = {\n                top: {},\n                bottom: {},\n                normal: {}\n            };\n            rowNodes.forEach(function (rowNode) {\n                if (rowNode.rowPinned === Constants.PINNED_TOP) {\n                    rowIdsMap.top[rowNode.id] = true;\n                }\n                else if (rowNode.rowPinned === Constants.PINNED_BOTTOM) {\n                    rowIdsMap.bottom[rowNode.id] = true;\n                }\n                else {\n                    rowIdsMap.normal[rowNode.id] = true;\n                }\n            });\n        }\n        var colIdsMap;\n        if (_.exists(columns)) {\n            colIdsMap = {};\n            columns.forEach(function (colKey) {\n                var column = _this.columnController.getGridColumn(colKey);\n                if (_.exists(column)) {\n                    colIdsMap[column.getId()] = true;\n                }\n            });\n        }\n        var processRow = function (rowComp) {\n            var rowNode = rowComp.getRowNode();\n            var id = rowNode.id;\n            var floating = rowNode.rowPinned;\n            // skip this row if it is missing from the provided list\n            if (_.exists(rowIdsMap)) {\n                if (floating === Constants.PINNED_BOTTOM) {\n                    if (!rowIdsMap.bottom[id]) {\n                        return;\n                    }\n                }\n                else if (floating === Constants.PINNED_TOP) {\n                    if (!rowIdsMap.top[id]) {\n                        return;\n                    }\n                }\n                else {\n                    if (!rowIdsMap.normal[id]) {\n                        return;\n                    }\n                }\n            }\n            rowComp.forEachCellComp(function (cellComp) {\n                var colId = cellComp.getColumn().getId();\n                var excludeColFromRefresh = colIdsMap && !colIdsMap[colId];\n                if (excludeColFromRefresh) {\n                    return;\n                }\n                callback(cellComp);\n            });\n        };\n        _.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n            processRow(rowComp);\n        });\n        if (this.floatingTopRowComps) {\n            this.floatingTopRowComps.forEach(processRow);\n        }\n        if (this.floatingBottomRowComps) {\n            this.floatingBottomRowComps.forEach(processRow);\n        }\n    };\n    RowRenderer.prototype.destroy = function () {\n        var rowIndexesToRemove = Object.keys(this.rowCompsByIndex);\n        this.removeRowComps(rowIndexesToRemove);\n        _super.prototype.destroy.call(this);\n    };\n    RowRenderer.prototype.binRowComps = function (recycleRows) {\n        var _this = this;\n        var rowsToRecycle = {};\n        var indexesToRemove;\n        if (recycleRows) {\n            indexesToRemove = [];\n            _.iterateObject(this.rowCompsByIndex, function (index, rowComp) {\n                var rowNode = rowComp.getRowNode();\n                if (_.exists(rowNode.id)) {\n                    rowsToRecycle[rowNode.id] = rowComp;\n                    delete _this.rowCompsByIndex[index];\n                }\n                else {\n                    indexesToRemove.push(index);\n                }\n            });\n        }\n        else {\n            indexesToRemove = Object.keys(this.rowCompsByIndex);\n        }\n        this.removeRowComps(indexesToRemove);\n        return rowsToRecycle;\n    };\n    // takes array of row indexes\n    RowRenderer.prototype.removeRowComps = function (rowsToRemove) {\n        var _this = this;\n        // if no fromIndex then set to -1, which will refresh everything\n        // let realFromIndex = -1;\n        rowsToRemove.forEach(function (indexToRemove) {\n            var renderedRow = _this.rowCompsByIndex[indexToRemove];\n            renderedRow.destroy();\n            delete _this.rowCompsByIndex[indexToRemove];\n        });\n    };\n    // gets called when rows don't change, but viewport does, so after:\n    // 1) height of grid body changes, ie number of displayed rows has changed\n    // 2) grid scrolled to new position\n    // 3) ensure index visible (which is a scroll)\n    RowRenderer.prototype.redrawAfterScroll = function () {\n        this.getLockOnRefresh();\n        this.redraw(null, false, true);\n        this.releaseLockOnRefresh();\n    };\n    RowRenderer.prototype.removeRowCompsNotToDraw = function (indexesToDraw) {\n        // for speedy lookup, dump into map\n        var indexesToDrawMap = {};\n        indexesToDraw.forEach(function (index) { return (indexesToDrawMap[index] = true); });\n        var existingIndexes = Object.keys(this.rowCompsByIndex);\n        var indexesNotToDraw = existingIndexes.filter(function (index) { return !indexesToDrawMap[index]; });\n        this.removeRowComps(indexesNotToDraw);\n    };\n    RowRenderer.prototype.calculateIndexesToDraw = function (rowsToRecycle) {\n        var _this = this;\n        // all in all indexes in the viewport\n        var indexesToDraw = _.createArrayOfNumbers(this.firstRenderedRow, this.lastRenderedRow);\n        var checkRowToDraw = function (indexStr, rowComp) {\n            var index = Number(indexStr);\n            if (index < _this.firstRenderedRow || index > _this.lastRenderedRow) {\n                if (_this.doNotUnVirtualiseRow(rowComp)) {\n                    indexesToDraw.push(index);\n                }\n            }\n        };\n        // if we are redrawing due to scrolling change, then old rows are in this.rowCompsByIndex\n        _.iterateObject(this.rowCompsByIndex, checkRowToDraw);\n        // if we are redrawing due to model update, then old rows are in rowsToRecycle\n        _.iterateObject(rowsToRecycle, checkRowToDraw);\n        indexesToDraw.sort(function (a, b) { return a - b; });\n        return indexesToDraw;\n    };\n    RowRenderer.prototype.redraw = function (rowsToRecycle, animate, afterScroll) {\n        var _this = this;\n        if (animate === void 0) { animate = false; }\n        if (afterScroll === void 0) { afterScroll = false; }\n        this.maxDivHeightScaler.updateOffset();\n        this.workOutFirstAndLastRowsToRender();\n        // the row can already exist and be in the following:\n        // rowsToRecycle -> if model change, then the index may be different, however row may\n        //                         exist here from previous time (mapped by id).\n        // this.rowCompsByIndex -> if just a scroll, then this will contain what is currently in the viewport\n        // this is all the indexes we want, including those that already exist, so this method\n        // will end up going through each index and drawing only if the row doesn't already exist\n        var indexesToDraw = this.calculateIndexesToDraw(rowsToRecycle);\n        this.removeRowCompsNotToDraw(indexesToDraw);\n        // never animate when doing print layout - as we want to get things ready to print as quickly as possible,\n        // otherwise we risk the printer printing a row that's half faded (half way through fading in)\n        if (this.printLayout) {\n            animate = false;\n        }\n        // add in new rows\n        var nextVmTurnFunctions = [];\n        var rowComps = [];\n        indexesToDraw.forEach(function (rowIndex) {\n            var rowComp = _this.createOrUpdateRowComp(rowIndex, rowsToRecycle, animate, afterScroll);\n            if (_.exists(rowComp)) {\n                rowComps.push(rowComp);\n                _.pushAll(nextVmTurnFunctions, rowComp.getAndClearNextVMTurnFunctions());\n            }\n        });\n        this.flushContainers(rowComps);\n        _.executeNextVMTurn(nextVmTurnFunctions);\n        var useAnimationFrame = afterScroll && !this.gridOptionsWrapper.isSuppressAnimationFrame() && !this.printLayout;\n        if (useAnimationFrame) {\n            this.beans.taskQueue.addDestroyTask(this.destroyRowComps.bind(this, rowsToRecycle, animate));\n        }\n        else {\n            this.destroyRowComps(rowsToRecycle, animate);\n        }\n        this.checkAngularCompile();\n        this.gridPanel.updateRowCount();\n    };\n    RowRenderer.prototype.flushContainers = function (rowComps) {\n        _.iterateObject(this.rowContainers, function (key, rowContainerComp) {\n            if (rowContainerComp) {\n                rowContainerComp.flushRowTemplates();\n            }\n        });\n        rowComps.forEach(function (rowComp) { return rowComp.afterFlush(); });\n    };\n    RowRenderer.prototype.onDisplayedColumnsChanged = function () {\n        var pinningLeft = this.columnController.isPinningLeft();\n        var pinningRight = this.columnController.isPinningRight();\n        var atLeastOneChanged = this.pinningLeft !== pinningLeft || pinningRight !== this.pinningRight;\n        if (atLeastOneChanged) {\n            this.pinningLeft = pinningLeft;\n            this.pinningRight = pinningRight;\n            if (this.embedFullWidthRows) {\n                this.redrawFullWidthEmbeddedRows();\n            }\n        }\n    };\n    // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,\n    // then it should go into the pinned left area if pinning left, or the center area if not pinning.\n    RowRenderer.prototype.redrawFullWidthEmbeddedRows = function () {\n        // if either of the pinned panels has shown / hidden, then need to redraw the fullWidth bits when\n        // embedded, as what appears in each section depends on whether we are pinned or not\n        var rowsToRemove = [];\n        _.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n            if (rowComp.isFullWidth()) {\n                var rowIndex = rowComp.getRowNode().rowIndex;\n                rowsToRemove.push(rowIndex.toString());\n            }\n        });\n        this.refreshFloatingRowComps();\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.refreshFullWidthRows = function () {\n        var rowsToRemove = [];\n        _.iterateObject(this.rowCompsByIndex, function (id, rowComp) {\n            if (rowComp.isFullWidth()) {\n                var fullWidthRowsRefreshed = rowComp.refreshFullWidth();\n                if (!fullWidthRowsRefreshed) {\n                    var rowIndex = rowComp.getRowNode().rowIndex;\n                    rowsToRemove.push(rowIndex.toString());\n                }\n            }\n        });\n        this.removeRowComps(rowsToRemove);\n        this.redrawAfterScroll();\n    };\n    RowRenderer.prototype.createOrUpdateRowComp = function (rowIndex, rowsToRecycle, animate, afterScroll) {\n        var rowNode;\n        var rowComp = this.rowCompsByIndex[rowIndex];\n        // if no row comp, see if we can get it from the previous rowComps\n        if (!rowComp) {\n            rowNode = this.paginationProxy.getRow(rowIndex);\n            if (_.exists(rowNode) && _.exists(rowsToRecycle) && rowsToRecycle[rowNode.id] && rowNode.alreadyRendered) {\n                rowComp = rowsToRecycle[rowNode.id];\n                rowsToRecycle[rowNode.id] = null;\n            }\n        }\n        var creatingNewRowComp = !rowComp;\n        if (creatingNewRowComp) {\n            // create a new one\n            if (!rowNode) {\n                rowNode = this.paginationProxy.getRow(rowIndex);\n            }\n            if (_.exists(rowNode)) {\n                rowComp = this.createRowComp(rowNode, animate, afterScroll);\n            }\n            else {\n                // this should never happen - if somehow we are trying to create\n                // a row for a rowNode that does not exist.\n                return;\n            }\n        }\n        else {\n            // ensure row comp is in right position in DOM\n            rowComp.ensureDomOrder();\n        }\n        if (rowNode) {\n            // set node as 'alreadyRendered' to ensure we only recycle rowComps that have been rendered, this ensures\n            // we don't reuse rowComps that have been removed and then re-added in the same batch transaction.\n            rowNode.alreadyRendered = true;\n        }\n        this.rowCompsByIndex[rowIndex] = rowComp;\n        return rowComp;\n    };\n    RowRenderer.prototype.destroyRowComps = function (rowCompsMap, animate) {\n        var delayedFuncs = [];\n        _.iterateObject(rowCompsMap, function (nodeId, rowComp) {\n            // if row was used, then it's null\n            if (!rowComp) {\n                return;\n            }\n            rowComp.destroy(animate);\n            _.pushAll(delayedFuncs, rowComp.getAndClearDelayedDestroyFunctions());\n        });\n        _.executeInAWhile(delayedFuncs);\n    };\n    RowRenderer.prototype.checkAngularCompile = function () {\n        var _this = this;\n        // if we are doing angular compiling, then do digest the scope here\n        if (this.gridOptionsWrapper.isAngularCompileRows()) {\n            // we do it in a timeout, in case we are already in an apply\n            window.setTimeout(function () {\n                _this.$scope.$apply();\n            }, 0);\n        }\n    };\n    RowRenderer.prototype.workOutFirstAndLastRowsToRender = function () {\n        var _this = this;\n        var newFirst;\n        var newLast;\n        if (!this.paginationProxy.isRowsToRender()) {\n            newFirst = 0;\n            newLast = -1; // setting to -1 means nothing in range\n        }\n        else if (this.printLayout) {\n            newFirst = this.paginationProxy.getPageFirstRow();\n            newLast = this.paginationProxy.getPageLastRow();\n        }\n        else {\n            var paginationOffset = this.paginationProxy.getPixelOffset();\n            var maxDivHeightScaler = this.maxDivHeightScaler.getOffset();\n            var bodyVRange = this.gridPanel.getVScrollPosition();\n            var bodyTopPixel = bodyVRange.top;\n            var bodyBottomPixel = bodyVRange.bottom;\n            var bufferPixels = this.gridOptionsWrapper.getRowBufferInPixels();\n            var firstPixel = bodyTopPixel + paginationOffset + maxDivHeightScaler - bufferPixels;\n            var lastPixel = bodyBottomPixel + paginationOffset + maxDivHeightScaler + bufferPixels;\n            this.ensureAllRowsInRangeHaveHeightsCalculated(firstPixel, lastPixel);\n            var firstRowIndex = this.paginationProxy.getRowIndexAtPixel(firstPixel);\n            var lastRowIndex = this.paginationProxy.getRowIndexAtPixel(lastPixel);\n            var pageFirstRow = this.paginationProxy.getPageFirstRow();\n            var pageLastRow = this.paginationProxy.getPageLastRow();\n            // adjust, in case buffer extended actual size\n            if (firstRowIndex < pageFirstRow) {\n                firstRowIndex = pageFirstRow;\n            }\n            if (lastRowIndex > pageLastRow) {\n                lastRowIndex = pageLastRow;\n            }\n            newFirst = firstRowIndex;\n            newLast = lastRowIndex;\n        }\n        // sometimes user doesn't set CSS right and ends up with grid with no height and grid ends up\n        // trying to render all the rows, eg 10,000+ rows. this will kill the browser. so instead of\n        // killing the browser, we limit the number of rows. just in case some use case we didn't think\n        // of, we also have a property to not do this operation.\n        var rowLayoutNormal = this.gridOptionsWrapper.getDomLayout() === Constants.DOM_LAYOUT_NORMAL;\n        var suppressRowCountRestriction = this.gridOptionsWrapper.isSuppressMaxRenderedRowRestriction();\n        var rowBufferMaxSize = Math.max(this.gridOptionsWrapper.getRowBuffer(), 500);\n        if (rowLayoutNormal && !suppressRowCountRestriction) {\n            if (newLast - newFirst > rowBufferMaxSize) {\n                newLast = newFirst + rowBufferMaxSize;\n            }\n        }\n        var firstDiffers = newFirst !== this.firstRenderedRow;\n        var lastDiffers = newLast !== this.lastRenderedRow;\n        if (firstDiffers || lastDiffers) {\n            this.firstRenderedRow = newFirst;\n            this.lastRenderedRow = newLast;\n            var event_1 = {\n                type: Events.EVENT_VIEWPORT_CHANGED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n        // only dispatch firstDataRendered if we have actually rendered some data\n        if (this.paginationProxy.isRowsToRender()) {\n            var event_2 = {\n                type: Events.EVENT_FIRST_DATA_RENDERED,\n                firstRow: newFirst,\n                lastRow: newLast,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            // added a small delay here because in some scenarios this can be fired\n            // before the grid is actually rendered, causing component creation\n            // on EVENT_FIRST_DATA_RENDERED to fail.\n            window.setTimeout(function () { return _this.eventService.dispatchEventOnce(event_2); }, 50);\n        }\n    };\n    RowRenderer.prototype.ensureAllRowsInRangeHaveHeightsCalculated = function (topPixel, bottomPixel) {\n        // ensureRowHeightsVisible only works with CSRM, as it's the only row model that allows lazy row height calcs.\n        // all the other row models just hard code so the method just returns back false\n        var rowHeightsChanged = this.paginationProxy.ensureRowHeightsValid(topPixel, bottomPixel, -1, -1);\n        if (rowHeightsChanged) {\n            // if row heights have changed, we need to resize the containers the rows sit it\n            this.sizeContainerToPageHeight();\n            // we also need to update heightScaler as this has dependency of row container height\n            this.maxDivHeightScaler.updateOffset();\n        }\n    };\n    RowRenderer.prototype.getFirstVirtualRenderedRow = function () {\n        return this.firstRenderedRow;\n    };\n    RowRenderer.prototype.getLastVirtualRenderedRow = function () {\n        return this.lastRenderedRow;\n    };\n    // check that none of the rows to remove are editing or focused as:\n    // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,\n    //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered\n    //    the edit is reset - so we want to keep it rendered.\n    // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,\n    //    otherwise the user can range select and drag (with focus cell going out of the viewport)\n    //    and then ctrl+c, nothing will happen if cell is removed from dom.\n    // c) if detail record of master detail, as users complained that the context of detail rows\n    //    was getting lost when detail row out of view. eg user expands to show detail row,\n    //    then manipulates the detail panel (eg sorts the detail grid), then context is lost\n    //    after detail panel is scrolled out of / into view.\n    RowRenderer.prototype.doNotUnVirtualiseRow = function (rowComp) {\n        var REMOVE_ROW = false;\n        var KEEP_ROW = true;\n        var rowNode = rowComp.getRowNode();\n        var rowHasFocus = this.focusController.isRowNodeFocused(rowNode);\n        var rowIsEditing = rowComp.isEditing();\n        var rowIsDetail = rowNode.detail;\n        var mightWantToKeepRow = rowHasFocus || rowIsEditing || rowIsDetail;\n        // if we deffo don't want to keep it,\n        if (!mightWantToKeepRow) {\n            return REMOVE_ROW;\n        }\n        // editing row, only remove if it is no longer rendered, eg filtered out or new data set.\n        // the reason we want to keep is if user is scrolling up and down, we don't want to loose\n        // the context of the editing in process.\n        var rowNodePresent = this.paginationProxy.isRowPresent(rowNode);\n        return rowNodePresent ? KEEP_ROW : REMOVE_ROW;\n    };\n    RowRenderer.prototype.createRowComp = function (rowNode, animate, afterScroll) {\n        var suppressAnimationFrame = this.gridOptionsWrapper.isSuppressAnimationFrame();\n        // we don't use animations frames for printing, so the user can put the grid into print mode\n        // and immediately print - otherwise the user would have to wait for the rows to draw in the background\n        // (via the animation frames) which is awkward to do from code.\n        // we only do the animation frames after scrolling, as this is where we want the smooth user experience.\n        // having animation frames for other times makes the grid look 'jumpy'.\n        var useAnimationFrameForCreate = afterScroll && !suppressAnimationFrame && !this.printLayout;\n        var rowComp = new RowComp(this.$scope, this.rowContainers.body, this.rowContainers.pinnedLeft, this.rowContainers.pinnedRight, this.rowContainers.fullWidth, rowNode, this.beans, animate, useAnimationFrameForCreate, this.printLayout, this.embedFullWidthRows);\n        rowComp.init();\n        return rowComp;\n    };\n    RowRenderer.prototype.getRenderedNodes = function () {\n        var renderedRows = this.rowCompsByIndex;\n        return Object.keys(renderedRows).map(function (key) { return renderedRows[key].getRowNode(); });\n    };\n    // we use index for rows, but column object for columns, as the next column (by index) might not\n    // be visible (header grouping) so it's not reliable, so using the column object instead.\n    RowRenderer.prototype.navigateToNextCell = function (event, key, currentCell, allowUserOverride) {\n        // we keep searching for a next cell until we find one. this is how the group rows get skipped\n        var nextCell = currentCell;\n        var hitEdgeOfGrid = false;\n        while (nextCell && (nextCell === currentCell || !this.isValidNavigateCell(nextCell))) {\n            // if the current cell is spanning across multiple columns, we need to move\n            // our current position to be the last cell on the right before finding the\n            // the next target.\n            if (this.gridOptionsWrapper.isEnableRtl()) {\n                if (key === Constants.KEY_LEFT) {\n                    nextCell = this.getLastCellOfColSpan(nextCell);\n                }\n            }\n            else if (key === Constants.KEY_RIGHT) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextCellToFocus(key, nextCell);\n            // eg if going down, and nextCell=undefined, means we are gone past the last row\n            hitEdgeOfGrid = _.missing(nextCell);\n        }\n        if (hitEdgeOfGrid && event.keyCode === Constants.KEY_UP) {\n            nextCell = {\n                rowIndex: -1,\n                rowPinned: null,\n                column: currentCell.column\n            };\n        }\n        // allow user to override what cell to go to next. when doing normal cell navigation (with keys)\n        // we allow this, however if processing 'enter after edit' we don't allow override\n        if (allowUserOverride) {\n            var userFunc = this.gridOptionsWrapper.getNavigateToNextCellFunc();\n            if (_.exists(userFunc)) {\n                var params = {\n                    key: key,\n                    previousCellPosition: currentCell,\n                    nextCellPosition: nextCell ? nextCell : null,\n                    event: event\n                };\n                var userCell = userFunc(params);\n                if (_.exists(userCell)) {\n                    if (userCell.floating) {\n                        _.doOnce(function () { console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextCell = {\n                        rowPinned: userCell.rowPinned,\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column\n                    };\n                }\n                else {\n                    nextCell = null;\n                }\n            }\n        }\n        // no next cell means we have reached a grid boundary, eg left, right, top or bottom of grid\n        if (!nextCell) {\n            return;\n        }\n        if (nextCell.rowIndex < 0) {\n            var headerLen = this.beans.headerNavigationService.getHeaderRowCount();\n            this.focusController.focusHeaderPosition({\n                headerRowIndex: headerLen + (nextCell.rowIndex), column: currentCell.column\n            });\n            return;\n        }\n        // in case we have col spanning we get the cellComp and use it to\n        // get the position. This was we always focus the first cell inside\n        // the spanning.\n        this.ensureCellVisible(nextCell); // ensureCellVisible first, to make sure nextCell is rendered\n        var cellComp = this.getComponentForCell(nextCell);\n        // not guaranteed to have a cellComp when using the SSRM as blocks are loading.\n        if (!cellComp) {\n            return;\n        }\n        nextCell = cellComp.getCellPosition();\n        // we call this again, as nextCell can be different to it's previous value due to Column Spanning\n        // (ie if cursor moving from right to left, and cell is spanning columns, then nextCell was the\n        // last column in the group, however now it's the first column in the group). if we didn't do\n        // ensureCellVisible again, then we could only be showing the last portion (last column) of the\n        // merged cells.\n        this.ensureCellVisible(nextCell);\n        this.focusController.setFocusedCell(nextCell.rowIndex, nextCell.column, nextCell.rowPinned, true);\n        if (this.rangeController) {\n            this.rangeController.setRangeToCell(nextCell);\n        }\n    };\n    RowRenderer.prototype.isValidNavigateCell = function (cell) {\n        var rowNode = this.rowPositionUtils.getRowNode(cell);\n        // we do not allow focusing on detail rows and full width rows\n        if (rowNode.detail || rowNode.isFullWidthCell()) {\n            return false;\n        }\n        // if not a group, then we have a valid row, so quit the search\n        if (!rowNode.group) {\n            return true;\n        }\n        // full width rows cannot be focused, so if it's a group and using full width rows,\n        // we need to skip over the row\n        var pivotMode = this.columnController.isPivotMode();\n        var usingFullWidthRows = this.gridOptionsWrapper.isGroupUseEntireRow(pivotMode);\n        if (!usingFullWidthRows) {\n            return true;\n        }\n        return false;\n    };\n    RowRenderer.prototype.getLastCellOfColSpan = function (cell) {\n        var cellComp = this.getComponentForCell(cell);\n        if (!cellComp) {\n            return cell;\n        }\n        var colSpanningList = cellComp.getColSpanningList();\n        if (colSpanningList.length === 1) {\n            return cell;\n        }\n        return {\n            rowIndex: cell.rowIndex,\n            column: _.last(colSpanningList),\n            rowPinned: cell.rowPinned\n        };\n    };\n    RowRenderer.prototype.ensureCellVisible = function (gridCell) {\n        // this scrolls the row into view\n        if (_.missing(gridCell.rowPinned)) {\n            this.gridPanel.ensureIndexVisible(gridCell.rowIndex);\n        }\n        if (!gridCell.column.isPinned()) {\n            this.gridPanel.ensureColumnVisible(gridCell.column);\n        }\n        // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n        // floating cell, the scrolls get out of sync\n        this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n        // need to flush frames, to make sure the correct cells are rendered\n        this.animationFrameService.flushAllFrames();\n    };\n    RowRenderer.prototype.startEditingCell = function (gridCell, keyPress, charPress) {\n        var cell = this.getComponentForCell(gridCell);\n        if (cell) {\n            cell.startRowOrCellEdit(keyPress, charPress);\n        }\n    };\n    RowRenderer.prototype.getComponentForCell = function (cellPosition) {\n        var rowComponent;\n        switch (cellPosition.rowPinned) {\n            case Constants.PINNED_TOP:\n                rowComponent = this.floatingTopRowComps[cellPosition.rowIndex];\n                break;\n            case Constants.PINNED_BOTTOM:\n                rowComponent = this.floatingBottomRowComps[cellPosition.rowIndex];\n                break;\n            default:\n                rowComponent = this.rowCompsByIndex[cellPosition.rowIndex];\n                break;\n        }\n        if (!rowComponent) {\n            return null;\n        }\n        var cellComponent = rowComponent.getRenderedCellForColumn(cellPosition.column);\n        return cellComponent;\n    };\n    RowRenderer.prototype.getRowNode = function (gridRow) {\n        switch (gridRow.rowPinned) {\n            case Constants.PINNED_TOP:\n                return this.pinnedRowModel.getPinnedTopRowData()[gridRow.rowIndex];\n            case Constants.PINNED_BOTTOM:\n                return this.pinnedRowModel.getPinnedBottomRowData()[gridRow.rowIndex];\n            default:\n                return this.rowModel.getRow(gridRow.rowIndex);\n        }\n    };\n    RowRenderer.prototype.onTabKeyDown = function (previousRenderedCell, keyboardEvent) {\n        var backwards = keyboardEvent.shiftKey;\n        var success = this.moveToCellAfter(previousRenderedCell, backwards);\n        if (success) {\n            keyboardEvent.preventDefault();\n        }\n        else if (keyboardEvent.shiftKey) {\n            var cellPosition = previousRenderedCell.getCellPosition();\n            if (cellPosition.rowIndex === 0) {\n                keyboardEvent.preventDefault();\n                this.focusController.focusHeaderPosition({\n                    headerRowIndex: this.beans.headerNavigationService.getHeaderRowCount() - 1,\n                    column: _.last(this.columnController.getAllDisplayedColumns())\n                });\n            }\n        }\n    };\n    RowRenderer.prototype.tabToNextCell = function (backwards) {\n        var focusedCell = this.focusController.getFocusedCell();\n        // if no focus, then cannot navigate\n        if (_.missing(focusedCell)) {\n            return false;\n        }\n        var renderedCell = this.getComponentForCell(focusedCell);\n        // if cell is not rendered, means user has scrolled away from the cell\n        if (_.missing(renderedCell)) {\n            return false;\n        }\n        var result = this.moveToCellAfter(renderedCell, backwards);\n        return result;\n    };\n    RowRenderer.prototype.moveToCellAfter = function (previousRenderedCell, backwards) {\n        var editing = previousRenderedCell.isEditing();\n        var res;\n        if (editing) {\n            if (this.gridOptionsWrapper.isFullRowEdit()) {\n                res = this.moveToNextEditingRow(previousRenderedCell, backwards);\n            }\n            else {\n                res = this.moveToNextEditingCell(previousRenderedCell, backwards);\n            }\n        }\n        else {\n            res = this.moveToNextCellNotEditing(previousRenderedCell, backwards);\n        }\n        return res;\n    };\n    RowRenderer.prototype.moveToNextEditingCell = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // need to do this before getting next cell to edit, in case the next cell\n        // has editable function (eg colDef.editable=func() ) and it depends on the\n        // result of this cell, so need to save updates from the first edit, in case\n        // the value is referenced in the function.\n        previousRenderedCell.stopEditing();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n        var foundCell = _.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.startEditingIfEnabled(null, null, true);\n            nextRenderedCell.focusCell(false);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveToNextEditingRow = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, true);\n        var foundCell = _.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            this.moveEditToNextCellOrRow(previousRenderedCell, nextRenderedCell);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveToNextCellNotEditing = function (previousRenderedCell, backwards) {\n        var gridCell = previousRenderedCell.getCellPosition();\n        // find the next cell to start editing\n        var nextRenderedCell = this.findNextCellToFocusOn(gridCell, backwards, false);\n        var foundCell = _.exists(nextRenderedCell);\n        // only prevent default if we found a cell. so if user is on last cell and hits tab, then we default\n        // to the normal tabbing so user can exit the grid.\n        if (foundCell) {\n            nextRenderedCell.focusCell(true);\n        }\n        return foundCell;\n    };\n    RowRenderer.prototype.moveEditToNextCellOrRow = function (previousRenderedCell, nextRenderedCell) {\n        var pGridCell = previousRenderedCell.getCellPosition();\n        var nGridCell = nextRenderedCell.getCellPosition();\n        var rowsMatch = pGridCell.rowIndex === nGridCell.rowIndex && pGridCell.rowPinned === nGridCell.rowPinned;\n        if (rowsMatch) {\n            // same row, so we don't start / stop editing, we just move the focus along\n            previousRenderedCell.setFocusOutOnEditor();\n            nextRenderedCell.setFocusInOnEditor();\n        }\n        else {\n            var pRow = previousRenderedCell.getRenderedRow();\n            var nRow = nextRenderedCell.getRenderedRow();\n            previousRenderedCell.setFocusOutOnEditor();\n            pRow.stopEditing();\n            nRow.startRowEditing();\n            nextRenderedCell.setFocusInOnEditor();\n        }\n        nextRenderedCell.focusCell();\n    };\n    // called by the cell, when tab is pressed while editing.\n    // @return: RenderedCell when navigation successful, otherwise null\n    RowRenderer.prototype.findNextCellToFocusOn = function (gridCell, backwards, startEditing) {\n        var nextCell = gridCell;\n        while (true) {\n            if (!backwards) {\n                nextCell = this.getLastCellOfColSpan(nextCell);\n            }\n            nextCell = this.cellNavigationService.getNextTabbedCell(nextCell, backwards);\n            // allow user to override what cell to go to next\n            var userFunc = this.gridOptionsWrapper.getTabToNextCellFunc();\n            if (_.exists(userFunc)) {\n                var params = {\n                    backwards: backwards,\n                    editing: startEditing,\n                    previousCellPosition: gridCell,\n                    nextCellPosition: nextCell ? nextCell : null\n                };\n                var userCell = userFunc(params);\n                if (_.exists(userCell)) {\n                    if (userCell.floating) {\n                        _.doOnce(function () { console.warn(\"ag-Grid: tabToNextCellFunc return type should have attributes: rowIndex, rowPinned, column. However you had 'floating', maybe you meant 'rowPinned'?\"); }, 'no floating in userCell');\n                        userCell.rowPinned = userCell.floating;\n                    }\n                    nextCell = {\n                        rowIndex: userCell.rowIndex,\n                        column: userCell.column,\n                        rowPinned: userCell.rowPinned\n                    };\n                }\n                else {\n                    nextCell = null;\n                }\n            }\n            // if no 'next cell', means we have got to last cell of grid, so nothing to move to,\n            // so bottom right cell going forwards, or top left going backwards\n            if (!nextCell) {\n                return null;\n            }\n            // if editing, but cell not editable, skip cell. we do this before we do all of\n            // the 'ensure index visible' and 'flush all frames', otherwise if we are skipping\n            // a bunch of cells (eg 10 rows) then all the work on ensuring cell visible is useless\n            // (except for the last one) which causes grid to stall for a while.\n            if (startEditing) {\n                var rowNode = this.lookupRowNodeForCell(nextCell);\n                var cellIsEditable = nextCell.column.isCellEditable(rowNode);\n                if (!cellIsEditable) {\n                    continue;\n                }\n            }\n            // this scrolls the row into view\n            var cellIsNotFloating = _.missing(nextCell.rowPinned);\n            if (cellIsNotFloating) {\n                this.gridPanel.ensureIndexVisible(nextCell.rowIndex);\n            }\n            // pinned columns don't scroll, so no need to ensure index visible\n            if (!nextCell.column.isPinned()) {\n                this.gridPanel.ensureColumnVisible(nextCell.column);\n            }\n            // need to nudge the scrolls for the floating items. otherwise when we set focus on a non-visible\n            // floating cell, the scrolls get out of sync\n            this.gridPanel.horizontallyScrollHeaderCenterAndFloatingCenter();\n            // get the grid panel to flush all animation frames - otherwise the call below to get the cellComp\n            // could fail, if we just scrolled the grid (to make a cell visible) and the rendering hasn't finished.\n            this.animationFrameService.flushAllFrames();\n            // we have to call this after ensureColumnVisible - otherwise it could be a virtual column\n            // or row that is not currently in view, hence the renderedCell would not exist\n            var nextCellComp = this.getComponentForCell(nextCell);\n            // if next cell is fullWidth row, then no rendered cell,\n            // as fullWidth rows have no cells, so we skip it\n            if (_.missing(nextCellComp)) {\n                continue;\n            }\n            if (nextCellComp.isSuppressNavigable()) {\n                continue;\n            }\n            // by default, when we click a cell, it gets selected into a range, so to keep keyboard navigation\n            // consistent, we set into range here also.\n            if (this.rangeController) {\n                this.rangeController.setRangeToCell(nextCell);\n            }\n            // we successfully tabbed onto a grid cell, so return true\n            return nextCellComp;\n        }\n    };\n    RowRenderer.prototype.lookupRowNodeForCell = function (cell) {\n        if (cell.rowPinned === Constants.PINNED_TOP) {\n            return this.pinnedRowModel.getPinnedTopRow(cell.rowIndex);\n        }\n        if (cell.rowPinned === Constants.PINNED_BOTTOM) {\n            return this.pinnedRowModel.getPinnedBottomRow(cell.rowIndex);\n        }\n        return this.paginationProxy.getRow(cell.rowIndex);\n    };\n    __decorate([\n        Autowired(\"paginationProxy\")\n    ], RowRenderer.prototype, \"paginationProxy\", void 0);\n    __decorate([\n        Autowired(\"columnController\")\n    ], RowRenderer.prototype, \"columnController\", void 0);\n    __decorate([\n        Autowired(\"gridOptionsWrapper\")\n    ], RowRenderer.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired(\"$scope\")\n    ], RowRenderer.prototype, \"$scope\", void 0);\n    __decorate([\n        Autowired(\"pinnedRowModel\")\n    ], RowRenderer.prototype, \"pinnedRowModel\", void 0);\n    __decorate([\n        Autowired(\"rowModel\")\n    ], RowRenderer.prototype, \"rowModel\", void 0);\n    __decorate([\n        Autowired(\"loggerFactory\")\n    ], RowRenderer.prototype, \"loggerFactory\", void 0);\n    __decorate([\n        Autowired(\"focusController\")\n    ], RowRenderer.prototype, \"focusController\", void 0);\n    __decorate([\n        Autowired(\"cellNavigationService\")\n    ], RowRenderer.prototype, \"cellNavigationService\", void 0);\n    __decorate([\n        Autowired(\"columnApi\")\n    ], RowRenderer.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired(\"gridApi\")\n    ], RowRenderer.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired(\"beans\")\n    ], RowRenderer.prototype, \"beans\", void 0);\n    __decorate([\n        Autowired(\"maxDivHeightScaler\")\n    ], RowRenderer.prototype, \"maxDivHeightScaler\", void 0);\n    __decorate([\n        Autowired(\"animationFrameService\")\n    ], RowRenderer.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired(\"rowPositionUtils\")\n    ], RowRenderer.prototype, \"rowPositionUtils\", void 0);\n    __decorate([\n        Optional(\"rangeController\")\n    ], RowRenderer.prototype, \"rangeController\", void 0);\n    __decorate([\n        __param(0, Qualifier(\"loggerFactory\"))\n    ], RowRenderer.prototype, \"agWire\", null);\n    RowRenderer = __decorate([\n        Bean(\"rowRenderer\")\n    ], RowRenderer);\n    return RowRenderer;\n}(BeanStub));\nexport { RowRenderer };\n"]},"metadata":{},"sourceType":"module"}