{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Bean, BeanStub, Autowired, _ } from \"@ag-grid-community/core\";\n\nvar AggregationStage =\n/** @class */\nfunction (_super) {\n  __extends(AggregationStage, _super);\n\n  function AggregationStage() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // it's possible to recompute the aggregate without doing the other parts\n  // + gridApi.recomputeAggregates()\n\n\n  AggregationStage.prototype.execute = function (params) {\n    // we don't do aggregation if doing legacy tree good\n    var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n\n    if (doingLegacyTreeData) {\n      return null;\n    } // if changed path is active, it means we came from a) change detection or b) transaction update.\n    // for both of these, if no value columns are present, it means there is nothing to aggregate now\n    // and there is no cleanup to be done (as value columns don't change between transactions or change\n    // detections). if no value columns and no changed path, means we have to go through all nodes in\n    // case we need to clean up agg data from before.\n\n\n    var noValueColumns = _.missingOrEmpty(this.columnController.getValueColumns());\n\n    var noUserAgg = !this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n    var changedPathActive = params.changedPath && params.changedPath.isActive();\n\n    if (noValueColumns && noUserAgg && changedPathActive) {\n      return;\n    }\n\n    var aggDetails = this.createAggDetails(params);\n    this.recursivelyCreateAggData(aggDetails);\n  };\n\n  AggregationStage.prototype.createAggDetails = function (params) {\n    var pivotActive = this.columnController.isPivotActive();\n    var measureColumns = this.columnController.getValueColumns();\n    var pivotColumns = pivotActive ? this.columnController.getPivotColumns() : [];\n    var aggDetails = {\n      changedPath: params.changedPath,\n      valueColumns: measureColumns,\n      pivotColumns: pivotColumns\n    };\n    return aggDetails;\n  };\n\n  AggregationStage.prototype.recursivelyCreateAggData = function (aggDetails) {\n    var _this = this;\n\n    var callback = function (rowNode) {\n      var hasNoChildren = !rowNode.hasChildren();\n\n      if (hasNoChildren) {\n        // this check is needed for TreeData, in case the node is no longer a child,\n        // but it was a child previously.\n        if (rowNode.aggData) {\n          rowNode.setAggData(null);\n        } // never agg data for leaf nodes\n\n\n        return;\n      } //Optionally prevent the aggregation at the root Node\n      //https://ag-grid.atlassian.net/browse/AG-388\n\n\n      var isRootNode = rowNode.level === -1;\n\n      if (isRootNode) {\n        var notPivoting = !_this.columnController.isPivotMode();\n\n        var suppressAggAtRootLevel = _this.gridOptionsWrapper.isSuppressAggAtRootLevel();\n\n        if (suppressAggAtRootLevel && notPivoting) {\n          return;\n        }\n      }\n\n      _this.aggregateRowNode(rowNode, aggDetails);\n    };\n\n    aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);\n  };\n\n  AggregationStage.prototype.aggregateRowNode = function (rowNode, aggDetails) {\n    var measureColumnsMissing = aggDetails.valueColumns.length === 0;\n    var pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n    var userFunc = this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n    var aggResult;\n\n    if (userFunc) {\n      aggResult = userFunc(rowNode.childrenAfterFilter);\n    } else if (measureColumnsMissing) {\n      aggResult = null;\n    } else if (pivotColumnsMissing) {\n      aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n    } else {\n      aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n    }\n\n    rowNode.setAggData(aggResult); // if we are grouping, then it's possible there is a sibling footer\n    // to the group, so update the data here also if there is one\n\n    if (rowNode.sibling) {\n      rowNode.sibling.setAggData(aggResult);\n    }\n  };\n\n  AggregationStage.prototype.aggregateRowNodeUsingValuesAndPivot = function (rowNode) {\n    var _this = this;\n\n    var result = {};\n    var pivotColumnDefs = this.pivotStage.getPivotColumnDefs(); // Step 1: process value columns\n\n    pivotColumnDefs.filter(function (v) {\n      return !_.exists(v.pivotTotalColumnIds);\n    }) // only process pivot value columns\n    .forEach(function (valueColDef) {\n      var keys = valueColDef.pivotKeys || [];\n      var values;\n      var valueColumn = valueColDef.pivotValueColumn;\n      var colId = valueColDef.colId;\n\n      if (rowNode.leafGroup) {\n        // lowest level group, get the values from the mapped set\n        values = _this.getValuesFromMappedSet(rowNode.childrenMapped, keys, valueColumn);\n      } else {\n        // value columns and pivot columns, non-leaf group\n        values = _this.getValuesPivotNonLeaf(rowNode, colId);\n      }\n\n      result[colId] = _this.aggregateValues(values, valueColumn.getAggFunc(), valueColumn, rowNode);\n    }); // Step 2: process total columns\n\n    pivotColumnDefs.filter(function (v) {\n      return _.exists(v.pivotTotalColumnIds);\n    }) // only process pivot total columns\n    .forEach(function (totalColDef) {\n      var aggResults = [];\n      var pivotValueColumn = totalColDef.pivotValueColumn,\n          pivotTotalColumnIds = totalColDef.pivotTotalColumnIds,\n          colId = totalColDef.colId; //retrieve results for colIds associated with this pivot total column\n\n      if (!pivotTotalColumnIds || !pivotTotalColumnIds.length) {\n        return;\n      }\n\n      pivotTotalColumnIds.forEach(function (colId) {\n        aggResults.push(result[colId]);\n      });\n      result[colId] = _this.aggregateValues(aggResults, pivotValueColumn.getAggFunc(), pivotValueColumn, rowNode);\n    });\n    return result;\n  };\n\n  AggregationStage.prototype.aggregateRowNodeUsingValuesOnly = function (rowNode, aggDetails) {\n    var _this = this;\n\n    var result = {};\n    var changedValueColumns = aggDetails.changedPath.isActive() ? aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns) : aggDetails.valueColumns;\n    var notChangedValueColumns = aggDetails.changedPath.isActive() ? aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns) : null;\n    var values2d = this.getValuesNormal(rowNode, changedValueColumns);\n    var oldValues = rowNode.aggData;\n    changedValueColumns.forEach(function (valueColumn, index) {\n      result[valueColumn.getId()] = _this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);\n    });\n\n    if (notChangedValueColumns && oldValues) {\n      notChangedValueColumns.forEach(function (valueColumn) {\n        result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n      });\n    }\n\n    return result;\n  };\n\n  AggregationStage.prototype.getValuesPivotNonLeaf = function (rowNode, colId) {\n    var values = [];\n    rowNode.childrenAfterFilter.forEach(function (node) {\n      var value = node.aggData[colId];\n      values.push(value);\n    });\n    return values;\n  };\n\n  AggregationStage.prototype.getValuesFromMappedSet = function (mappedSet, keys, valueColumn) {\n    var _this = this;\n\n    var mapPointer = mappedSet;\n    keys.forEach(function (key) {\n      return mapPointer = mapPointer ? mapPointer[key] : null;\n    });\n\n    if (!mapPointer) {\n      return [];\n    }\n\n    var values = [];\n    mapPointer.forEach(function (rowNode) {\n      var value = _this.valueService.getValue(valueColumn, rowNode);\n\n      values.push(value);\n    });\n    return values;\n  };\n\n  AggregationStage.prototype.getValuesNormal = function (rowNode, valueColumns) {\n    // create 2d array, of all values for all valueColumns\n    var values = [];\n    valueColumns.forEach(function () {\n      return values.push([]);\n    });\n    var valueColumnCount = valueColumns.length;\n    var rowCount = rowNode.childrenAfterFilter.length;\n\n    for (var i = 0; i < rowCount; i++) {\n      var childNode = rowNode.childrenAfterFilter[i];\n\n      for (var j = 0; j < valueColumnCount; j++) {\n        var valueColumn = valueColumns[j]; // if the row is a group, then it will only have an agg result value,\n        // which means valueGetter is never used.\n\n        var value = this.valueService.getValue(valueColumn, childNode);\n        values[j].push(value);\n      }\n    }\n\n    return values;\n  };\n\n  AggregationStage.prototype.aggregateValues = function (values, aggFuncOrString, column, rowNode) {\n    var aggFunction = typeof aggFuncOrString === 'string' ? this.aggFuncService.getAggFunc(aggFuncOrString) : aggFuncOrString;\n\n    if (typeof aggFunction !== 'function') {\n      console.error(\"ag-Grid: unrecognised aggregation function \" + aggFuncOrString);\n      return null;\n    }\n\n    var aggFuncAny = aggFunction;\n    return aggFuncAny(values, {\n      values: values,\n      column: column,\n      colDef: column ? column.getColDef() : undefined,\n      rowNode: rowNode,\n      data: rowNode ? rowNode.data : undefined,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    });\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], AggregationStage.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('columnController')], AggregationStage.prototype, \"columnController\", void 0);\n\n  __decorate([Autowired('valueService')], AggregationStage.prototype, \"valueService\", void 0);\n\n  __decorate([Autowired('pivotStage')], AggregationStage.prototype, \"pivotStage\", void 0);\n\n  __decorate([Autowired('aggFuncService')], AggregationStage.prototype, \"aggFuncService\", void 0);\n\n  __decorate([Autowired('aggFuncService')], AggregationStage.prototype, \"gridApi\", void 0);\n\n  __decorate([Autowired('aggFuncService')], AggregationStage.prototype, \"columnApi\", void 0);\n\n  AggregationStage = __decorate([Bean('aggregationStage')], AggregationStage);\n  return AggregationStage;\n}(BeanStub);\n\nexport { AggregationStage };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-enterprise/row-grouping/dist/es6/rowGrouping/aggregationStage.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Bean","BeanStub","Autowired","_","AggregationStage","_super","apply","execute","params","doingLegacyTreeData","exists","gridOptionsWrapper","getNodeChildDetailsFunc","noValueColumns","missingOrEmpty","columnController","getValueColumns","noUserAgg","getGroupRowAggNodesFunc","changedPathActive","changedPath","isActive","aggDetails","createAggDetails","recursivelyCreateAggData","pivotActive","isPivotActive","measureColumns","pivotColumns","getPivotColumns","valueColumns","_this","callback","rowNode","hasNoChildren","hasChildren","aggData","setAggData","isRootNode","level","notPivoting","isPivotMode","suppressAggAtRootLevel","isSuppressAggAtRootLevel","aggregateRowNode","forEachChangedNodeDepthFirst","measureColumnsMissing","pivotColumnsMissing","userFunc","aggResult","childrenAfterFilter","aggregateRowNodeUsingValuesOnly","aggregateRowNodeUsingValuesAndPivot","sibling","result","pivotColumnDefs","pivotStage","getPivotColumnDefs","filter","v","pivotTotalColumnIds","forEach","valueColDef","keys","pivotKeys","values","valueColumn","pivotValueColumn","colId","leafGroup","getValuesFromMappedSet","childrenMapped","getValuesPivotNonLeaf","aggregateValues","getAggFunc","totalColDef","aggResults","push","changedValueColumns","getValueColumnsForNode","notChangedValueColumns","getNotValueColumnsForNode","values2d","getValuesNormal","oldValues","index","getId","node","value","mappedSet","mapPointer","valueService","getValue","valueColumnCount","rowCount","childNode","j","aggFuncOrString","column","aggFunction","aggFuncService","console","error","aggFuncAny","colDef","getColDef","undefined","data","api","gridApi","columnApi"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Bean, BeanStub, Autowired, _ } from \"@ag-grid-community/core\";\nvar AggregationStage = /** @class */ (function (_super) {\n    __extends(AggregationStage, _super);\n    function AggregationStage() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // it's possible to recompute the aggregate without doing the other parts\n    // + gridApi.recomputeAggregates()\n    AggregationStage.prototype.execute = function (params) {\n        // we don't do aggregation if doing legacy tree good\n        var doingLegacyTreeData = _.exists(this.gridOptionsWrapper.getNodeChildDetailsFunc());\n        if (doingLegacyTreeData) {\n            return null;\n        }\n        // if changed path is active, it means we came from a) change detection or b) transaction update.\n        // for both of these, if no value columns are present, it means there is nothing to aggregate now\n        // and there is no cleanup to be done (as value columns don't change between transactions or change\n        // detections). if no value columns and no changed path, means we have to go through all nodes in\n        // case we need to clean up agg data from before.\n        var noValueColumns = _.missingOrEmpty(this.columnController.getValueColumns());\n        var noUserAgg = !this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n        var changedPathActive = params.changedPath && params.changedPath.isActive();\n        if (noValueColumns && noUserAgg && changedPathActive) {\n            return;\n        }\n        var aggDetails = this.createAggDetails(params);\n        this.recursivelyCreateAggData(aggDetails);\n    };\n    AggregationStage.prototype.createAggDetails = function (params) {\n        var pivotActive = this.columnController.isPivotActive();\n        var measureColumns = this.columnController.getValueColumns();\n        var pivotColumns = pivotActive ? this.columnController.getPivotColumns() : [];\n        var aggDetails = {\n            changedPath: params.changedPath,\n            valueColumns: measureColumns,\n            pivotColumns: pivotColumns\n        };\n        return aggDetails;\n    };\n    AggregationStage.prototype.recursivelyCreateAggData = function (aggDetails) {\n        var _this = this;\n        var callback = function (rowNode) {\n            var hasNoChildren = !rowNode.hasChildren();\n            if (hasNoChildren) {\n                // this check is needed for TreeData, in case the node is no longer a child,\n                // but it was a child previously.\n                if (rowNode.aggData) {\n                    rowNode.setAggData(null);\n                }\n                // never agg data for leaf nodes\n                return;\n            }\n            //Optionally prevent the aggregation at the root Node\n            //https://ag-grid.atlassian.net/browse/AG-388\n            var isRootNode = rowNode.level === -1;\n            if (isRootNode) {\n                var notPivoting = !_this.columnController.isPivotMode();\n                var suppressAggAtRootLevel = _this.gridOptionsWrapper.isSuppressAggAtRootLevel();\n                if (suppressAggAtRootLevel && notPivoting) {\n                    return;\n                }\n            }\n            _this.aggregateRowNode(rowNode, aggDetails);\n        };\n        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);\n    };\n    AggregationStage.prototype.aggregateRowNode = function (rowNode, aggDetails) {\n        var measureColumnsMissing = aggDetails.valueColumns.length === 0;\n        var pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n        var userFunc = this.gridOptionsWrapper.getGroupRowAggNodesFunc();\n        var aggResult;\n        if (userFunc) {\n            aggResult = userFunc(rowNode.childrenAfterFilter);\n        }\n        else if (measureColumnsMissing) {\n            aggResult = null;\n        }\n        else if (pivotColumnsMissing) {\n            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n        }\n        else {\n            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n        }\n        rowNode.setAggData(aggResult);\n        // if we are grouping, then it's possible there is a sibling footer\n        // to the group, so update the data here also if there is one\n        if (rowNode.sibling) {\n            rowNode.sibling.setAggData(aggResult);\n        }\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesAndPivot = function (rowNode) {\n        var _this = this;\n        var result = {};\n        var pivotColumnDefs = this.pivotStage.getPivotColumnDefs();\n        // Step 1: process value columns\n        pivotColumnDefs\n            .filter(function (v) { return !_.exists(v.pivotTotalColumnIds); }) // only process pivot value columns\n            .forEach(function (valueColDef) {\n            var keys = valueColDef.pivotKeys || [];\n            var values;\n            var valueColumn = valueColDef.pivotValueColumn;\n            var colId = valueColDef.colId;\n            if (rowNode.leafGroup) {\n                // lowest level group, get the values from the mapped set\n                values = _this.getValuesFromMappedSet(rowNode.childrenMapped, keys, valueColumn);\n            }\n            else {\n                // value columns and pivot columns, non-leaf group\n                values = _this.getValuesPivotNonLeaf(rowNode, colId);\n            }\n            result[colId] = _this.aggregateValues(values, valueColumn.getAggFunc(), valueColumn, rowNode);\n        });\n        // Step 2: process total columns\n        pivotColumnDefs\n            .filter(function (v) { return _.exists(v.pivotTotalColumnIds); }) // only process pivot total columns\n            .forEach(function (totalColDef) {\n            var aggResults = [];\n            var pivotValueColumn = totalColDef.pivotValueColumn, pivotTotalColumnIds = totalColDef.pivotTotalColumnIds, colId = totalColDef.colId;\n            //retrieve results for colIds associated with this pivot total column\n            if (!pivotTotalColumnIds || !pivotTotalColumnIds.length) {\n                return;\n            }\n            pivotTotalColumnIds.forEach(function (colId) {\n                aggResults.push(result[colId]);\n            });\n            result[colId] = _this.aggregateValues(aggResults, pivotValueColumn.getAggFunc(), pivotValueColumn, rowNode);\n        });\n        return result;\n    };\n    AggregationStage.prototype.aggregateRowNodeUsingValuesOnly = function (rowNode, aggDetails) {\n        var _this = this;\n        var result = {};\n        var changedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : aggDetails.valueColumns;\n        var notChangedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : null;\n        var values2d = this.getValuesNormal(rowNode, changedValueColumns);\n        var oldValues = rowNode.aggData;\n        changedValueColumns.forEach(function (valueColumn, index) {\n            result[valueColumn.getId()] = _this.aggregateValues(values2d[index], valueColumn.getAggFunc(), valueColumn, rowNode);\n        });\n        if (notChangedValueColumns && oldValues) {\n            notChangedValueColumns.forEach(function (valueColumn) {\n                result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n            });\n        }\n        return result;\n    };\n    AggregationStage.prototype.getValuesPivotNonLeaf = function (rowNode, colId) {\n        var values = [];\n        rowNode.childrenAfterFilter.forEach(function (node) {\n            var value = node.aggData[colId];\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesFromMappedSet = function (mappedSet, keys, valueColumn) {\n        var _this = this;\n        var mapPointer = mappedSet;\n        keys.forEach(function (key) { return (mapPointer = mapPointer ? mapPointer[key] : null); });\n        if (!mapPointer) {\n            return [];\n        }\n        var values = [];\n        mapPointer.forEach(function (rowNode) {\n            var value = _this.valueService.getValue(valueColumn, rowNode);\n            values.push(value);\n        });\n        return values;\n    };\n    AggregationStage.prototype.getValuesNormal = function (rowNode, valueColumns) {\n        // create 2d array, of all values for all valueColumns\n        var values = [];\n        valueColumns.forEach(function () { return values.push([]); });\n        var valueColumnCount = valueColumns.length;\n        var rowCount = rowNode.childrenAfterFilter.length;\n        for (var i = 0; i < rowCount; i++) {\n            var childNode = rowNode.childrenAfterFilter[i];\n            for (var j = 0; j < valueColumnCount; j++) {\n                var valueColumn = valueColumns[j];\n                // if the row is a group, then it will only have an agg result value,\n                // which means valueGetter is never used.\n                var value = this.valueService.getValue(valueColumn, childNode);\n                values[j].push(value);\n            }\n        }\n        return values;\n    };\n    AggregationStage.prototype.aggregateValues = function (values, aggFuncOrString, column, rowNode) {\n        var aggFunction = typeof aggFuncOrString === 'string' ?\n            this.aggFuncService.getAggFunc(aggFuncOrString) :\n            aggFuncOrString;\n        if (typeof aggFunction !== 'function') {\n            console.error(\"ag-Grid: unrecognised aggregation function \" + aggFuncOrString);\n            return null;\n        }\n        var aggFuncAny = aggFunction;\n        return aggFuncAny(values, {\n            values: values,\n            column: column,\n            colDef: column ? column.getColDef() : undefined,\n            rowNode: rowNode,\n            data: rowNode ? rowNode.data : undefined,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        });\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], AggregationStage.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('columnController')\n    ], AggregationStage.prototype, \"columnController\", void 0);\n    __decorate([\n        Autowired('valueService')\n    ], AggregationStage.prototype, \"valueService\", void 0);\n    __decorate([\n        Autowired('pivotStage')\n    ], AggregationStage.prototype, \"pivotStage\", void 0);\n    __decorate([\n        Autowired('aggFuncService')\n    ], AggregationStage.prototype, \"aggFuncService\", void 0);\n    __decorate([\n        Autowired('aggFuncService')\n    ], AggregationStage.prototype, \"gridApi\", void 0);\n    __decorate([\n        Autowired('aggFuncService')\n    ], AggregationStage.prototype, \"columnApi\", void 0);\n    AggregationStage = __decorate([\n        Bean('aggregationStage')\n    ], AggregationStage);\n    return AggregationStage;\n}(BeanStub));\nexport { AggregationStage };\n"]},"metadata":{},"sourceType":"module"}