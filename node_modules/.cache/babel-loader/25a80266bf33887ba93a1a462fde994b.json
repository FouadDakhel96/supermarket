{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { _ } from \"../utils\";\nimport { BeanStub } from \"../context/beanStub\"; // takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\n\nvar ColumnFactory =\n/** @class */\nfunction (_super) {\n  __extends(ColumnFactory, _super);\n\n  function ColumnFactory() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ColumnFactory.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ColumnFactory');\n  };\n\n  ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingColumns) {\n    // column key creator dishes out unique column id's in a deterministic way,\n    // so if we have two grids (that could be master/slave) with same column definitions,\n    // then this ensures the two grids use identical id's.\n    var columnKeyCreator = new ColumnKeyCreator();\n\n    if (existingColumns) {\n      var existingKeys = existingColumns.map(function (col) {\n        return col.getId();\n      });\n      columnKeyCreator.addExistingKeys(existingKeys);\n    } // we take a copy of the columns as we are going to be removing from them\n\n\n    var existingColsCopy = existingColumns ? existingColumns.slice() : null; // create am unbalanced tree that maps the provided definitions\n\n    var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingColsCopy, columnKeyCreator, null);\n    var treeDept = this.findMaxDept(unbalancedTree, 0);\n    this.logger.log('Number of levels for grouped columns is ' + treeDept);\n    var columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n\n    var deptFirstCallback = function deptFirstCallback(child, parent) {\n      if (child instanceof OriginalColumnGroup) {\n        child.setupExpandable();\n      } // we set the original parents at the end, rather than when we go along, as balancing the tree\n      // adds extra levels into the tree. so we can only set parents when balancing is done.\n\n\n      child.setOriginalParent(parent);\n    };\n\n    this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n    return {\n      columnTree: columnTree,\n      treeDept: treeDept\n    };\n  };\n\n  ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n    var _this = this;\n\n    var autoColBalancedTree = [];\n    autoGroupCols.forEach(function (col) {\n      var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n\n      autoColBalancedTree.push(fakeTreeItem);\n    });\n    return autoColBalancedTree;\n  };\n\n  ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n    var dept = this.findDepth(balancedColumnTree); // at the end, this will be the top of the tree item.\n\n    var nextChild = column;\n\n    for (var i = dept - 1; i >= 0; i--) {\n      var autoGroup = new OriginalColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n      this.context.createBean(autoGroup);\n      autoGroup.setChildren([nextChild]);\n      nextChild.setOriginalParent(autoGroup);\n      nextChild = autoGroup;\n    } // at this point, the nextChild is the top most item in the tree\n\n\n    return nextChild;\n  };\n\n  ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n    var dept = 0;\n    var pointer = balancedColumnTree;\n\n    while (pointer && pointer[0] && pointer[0] instanceof OriginalColumnGroup) {\n      dept++;\n      pointer = pointer[0].getChildren();\n    }\n\n    return dept;\n  };\n\n  ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n    var result = []; // go through each child, for groups, recurse a level deeper,\n    // for columns we need to pad\n\n    for (var i = 0; i < unbalancedTree.length; i++) {\n      var child = unbalancedTree[i];\n\n      if (child instanceof OriginalColumnGroup) {\n        // child is a group, all we do is go to the next level of recursion\n        var originalGroup = child;\n        var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n        originalGroup.setChildren(newChildren);\n        result.push(originalGroup);\n      } else {\n        // child is a column - so here we add in the padded column groups if needed\n        var firstPaddedGroup = void 0;\n        var currentPaddedGroup = void 0; // this for loop will NOT run any loops if no padded column groups are needed\n\n        for (var j = columnDept - 1; j >= currentDept; j--) {\n          var newColId = columnKeyCreator.getUniqueKey(null, null);\n          var colGroupDefMerged = this.createMergedColGroupDef(null);\n          var paddedGroup = new OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n          this.context.createBean(paddedGroup);\n\n          if (currentPaddedGroup) {\n            currentPaddedGroup.setChildren([paddedGroup]);\n          }\n\n          currentPaddedGroup = paddedGroup;\n\n          if (!firstPaddedGroup) {\n            firstPaddedGroup = currentPaddedGroup;\n          }\n        } // likewise this if statement will not run if no padded groups\n\n\n        if (firstPaddedGroup) {\n          result.push(firstPaddedGroup);\n          var hasGroups = unbalancedTree.some(function (child) {\n            return child instanceof OriginalColumnGroup;\n          });\n\n          if (hasGroups) {\n            currentPaddedGroup.setChildren([child]);\n            continue;\n          } else {\n            currentPaddedGroup.setChildren(unbalancedTree);\n            break;\n          }\n        }\n\n        result.push(child);\n      }\n    }\n\n    return result;\n  };\n\n  ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n    var maxDeptThisLevel = dept;\n\n    for (var i = 0; i < treeChildren.length; i++) {\n      var abstractColumn = treeChildren[i];\n\n      if (abstractColumn instanceof OriginalColumnGroup) {\n        var originalGroup = abstractColumn;\n        var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n\n        if (maxDeptThisLevel < newDept) {\n          maxDeptThisLevel = newDept;\n        }\n      }\n    }\n\n    return maxDeptThisLevel;\n  };\n\n  ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, parent) {\n    var _this = this;\n\n    var result = [];\n\n    if (!defs) {\n      return result;\n    }\n\n    defs.forEach(function (def) {\n      var newGroupOrColumn;\n\n      if (_this.isColumnGroup(def)) {\n        newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, parent);\n      } else {\n        newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator, parent);\n      }\n\n      result.push(newGroupOrColumn);\n    });\n    return result;\n  };\n\n  ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, parent) {\n    var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n    var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n    var originalGroup = new OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n    this.context.createBean(originalGroup);\n    var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n    originalGroup.setChildren(children);\n    return originalGroup;\n  };\n\n  ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n    var colGroupDefMerged = {};\n\n    _.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n\n    _.assign(colGroupDefMerged, colGroupDef);\n\n    this.checkForDeprecatedItems(colGroupDefMerged);\n    return colGroupDefMerged;\n  };\n\n  ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator, parent) {\n    var colDefMerged = this.mergeColDefs(colDef);\n    this.checkForDeprecatedItems(colDefMerged); // see if column already exists\n\n    var column = this.findExistingColumn(colDef, existingColsCopy);\n\n    if (!column) {\n      // no existing column, need to create one\n      var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n      column = new Column(colDefMerged, colDef, colId, primaryColumns);\n      this.context.createBean(column);\n    } else {\n      column.setColDef(colDefMerged, colDef);\n    }\n\n    return column;\n  };\n\n  ColumnFactory.prototype.findExistingColumn = function (colDef, existingColsCopy) {\n    var res = _.find(existingColsCopy, function (col) {\n      var oldColDef = col.getUserProvidedColDef();\n\n      if (!oldColDef) {\n        return false;\n      } // first check object references\n\n\n      if (oldColDef === colDef) {\n        return true;\n      } // second check id's\n\n\n      var oldColHadId = oldColDef.colId !== null && oldColDef.colId !== undefined;\n\n      if (oldColHadId) {\n        return oldColDef.colId === colDef.colId;\n      }\n\n      return false;\n    }); // make sure we remove, so if user provided duplicate id, then we don't have more than\n    // one column instance for colDef with common id\n\n\n    if (res) {\n      _.removeFromArray(existingColsCopy, res);\n    }\n\n    return res;\n  };\n\n  ColumnFactory.prototype.mergeColDefs = function (colDef) {\n    // start with empty merged definition\n    var colDefMerged = {}; // merge properties from default column definitions\n\n    _.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef()); // merge properties from column type properties\n\n\n    if (colDef.type) {\n      this.assignColumnTypes(colDef, colDefMerged);\n    } // merge properties from column definitions\n\n\n    _.assign(colDefMerged, colDef);\n\n    return colDefMerged;\n  };\n\n  ColumnFactory.prototype.assignColumnTypes = function (colDef, colDefMerged) {\n    var typeKeys;\n\n    if (colDef.type instanceof Array) {\n      var invalidArray = colDef.type.some(function (a) {\n        return typeof a !== 'string';\n      });\n\n      if (invalidArray) {\n        console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n      } else {\n        typeKeys = colDef.type;\n      }\n    } else if (typeof colDef.type === 'string') {\n      typeKeys = colDef.type.split(',');\n    } else {\n      console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n      return;\n    } // merge user defined with default column types\n\n\n    var allColumnTypes = _.assign({}, DefaultColumnTypes);\n\n    var userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n\n    _.iterateObject(userTypes, function (key, value) {\n      if (key in allColumnTypes) {\n        console.warn(\"ag-Grid: the column type '\" + key + \"' is a default column type and cannot be overridden.\");\n      } else {\n        allColumnTypes[key] = value;\n      }\n    });\n\n    typeKeys.forEach(function (t) {\n      var typeColDef = allColumnTypes[t.trim()];\n\n      if (typeColDef) {\n        _.assign(colDefMerged, typeColDef);\n      } else {\n        console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n      }\n    });\n  };\n\n  ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n    if (colDef) {\n      var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n\n      if (colDefNoType.group !== undefined) {\n        console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroup !== undefined) {\n        console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.headerGroupShow !== undefined) {\n        console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n      }\n\n      if (colDefNoType.suppressRowGroup !== undefined) {\n        console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressAggregation !== undefined) {\n        console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n      }\n\n      if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n        console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n      }\n\n      if (colDefNoType.displayName) {\n        console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n        colDefNoType.headerName = colDefNoType.displayName;\n      }\n    }\n  }; // if object has children, we assume it's a group\n\n\n  ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n    return abstractColDef.children !== undefined;\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], ColumnFactory.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('columnUtils')], ColumnFactory.prototype, \"columnUtils\", void 0);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], ColumnFactory.prototype, \"setBeans\", null);\n\n  ColumnFactory = __decorate([Bean('columnFactory')], ColumnFactory);\n  return ColumnFactory;\n}(BeanStub);\n\nexport { ColumnFactory };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/columnController/columnFactory.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ColumnKeyCreator","OriginalColumnGroup","Column","Autowired","Bean","Qualifier","DefaultColumnTypes","_","BeanStub","ColumnFactory","_super","apply","setBeans","loggerFactory","logger","createColumnTree","defs","primaryColumns","existingColumns","columnKeyCreator","existingKeys","map","col","getId","addExistingKeys","existingColsCopy","slice","unbalancedTree","recursivelyCreateColumns","treeDept","findMaxDept","log","columnTree","balanceColumnTree","deptFirstCallback","child","parent","setupExpandable","setOriginalParent","columnUtils","depthFirstOriginalTreeSearch","createForAutoGroups","autoGroupCols","gridBalancedTree","_this","autoColBalancedTree","forEach","fakeTreeItem","createAutoGroupTreeItem","push","balancedColumnTree","column","dept","findDepth","nextChild","autoGroup","context","createBean","setChildren","pointer","getChildren","currentDept","columnDept","result","originalGroup","newChildren","firstPaddedGroup","currentPaddedGroup","j","newColId","getUniqueKey","colGroupDefMerged","createMergedColGroupDef","paddedGroup","hasGroups","some","treeChildren","maxDeptThisLevel","abstractColumn","newDept","level","def","newGroupOrColumn","isColumnGroup","createColumnGroup","createColumn","colGroupDef","groupId","children","assign","gridOptionsWrapper","getDefaultColGroupDef","checkForDeprecatedItems","colDef","colDefMerged","mergeColDefs","findExistingColumn","colId","field","setColDef","res","find","oldColDef","getUserProvidedColDef","oldColHadId","undefined","removeFromArray","getDefaultColDef","type","assignColumnTypes","typeKeys","invalidArray","a","console","warn","split","allColumnTypes","userTypes","getColumnTypes","iterateObject","value","t","typeColDef","trim","colDefNoType","group","headerGroup","headerGroupShow","suppressRowGroup","suppressAggregation","displayName","headerName","abstractColDef"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ColumnKeyCreator } from \"./columnKeyCreator\";\nimport { OriginalColumnGroup } from \"../entities/originalColumnGroup\";\nimport { Column } from \"../entities/column\";\nimport { Autowired, Bean, Qualifier } from \"../context/context\";\nimport { DefaultColumnTypes } from \"../entities/defaultColumnTypes\";\nimport { _ } from \"../utils\";\nimport { BeanStub } from \"../context/beanStub\";\n// takes ColDefs and ColGroupDefs and turns them into Columns and OriginalGroups\nvar ColumnFactory = /** @class */ (function (_super) {\n    __extends(ColumnFactory, _super);\n    function ColumnFactory() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ColumnFactory.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ColumnFactory');\n    };\n    ColumnFactory.prototype.createColumnTree = function (defs, primaryColumns, existingColumns) {\n        // column key creator dishes out unique column id's in a deterministic way,\n        // so if we have two grids (that could be master/slave) with same column definitions,\n        // then this ensures the two grids use identical id's.\n        var columnKeyCreator = new ColumnKeyCreator();\n        if (existingColumns) {\n            var existingKeys = existingColumns.map(function (col) { return col.getId(); });\n            columnKeyCreator.addExistingKeys(existingKeys);\n        }\n        // we take a copy of the columns as we are going to be removing from them\n        var existingColsCopy = existingColumns ? existingColumns.slice() : null;\n        // create am unbalanced tree that maps the provided definitions\n        var unbalancedTree = this.recursivelyCreateColumns(defs, 0, primaryColumns, existingColsCopy, columnKeyCreator, null);\n        var treeDept = this.findMaxDept(unbalancedTree, 0);\n        this.logger.log('Number of levels for grouped columns is ' + treeDept);\n        var columnTree = this.balanceColumnTree(unbalancedTree, 0, treeDept, columnKeyCreator);\n        var deptFirstCallback = function (child, parent) {\n            if (child instanceof OriginalColumnGroup) {\n                child.setupExpandable();\n            }\n            // we set the original parents at the end, rather than when we go along, as balancing the tree\n            // adds extra levels into the tree. so we can only set parents when balancing is done.\n            child.setOriginalParent(parent);\n        };\n        this.columnUtils.depthFirstOriginalTreeSearch(null, columnTree, deptFirstCallback);\n        return {\n            columnTree: columnTree,\n            treeDept: treeDept\n        };\n    };\n    ColumnFactory.prototype.createForAutoGroups = function (autoGroupCols, gridBalancedTree) {\n        var _this = this;\n        var autoColBalancedTree = [];\n        autoGroupCols.forEach(function (col) {\n            var fakeTreeItem = _this.createAutoGroupTreeItem(gridBalancedTree, col);\n            autoColBalancedTree.push(fakeTreeItem);\n        });\n        return autoColBalancedTree;\n    };\n    ColumnFactory.prototype.createAutoGroupTreeItem = function (balancedColumnTree, column) {\n        var dept = this.findDepth(balancedColumnTree);\n        // at the end, this will be the top of the tree item.\n        var nextChild = column;\n        for (var i = dept - 1; i >= 0; i--) {\n            var autoGroup = new OriginalColumnGroup(null, \"FAKE_PATH_\" + column.getId() + \"}_\" + i, true, i);\n            this.context.createBean(autoGroup);\n            autoGroup.setChildren([nextChild]);\n            nextChild.setOriginalParent(autoGroup);\n            nextChild = autoGroup;\n        }\n        // at this point, the nextChild is the top most item in the tree\n        return nextChild;\n    };\n    ColumnFactory.prototype.findDepth = function (balancedColumnTree) {\n        var dept = 0;\n        var pointer = balancedColumnTree;\n        while (pointer && pointer[0] && pointer[0] instanceof OriginalColumnGroup) {\n            dept++;\n            pointer = pointer[0].getChildren();\n        }\n        return dept;\n    };\n    ColumnFactory.prototype.balanceColumnTree = function (unbalancedTree, currentDept, columnDept, columnKeyCreator) {\n        var result = [];\n        // go through each child, for groups, recurse a level deeper,\n        // for columns we need to pad\n        for (var i = 0; i < unbalancedTree.length; i++) {\n            var child = unbalancedTree[i];\n            if (child instanceof OriginalColumnGroup) {\n                // child is a group, all we do is go to the next level of recursion\n                var originalGroup = child;\n                var newChildren = this.balanceColumnTree(originalGroup.getChildren(), currentDept + 1, columnDept, columnKeyCreator);\n                originalGroup.setChildren(newChildren);\n                result.push(originalGroup);\n            }\n            else {\n                // child is a column - so here we add in the padded column groups if needed\n                var firstPaddedGroup = void 0;\n                var currentPaddedGroup = void 0;\n                // this for loop will NOT run any loops if no padded column groups are needed\n                for (var j = columnDept - 1; j >= currentDept; j--) {\n                    var newColId = columnKeyCreator.getUniqueKey(null, null);\n                    var colGroupDefMerged = this.createMergedColGroupDef(null);\n                    var paddedGroup = new OriginalColumnGroup(colGroupDefMerged, newColId, true, currentDept);\n                    this.context.createBean(paddedGroup);\n                    if (currentPaddedGroup) {\n                        currentPaddedGroup.setChildren([paddedGroup]);\n                    }\n                    currentPaddedGroup = paddedGroup;\n                    if (!firstPaddedGroup) {\n                        firstPaddedGroup = currentPaddedGroup;\n                    }\n                }\n                // likewise this if statement will not run if no padded groups\n                if (firstPaddedGroup) {\n                    result.push(firstPaddedGroup);\n                    var hasGroups = unbalancedTree.some(function (child) { return child instanceof OriginalColumnGroup; });\n                    if (hasGroups) {\n                        currentPaddedGroup.setChildren([child]);\n                        continue;\n                    }\n                    else {\n                        currentPaddedGroup.setChildren(unbalancedTree);\n                        break;\n                    }\n                }\n                result.push(child);\n            }\n        }\n        return result;\n    };\n    ColumnFactory.prototype.findMaxDept = function (treeChildren, dept) {\n        var maxDeptThisLevel = dept;\n        for (var i = 0; i < treeChildren.length; i++) {\n            var abstractColumn = treeChildren[i];\n            if (abstractColumn instanceof OriginalColumnGroup) {\n                var originalGroup = abstractColumn;\n                var newDept = this.findMaxDept(originalGroup.getChildren(), dept + 1);\n                if (maxDeptThisLevel < newDept) {\n                    maxDeptThisLevel = newDept;\n                }\n            }\n        }\n        return maxDeptThisLevel;\n    };\n    ColumnFactory.prototype.recursivelyCreateColumns = function (defs, level, primaryColumns, existingColsCopy, columnKeyCreator, parent) {\n        var _this = this;\n        var result = [];\n        if (!defs) {\n            return result;\n        }\n        defs.forEach(function (def) {\n            var newGroupOrColumn;\n            if (_this.isColumnGroup(def)) {\n                newGroupOrColumn = _this.createColumnGroup(primaryColumns, def, level, existingColsCopy, columnKeyCreator, parent);\n            }\n            else {\n                newGroupOrColumn = _this.createColumn(primaryColumns, def, existingColsCopy, columnKeyCreator, parent);\n            }\n            result.push(newGroupOrColumn);\n        });\n        return result;\n    };\n    ColumnFactory.prototype.createColumnGroup = function (primaryColumns, colGroupDef, level, existingColumns, columnKeyCreator, parent) {\n        var colGroupDefMerged = this.createMergedColGroupDef(colGroupDef);\n        var groupId = columnKeyCreator.getUniqueKey(colGroupDefMerged.groupId, null);\n        var originalGroup = new OriginalColumnGroup(colGroupDefMerged, groupId, false, level);\n        this.context.createBean(originalGroup);\n        var children = this.recursivelyCreateColumns(colGroupDefMerged.children, level + 1, primaryColumns, existingColumns, columnKeyCreator, originalGroup);\n        originalGroup.setChildren(children);\n        return originalGroup;\n    };\n    ColumnFactory.prototype.createMergedColGroupDef = function (colGroupDef) {\n        var colGroupDefMerged = {};\n        _.assign(colGroupDefMerged, this.gridOptionsWrapper.getDefaultColGroupDef());\n        _.assign(colGroupDefMerged, colGroupDef);\n        this.checkForDeprecatedItems(colGroupDefMerged);\n        return colGroupDefMerged;\n    };\n    ColumnFactory.prototype.createColumn = function (primaryColumns, colDef, existingColsCopy, columnKeyCreator, parent) {\n        var colDefMerged = this.mergeColDefs(colDef);\n        this.checkForDeprecatedItems(colDefMerged);\n        // see if column already exists\n        var column = this.findExistingColumn(colDef, existingColsCopy);\n        if (!column) {\n            // no existing column, need to create one\n            var colId = columnKeyCreator.getUniqueKey(colDefMerged.colId, colDefMerged.field);\n            column = new Column(colDefMerged, colDef, colId, primaryColumns);\n            this.context.createBean(column);\n        }\n        else {\n            column.setColDef(colDefMerged, colDef);\n        }\n        return column;\n    };\n    ColumnFactory.prototype.findExistingColumn = function (colDef, existingColsCopy) {\n        var res = _.find(existingColsCopy, function (col) {\n            var oldColDef = col.getUserProvidedColDef();\n            if (!oldColDef) {\n                return false;\n            }\n            // first check object references\n            if (oldColDef === colDef) {\n                return true;\n            }\n            // second check id's\n            var oldColHadId = oldColDef.colId !== null && oldColDef.colId !== undefined;\n            if (oldColHadId) {\n                return oldColDef.colId === colDef.colId;\n            }\n            return false;\n        });\n        // make sure we remove, so if user provided duplicate id, then we don't have more than\n        // one column instance for colDef with common id\n        if (res) {\n            _.removeFromArray(existingColsCopy, res);\n        }\n        return res;\n    };\n    ColumnFactory.prototype.mergeColDefs = function (colDef) {\n        // start with empty merged definition\n        var colDefMerged = {};\n        // merge properties from default column definitions\n        _.assign(colDefMerged, this.gridOptionsWrapper.getDefaultColDef());\n        // merge properties from column type properties\n        if (colDef.type) {\n            this.assignColumnTypes(colDef, colDefMerged);\n        }\n        // merge properties from column definitions\n        _.assign(colDefMerged, colDef);\n        return colDefMerged;\n    };\n    ColumnFactory.prototype.assignColumnTypes = function (colDef, colDefMerged) {\n        var typeKeys;\n        if (colDef.type instanceof Array) {\n            var invalidArray = colDef.type.some(function (a) { return typeof a !== 'string'; });\n            if (invalidArray) {\n                console.warn(\"ag-grid: if colDef.type is supplied an array it should be of type 'string[]'\");\n            }\n            else {\n                typeKeys = colDef.type;\n            }\n        }\n        else if (typeof colDef.type === 'string') {\n            typeKeys = colDef.type.split(',');\n        }\n        else {\n            console.warn(\"ag-grid: colDef.type should be of type 'string' | 'string[]'\");\n            return;\n        }\n        // merge user defined with default column types\n        var allColumnTypes = _.assign({}, DefaultColumnTypes);\n        var userTypes = this.gridOptionsWrapper.getColumnTypes() || {};\n        _.iterateObject(userTypes, function (key, value) {\n            if (key in allColumnTypes) {\n                console.warn(\"ag-Grid: the column type '\" + key + \"' is a default column type and cannot be overridden.\");\n            }\n            else {\n                allColumnTypes[key] = value;\n            }\n        });\n        typeKeys.forEach(function (t) {\n            var typeColDef = allColumnTypes[t.trim()];\n            if (typeColDef) {\n                _.assign(colDefMerged, typeColDef);\n            }\n            else {\n                console.warn(\"ag-grid: colDef.type '\" + t + \"' does not correspond to defined gridOptions.columnTypes\");\n            }\n        });\n    };\n    ColumnFactory.prototype.checkForDeprecatedItems = function (colDef) {\n        if (colDef) {\n            var colDefNoType = colDef; // take out the type, so we can access attributes not defined in the type\n            if (colDefNoType.group !== undefined) {\n                console.warn('ag-grid: colDef.group is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroup !== undefined) {\n                console.warn('ag-grid: colDef.headerGroup is invalid, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.headerGroupShow !== undefined) {\n                console.warn('ag-grid: colDef.headerGroupShow is invalid, should be columnGroupShow, please check documentation on how to do grouping as it changed in version 3');\n            }\n            if (colDefNoType.suppressRowGroup !== undefined) {\n                console.warn('ag-grid: colDef.suppressRowGroup is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressAggregation !== undefined) {\n                console.warn('ag-grid: colDef.suppressAggregation is deprecated, please use colDef.type instead');\n            }\n            if (colDefNoType.suppressRowGroup || colDefNoType.suppressAggregation) {\n                console.warn('ag-grid: colDef.suppressAggregation and colDef.suppressRowGroup are deprecated, use allowRowGroup, allowPivot and allowValue instead');\n            }\n            if (colDefNoType.displayName) {\n                console.warn(\"ag-grid: Found displayName \" + colDefNoType.displayName + \", please use headerName instead, displayName is deprecated.\");\n                colDefNoType.headerName = colDefNoType.displayName;\n            }\n        }\n    };\n    // if object has children, we assume it's a group\n    ColumnFactory.prototype.isColumnGroup = function (abstractColDef) {\n        return abstractColDef.children !== undefined;\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], ColumnFactory.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('columnUtils')\n    ], ColumnFactory.prototype, \"columnUtils\", void 0);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], ColumnFactory.prototype, \"setBeans\", null);\n    ColumnFactory = __decorate([\n        Bean('columnFactory')\n    ], ColumnFactory);\n    return ColumnFactory;\n}(BeanStub));\nexport { ColumnFactory };\n"]},"metadata":{},"sourceType":"module"}