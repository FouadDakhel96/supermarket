{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\n/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull(value) {\n  return value == null || value === '' ? null : value;\n}\nexport function exists(value, allowEmptyString) {\n  if (allowEmptyString === void 0) {\n    allowEmptyString = false;\n  }\n\n  return value != null && (allowEmptyString || value !== '');\n}\nexport function missing(value) {\n  return !exists(value);\n}\nexport function missingOrEmpty(value) {\n  return !value || missing(value) || value.length === 0;\n}\nexport function toStringOrNull(value) {\n  return exists(value) && value.toString ? value.toString() : null;\n}\n/** @deprecated */\n\nexport function referenceCompare(left, right) {\n  if (left == null && right == null) {\n    return true;\n  }\n\n  if (left == null && right != null) {\n    return false;\n  }\n\n  if (left != null && right == null) {\n    return false;\n  }\n\n  return left === right;\n}\nexport function jsonEquals(val1, val2) {\n  var val1Json = val1 ? JSON.stringify(val1) : null;\n  var val2Json = val2 ? JSON.stringify(val2) : null;\n  return val1Json === val2Json;\n}\nexport function defaultComparator(valueA, valueB, accentedCompare) {\n  if (accentedCompare === void 0) {\n    accentedCompare = false;\n  }\n\n  var valueAMissing = valueA == null;\n  var valueBMissing = valueB == null; // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n  // if we didn't do this, then the toString() value would be used, which would result in\n  // the strings getting used instead of the numbers.\n\n  if (valueA && valueA.toNumber) {\n    valueA = valueA.toNumber();\n  }\n\n  if (valueB && valueB.toNumber) {\n    valueB = valueB.toNumber();\n  }\n\n  if (valueAMissing && valueBMissing) {\n    return 0;\n  }\n\n  if (valueAMissing) {\n    return -1;\n  }\n\n  if (valueBMissing) {\n    return 1;\n  }\n\n  function doQuickCompare(a, b) {\n    return a > b ? 1 : a < b ? -1 : 0;\n  }\n\n  if (typeof valueA === 'string') {\n    if (!accentedCompare) {\n      return doQuickCompare(valueA, valueB);\n    }\n\n    try {\n      // using local compare also allows chinese comparisons\n      return valueA.localeCompare(valueB);\n    } catch (e) {\n      // if something wrong with localeCompare, eg not supported\n      // by browser, then just continue with the quick one\n      return doQuickCompare(valueA, valueB);\n    }\n  }\n\n  return doQuickCompare(valueA, valueB);\n}\nexport function find(collection, predicate, value) {\n  if (collection === null || collection === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(collection)) {\n    var objToArray = values(collection);\n    return find(objToArray, predicate, value);\n  }\n\n  var collectionAsArray = collection;\n  var firstMatchingItem = null;\n\n  for (var i = 0; i < collectionAsArray.length; i++) {\n    var item = collectionAsArray[i];\n\n    if (typeof predicate === 'string') {\n      if (item[predicate] === value) {\n        firstMatchingItem = item;\n        break;\n      }\n    } else {\n      var callback = predicate;\n\n      if (callback(item)) {\n        firstMatchingItem = item;\n        break;\n      }\n    }\n  }\n\n  return firstMatchingItem;\n}\nexport function values(object) {\n  if (object instanceof Set || object instanceof Map) {\n    var values_1 = [];\n    object.forEach(function (value) {\n      return values_1.push(value);\n    });\n    return values_1;\n  }\n\n  return Object.keys(object).map(function (key) {\n    return object[key];\n  });\n}","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/utils/generic.js"],"names":["makeNull","value","exists","allowEmptyString","missing","missingOrEmpty","length","toStringOrNull","toString","referenceCompare","left","right","jsonEquals","val1","val2","val1Json","JSON","stringify","val2Json","defaultComparator","valueA","valueB","accentedCompare","valueAMissing","valueBMissing","toNumber","doQuickCompare","a","b","localeCompare","e","find","collection","predicate","undefined","Array","isArray","objToArray","values","collectionAsArray","firstMatchingItem","i","item","callback","object","Set","Map","values_1","forEach","push","Object","keys","map","key"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n/**\n * If value is undefined, null or blank, returns null, otherwise returns the value\n * @param {T} value\n * @returns {T | null}\n */\nexport function makeNull(value) {\n    return value == null || value === '' ? null : value;\n}\nexport function exists(value, allowEmptyString) {\n    if (allowEmptyString === void 0) { allowEmptyString = false; }\n    return value != null && (allowEmptyString || value !== '');\n}\nexport function missing(value) {\n    return !exists(value);\n}\nexport function missingOrEmpty(value) {\n    return !value || missing(value) || value.length === 0;\n}\nexport function toStringOrNull(value) {\n    return exists(value) && value.toString ? value.toString() : null;\n}\n/** @deprecated */\nexport function referenceCompare(left, right) {\n    if (left == null && right == null) {\n        return true;\n    }\n    if (left == null && right != null) {\n        return false;\n    }\n    if (left != null && right == null) {\n        return false;\n    }\n    return left === right;\n}\nexport function jsonEquals(val1, val2) {\n    var val1Json = val1 ? JSON.stringify(val1) : null;\n    var val2Json = val2 ? JSON.stringify(val2) : null;\n    return val1Json === val2Json;\n}\nexport function defaultComparator(valueA, valueB, accentedCompare) {\n    if (accentedCompare === void 0) { accentedCompare = false; }\n    var valueAMissing = valueA == null;\n    var valueBMissing = valueB == null;\n    // this is for aggregations sum and avg, where the result can be a number that is wrapped.\n    // if we didn't do this, then the toString() value would be used, which would result in\n    // the strings getting used instead of the numbers.\n    if (valueA && valueA.toNumber) {\n        valueA = valueA.toNumber();\n    }\n    if (valueB && valueB.toNumber) {\n        valueB = valueB.toNumber();\n    }\n    if (valueAMissing && valueBMissing) {\n        return 0;\n    }\n    if (valueAMissing) {\n        return -1;\n    }\n    if (valueBMissing) {\n        return 1;\n    }\n    function doQuickCompare(a, b) {\n        return (a > b ? 1 : (a < b ? -1 : 0));\n    }\n    if (typeof valueA === 'string') {\n        if (!accentedCompare) {\n            return doQuickCompare(valueA, valueB);\n        }\n        try {\n            // using local compare also allows chinese comparisons\n            return valueA.localeCompare(valueB);\n        }\n        catch (e) {\n            // if something wrong with localeCompare, eg not supported\n            // by browser, then just continue with the quick one\n            return doQuickCompare(valueA, valueB);\n        }\n    }\n    return doQuickCompare(valueA, valueB);\n}\nexport function find(collection, predicate, value) {\n    if (collection === null || collection === undefined) {\n        return null;\n    }\n    if (!Array.isArray(collection)) {\n        var objToArray = values(collection);\n        return find(objToArray, predicate, value);\n    }\n    var collectionAsArray = collection;\n    var firstMatchingItem = null;\n    for (var i = 0; i < collectionAsArray.length; i++) {\n        var item = collectionAsArray[i];\n        if (typeof predicate === 'string') {\n            if (item[predicate] === value) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n        else {\n            var callback = predicate;\n            if (callback(item)) {\n                firstMatchingItem = item;\n                break;\n            }\n        }\n    }\n    return firstMatchingItem;\n}\nexport function values(object) {\n    if (object instanceof Set || object instanceof Map) {\n        var values_1 = [];\n        object.forEach(function (value) { return values_1.push(value); });\n        return values_1;\n    }\n    return Object.keys(object).map(function (key) { return object[key]; });\n}\n"]},"metadata":{},"sourceType":"module"}