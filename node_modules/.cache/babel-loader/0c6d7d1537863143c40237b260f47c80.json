{"ast":null,"code":"/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __param = this && this.__param || function (paramIndex, decorator) {\n  return function (target, key) {\n    decorator(target, key, paramIndex);\n  };\n};\n\nimport { ColumnGroup } from '../entities/columnGroup';\nimport { Column } from '../entities/column';\nimport { Events } from '../events';\nimport { BeanStub } from \"../context/beanStub\";\nimport { OriginalColumnGroup } from '../entities/originalColumnGroup';\nimport { GroupInstanceIdCreator } from './groupInstanceIdCreator';\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from '../context/context';\nimport { Constants } from '../constants';\nimport { areEqual } from '../utils/array';\nimport { _ } from '../utils';\n\nvar ColumnController =\n/** @class */\nfunction (_super) {\n  __extends(ColumnController, _super);\n\n  function ColumnController() {\n    var _this = _super !== null && _super.apply(this, arguments) || this; // header row count, based on user provided columns\n\n\n    _this.primaryHeaderRowCount = 0;\n    _this.secondaryHeaderRowCount = 0;\n    _this.secondaryColumnsPresent = false; // header row count, either above, or based on pivoting if we are pivoting\n\n    _this.gridHeaderRowCount = 0; // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above\n    // displayed trees, however it also takes into account if the groups are open or not.\n\n    _this.displayedLeftColumns = [];\n    _this.displayedRightColumns = [];\n    _this.displayedCenterColumns = []; // all three lists above combined\n\n    _this.allDisplayedColumns = []; // same as above, except trimmed down to only columns within the viewport\n\n    _this.allDisplayedVirtualColumns = [];\n    _this.allDisplayedCenterVirtualColumns = [];\n    _this.rowGroupColumns = [];\n    _this.valueColumns = [];\n    _this.pivotColumns = [];\n    _this.ready = false;\n    _this.autoGroupsNeedBuilding = false;\n    _this.forceRecreateAutoGroups = false;\n    _this.pivotMode = false;\n    _this.bodyWidth = 0;\n    _this.leftWidth = 0;\n    _this.rightWidth = 0;\n    _this.bodyWidthDirty = true;\n    _this.flexActive = false;\n    return _this;\n  }\n\n  ColumnController.prototype.init = function () {\n    this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n    var pivotMode = this.gridOptionsWrapper.isPivotMode();\n\n    if (this.isPivotSettingAllowed(pivotMode)) {\n      this.pivotMode = pivotMode;\n    }\n\n    this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n    this.addManagedListener(this.gridOptionsWrapper, 'autoGroupColumnDef', this.onAutoGroupColumnDefChanged.bind(this));\n  };\n\n  ColumnController.prototype.onAutoGroupColumnDefChanged = function () {\n    this.autoGroupsNeedBuilding = true;\n    this.forceRecreateAutoGroups = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns('gridOptionsChanged');\n  };\n\n  ColumnController.prototype.setColumnDefs = function (columnDefs, source) {\n    if (source === void 0) {\n      source = 'api';\n    }\n\n    var colsPreviouslyExisted = !!this.columnDefs;\n    this.columnDefs = columnDefs; // always invalidate cache on changing columns, as the column id's for the new columns\n    // could overlap with the old id's, so the cache would return old values for new columns.\n\n    this.valueCache.expire(); // NOTE ==================\n    // we should be destroying the existing columns and groups if they exist, for example, the original column\n    // group adds a listener to the columns, it should be also removing the listeners\n\n    this.autoGroupsNeedBuilding = true;\n    var oldPrimaryColumns = this.primaryColumns;\n    var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryColumns);\n    this.primaryColumnTree = balancedTreeResult.columnTree;\n    this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n    this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    this.extractRowGroupColumns(source, oldPrimaryColumns);\n    this.extractPivotColumns(source, oldPrimaryColumns);\n    this.createValueColumns(source, oldPrimaryColumns);\n    this.ready = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n    this.checkDisplayedVirtualColumns();\n\n    if (this.gridOptionsWrapper.isImmutableColumns() && colsPreviouslyExisted) {\n      this.resetColumnState(true, source);\n    }\n\n    var eventEverythingChanged = {\n      type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(eventEverythingChanged);\n    var newColumnsLoadedEvent = {\n      type: Events.EVENT_NEW_COLUMNS_LOADED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(newColumnsLoadedEvent);\n    this.flexActive = this.getDisplayedCenterColumns().some(function (col) {\n      return !!col.getFlex();\n    });\n  };\n\n  ColumnController.prototype.isAutoRowHeightActive = function () {\n    return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n  };\n\n  ColumnController.prototype.getAllAutoRowHeightCols = function () {\n    return this.autoRowHeightColumns;\n  };\n\n  ColumnController.prototype.setVirtualViewportLeftAndRight = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n      this.viewportRight = this.bodyWidth - this.scrollPosition;\n    } else {\n      this.viewportLeft = this.scrollPosition;\n      this.viewportRight = this.scrollWidth + this.scrollPosition;\n    }\n  }; // used by clipboard service, to know what columns to paste into\n\n\n  ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {\n    var currentColumn = column;\n    var columns = [];\n\n    while (currentColumn != null) {\n      columns.push(currentColumn);\n      currentColumn = this.getDisplayedColAfter(currentColumn);\n    }\n\n    return columns;\n  }; // checks what columns are currently displayed due to column virtualisation. fires an event\n  // if the list of columns has changed.\n  // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n\n\n  ColumnController.prototype.checkDisplayedVirtualColumns = function () {\n    // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n    if (this.displayedCenterColumns == null) {\n      return;\n    }\n\n    var hashBefore = this.allDisplayedVirtualColumns.map(function (column) {\n      return column.getId();\n    }).join('#');\n    this.updateVirtualSets();\n    var hashAfter = this.allDisplayedVirtualColumns.map(function (column) {\n      return column.getId();\n    }).join('#');\n\n    if (hashBefore !== hashAfter) {\n      var event_1 = {\n        type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_1);\n    }\n  };\n\n  ColumnController.prototype.setVirtualViewportPosition = function (scrollWidth, scrollPosition) {\n    if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n      this.scrollWidth = scrollWidth;\n      this.scrollPosition = scrollPosition; // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n      // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n      // virtual columns again\n\n      this.bodyWidthDirty = true;\n      this.setVirtualViewportLeftAndRight();\n\n      if (this.ready) {\n        this.checkDisplayedVirtualColumns();\n      }\n    }\n  };\n\n  ColumnController.prototype.isPivotMode = function () {\n    return this.pivotMode;\n  };\n\n  ColumnController.prototype.isPivotSettingAllowed = function (pivot) {\n    if (pivot && this.gridOptionsWrapper.isTreeData()) {\n      console.warn(\"ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n      return false;\n    }\n\n    return true;\n  };\n\n  ColumnController.prototype.setPivotMode = function (pivotMode, source) {\n    if (source === void 0) {\n      source = 'api';\n    }\n\n    if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {\n      return;\n    }\n\n    this.pivotMode = pivotMode; // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n    // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n    // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n\n    this.autoGroupsNeedBuilding = true;\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n    if (!this.secondaryColumnsPresent || !this.secondaryColumns) {\n      return null;\n    }\n\n    var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n    var foundColumn = null;\n    this.secondaryColumns.forEach(function (column) {\n      var thisPivotKeys = column.getColDef().pivotKeys;\n      var pivotValueColumn = column.getColDef().pivotValueColumn;\n      var pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);\n      var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n\n      if (pivotKeyMatches && pivotValueMatches) {\n        foundColumn = column;\n      }\n    });\n    return foundColumn;\n  };\n\n  ColumnController.prototype.setBeans = function (loggerFactory) {\n    this.logger = loggerFactory.create('ColumnController');\n  };\n\n  ColumnController.prototype.setFirstRightAndLastLeftPinned = function (source) {\n    var lastLeft;\n    var firstRight;\n\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;\n      firstRight = this.displayedRightColumns ? _.last(this.displayedRightColumns) : null;\n    } else {\n      lastLeft = this.displayedLeftColumns ? _.last(this.displayedLeftColumns) : null;\n      firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;\n    }\n\n    this.gridColumns.forEach(function (column) {\n      column.setLastLeftPinned(column === lastLeft, source);\n      column.setFirstRightPinned(column === firstRight, source);\n    });\n  };\n\n  ColumnController.prototype.autoSizeColumns = function (keys, skipHeader, source) {\n    // because of column virtualisation, we can only do this function on columns that are\n    // actually rendered, as non-rendered columns (outside the viewport and not rendered\n    // due to column virtualisation) are not present. this can result in all rendered columns\n    // getting narrowed, which in turn introduces more rendered columns on the RHS which\n    // did not get autosized in the original run, leaving the visible grid with columns on\n    // the LHS sized, but RHS no. so we keep looping through the visible columns until\n    // no more cols are available (rendered) to be resized\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    } // we autosize after animation frames finish in case any cell renderers need to complete first. this can\n    // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid\n    // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).\n\n\n    this.animationFrameService.flushAllFrames(); // keep track of which cols we have resized in here\n\n    var columnsAutosized = []; // initialise with anything except 0 so that while loop executes at least once\n\n    var changesThisTimeAround = -1;\n\n    if (skipHeader == null) {\n      skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n    }\n\n    while (changesThisTimeAround !== 0) {\n      changesThisTimeAround = 0;\n      this.actionOnGridColumns(keys, function (column) {\n        // if already autosized, skip it\n        if (columnsAutosized.indexOf(column) >= 0) {\n          return false;\n        } // get how wide this col should be\n\n\n        var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader); // preferredWidth = -1 if this col is not on the screen\n\n\n        if (preferredWidth > 0) {\n          var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n\n          column.setActualWidth(newWidth, source);\n          columnsAutosized.push(column);\n          changesThisTimeAround++;\n        }\n\n        return true;\n      }, source);\n    }\n\n    if (columnsAutosized.length) {\n      var event_2 = {\n        type: Events.EVENT_COLUMN_RESIZED,\n        columns: columnsAutosized,\n        column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,\n        finished: true,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: \"autosizeColumns\"\n      };\n      this.eventService.dispatchEvent(event_2);\n    }\n  };\n\n  ColumnController.prototype.autoSizeColumn = function (key, skipHeader, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.autoSizeColumns([key], skipHeader, source);\n    }\n  };\n\n  ColumnController.prototype.autoSizeAllColumns = function (skipHeader, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n  };\n\n  ColumnController.prototype.getColumnsFromTree = function (rootColumns) {\n    var result = [];\n\n    var recursiveFindColumns = function (childColumns) {\n      for (var i = 0; i < childColumns.length; i++) {\n        var child = childColumns[i];\n\n        if (child instanceof Column) {\n          result.push(child);\n        } else if (child instanceof OriginalColumnGroup) {\n          recursiveFindColumns(child.getChildren());\n        }\n      }\n    };\n\n    recursiveFindColumns(rootColumns);\n    return result;\n  };\n\n  ColumnController.prototype.getAllDisplayedColumnGroups = function () {\n    if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {\n      return this.displayedLeftColumnTree.concat(this.displayedCentreColumnTree).concat(this.displayedRightColumnTree);\n    }\n\n    return null;\n  }; // + columnSelectPanel\n\n\n  ColumnController.prototype.getPrimaryColumnTree = function () {\n    return this.primaryColumnTree;\n  }; // + gridPanel -> for resizing the body and setting top margin\n\n\n  ColumnController.prototype.getHeaderRowCount = function () {\n    return this.gridHeaderRowCount;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getLeftDisplayedColumnGroups = function () {\n    return this.displayedLeftColumnTree;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getRightDisplayedColumnGroups = function () {\n    return this.displayedRightColumnTree;\n  }; // + headerRenderer -> setting pinned body width\n\n\n  ColumnController.prototype.getCenterDisplayedColumnGroups = function () {\n    return this.displayedCentreColumnTree;\n  };\n\n  ColumnController.prototype.getDisplayedColumnGroups = function (type) {\n    switch (type) {\n      case Constants.PINNED_LEFT:\n        return this.getLeftDisplayedColumnGroups();\n\n      case Constants.PINNED_RIGHT:\n        return this.getRightDisplayedColumnGroups();\n\n      default:\n        return this.getCenterDisplayedColumnGroups();\n    }\n  }; // gridPanel -> ensureColumnVisible\n\n\n  ColumnController.prototype.isColumnDisplayed = function (column) {\n    return this.getAllDisplayedColumns().indexOf(column) >= 0;\n  }; // + csvCreator\n\n\n  ColumnController.prototype.getAllDisplayedColumns = function () {\n    return this.allDisplayedColumns;\n  };\n\n  ColumnController.prototype.getAllDisplayedVirtualColumns = function () {\n    return this.allDisplayedVirtualColumns;\n  };\n\n  ColumnController.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedLeftColumns;\n    }\n\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);\n  };\n\n  ColumnController.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n    if (!this.colSpanActive) {\n      return this.displayedRightColumns;\n    }\n\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);\n  };\n\n  ColumnController.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n    var result = [];\n    var lastConsideredCol = null;\n\n    var _loop_1 = function (i) {\n      var col = displayedColumns[i];\n      var maxAllowedColSpan = displayedColumns.length - i;\n      var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n      var columnsToCheckFilter = [col];\n\n      if (colSpan > 1) {\n        var colsToRemove = colSpan - 1;\n\n        for (var j = 1; j <= colsToRemove; j++) {\n          columnsToCheckFilter.push(displayedColumns[i + j]);\n        }\n\n        i += colsToRemove;\n      } // see which cols we should take out for column virtualisation\n\n\n      var filterPasses;\n\n      if (filterCallback) {\n        // if user provided a callback, means some columns may not be in the viewport.\n        // the user will NOT provide a callback if we are talking about pinned areas,\n        // as pinned areas have no horizontal scroll and do not virtualise the columns.\n        // if lots of columns, that means column spanning, and we set filterPasses = true\n        // if one or more of the columns spanned pass the filter.\n        filterPasses = false;\n        columnsToCheckFilter.forEach(function (colForFilter) {\n          if (filterCallback(colForFilter)) {\n            filterPasses = true;\n          }\n        });\n      } else {\n        filterPasses = true;\n      }\n\n      if (filterPasses) {\n        if (result.length === 0 && lastConsideredCol) {\n          var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n\n          if (gapBeforeColumn) {\n            result.push(lastConsideredCol);\n          }\n        }\n\n        result.push(col);\n      }\n\n      lastConsideredCol = col;\n      out_i_1 = i;\n    };\n\n    var out_i_1;\n\n    for (var i = 0; i < displayedColumns.length; i++) {\n      _loop_1(i);\n\n      i = out_i_1;\n    }\n\n    return result;\n  }; // + rowRenderer\n  // if we are not column spanning, this just returns back the virtual centre columns,\n  // however if we are column spanning, then different rows can have different virtual\n  // columns, so we have to work out the list for each individual row.\n\n\n  ColumnController.prototype.getAllDisplayedCenterVirtualColumnsForRow = function (rowNode) {\n    var _this = this;\n\n    if (!this.colSpanActive) {\n      return this.allDisplayedCenterVirtualColumns;\n    }\n\n    var emptySpaceBeforeColumn = function (col) {\n      return col.getLeft() > _this.viewportLeft;\n    }; // if doing column virtualisation, then we filter based on the viewport.\n\n\n    var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n    return this.getDisplayedColumnsForRow(rowNode, this.displayedCenterColumns, filterCallback, emptySpaceBeforeColumn);\n  };\n\n  ColumnController.prototype.isColumnInViewport = function (col) {\n    var columnLeft = col.getLeft();\n    var columnRight = col.getLeft() + col.getActualWidth(); // adding 200 for buffer size, so some cols off viewport are rendered.\n    // this helps horizontal scrolling so user rarely sees white space (unless\n    // they scroll horizontally fast). however we are conservative, as the more\n    // buffer the slower the vertical redraw speed\n\n    var leftBounds = this.viewportLeft - 200;\n    var rightBounds = this.viewportRight + 200;\n    var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n    var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n    return !columnToMuchLeft && !columnToMuchRight;\n  }; // used by:\n  // + angularGrid -> setting pinned body width\n  // note: this should be cached\n\n\n  ColumnController.prototype.getPinnedLeftContainerWidth = function () {\n    return this.getWidthOfColsInList(this.displayedLeftColumns);\n  }; // note: this should be cached\n\n\n  ColumnController.prototype.getPinnedRightContainerWidth = function () {\n    return this.getWidthOfColsInList(this.displayedRightColumns);\n  };\n\n  ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (!keys || _.missingOrEmpty(keys)) {\n      return;\n    }\n\n    var atLeastOne = false;\n    keys.forEach(function (key) {\n      var columnToAdd = _this.getPrimaryColumn(key);\n\n      if (!columnToAdd) {\n        return;\n      }\n\n      if (actionIsAdd) {\n        if (masterList.indexOf(columnToAdd) >= 0) {\n          return;\n        }\n\n        masterList.push(columnToAdd);\n      } else {\n        if (masterList.indexOf(columnToAdd) < 0) {\n          return;\n        }\n\n        _.removeFromArray(masterList, columnToAdd);\n      }\n\n      columnCallback(columnToAdd);\n      atLeastOne = true;\n    });\n\n    if (!atLeastOne) {\n      return;\n    }\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: eventType,\n      columns: masterList,\n      column: masterList.length === 1 ? masterList[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.setRowGroupColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.setPrimaryColumnList(colKeys, this.rowGroupColumns, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n  };\n\n  ColumnController.prototype.setRowGroupActive = function (active, column, source) {\n    if (active === column.isRowGroupActive()) {\n      return;\n    }\n\n    column.setRowGroupActive(active, source);\n\n    if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n      column.setVisible(true, source);\n    }\n  };\n\n  ColumnController.prototype.addRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.addRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnController.prototype.addRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnController.prototype.removeRowGroupColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.autoGroupsNeedBuilding = true;\n    this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n  };\n\n  ColumnController.prototype.removeRowGroupColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.removeRowGroupColumns([key], source);\n    }\n  };\n\n  ColumnController.prototype.addPivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) {\n      return column.setPivotActive(true, source);\n    }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnController.prototype.setPivotColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n      column.setPivotActive(added, source);\n    }, source);\n  };\n\n  ColumnController.prototype.addPivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.addPivotColumns([key], source);\n  };\n\n  ColumnController.prototype.removePivotColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) {\n      return column.setPivotActive(false, source);\n    }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n  };\n\n  ColumnController.prototype.removePivotColumn = function (key, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removePivotColumns([key], source);\n  };\n\n  ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n    var _this = this;\n\n    masterList.length = 0;\n\n    if (_.exists(colKeys)) {\n      colKeys.forEach(function (key) {\n        var column = _this.getPrimaryColumn(key);\n\n        if (column) {\n          masterList.push(column);\n        }\n      });\n    }\n\n    this.primaryColumns.forEach(function (column) {\n      var added = masterList.indexOf(column) >= 0;\n      columnCallback(added, column);\n    });\n\n    if (this.autoGroupsNeedBuilding) {\n      this.updateGridColumns();\n    }\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: eventName,\n      columns: masterList,\n      column: masterList.length === 1 ? masterList[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.setValueColumns = function (colKeys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setPrimaryColumnList(colKeys, this.valueColumns, Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n  };\n\n  ColumnController.prototype.setValueActive = function (active, column, source) {\n    if (active === column.isValueActive()) {\n      return;\n    }\n\n    column.setValueActive(active, source);\n\n    if (active && !column.getAggFunc()) {\n      var defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n      column.setAggFunc(defaultAggFunc);\n    }\n  };\n\n  ColumnController.prototype.addValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  };\n\n  ColumnController.prototype.addValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (colKey) {\n      this.addValueColumns([colKey], source);\n    }\n  };\n\n  ColumnController.prototype.removeValueColumn = function (colKey, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.removeValueColumns([colKey], source);\n  };\n\n  ColumnController.prototype.removeValueColumns = function (keys, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n  }; // returns the width we can set to this col, taking into consideration min and max widths\n\n\n  ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {\n    if (newWidth < column.getMinWidth()) {\n      newWidth = column.getMinWidth();\n    }\n\n    if (column.isGreaterThanMax(newWidth)) {\n      newWidth = column.getMaxWidth();\n    }\n\n    return newWidth;\n  };\n\n  ColumnController.prototype.getPrimaryOrGridColumn = function (key) {\n    var column = this.getPrimaryColumn(key);\n    return column || this.getGridColumn(key);\n  };\n\n  ColumnController.prototype.setColumnWidths = function (columnWidths, shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n  finished, // @finished - ends up in the event, tells the user if more events are to come\n  source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var sets = [];\n    columnWidths.forEach(function (columnWidth) {\n      var col = _this.getPrimaryOrGridColumn(columnWidth.key);\n\n      if (!col) {\n        return;\n      }\n\n      sets.push({\n        width: columnWidth.newWidth,\n        ratios: [1],\n        columns: [col]\n      }); // if user wants to do shift resize by default, then we invert the shift operation\n\n      var defaultIsShift = _this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n\n      if (defaultIsShift) {\n        shiftKey = !shiftKey;\n      }\n\n      if (shiftKey) {\n        var otherCol = _this.getDisplayedColAfter(col);\n\n        if (!otherCol) {\n          return;\n        }\n\n        var widthDiff = col.getActualWidth() - columnWidth.newWidth;\n        var otherColWidth = otherCol.getActualWidth() + widthDiff;\n        sets.push({\n          width: otherColWidth,\n          ratios: [1],\n          columns: [otherCol]\n        });\n      }\n    });\n\n    if (sets.length === 0) {\n      return;\n    }\n\n    this.resizeColumnSets(sets, finished, source);\n\n    if (this.flexActive) {\n      this.refreshFlexedColumns();\n    }\n  };\n\n  ColumnController.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n    var columns = columnResizeSet.columns,\n        width = columnResizeSet.width; // every col has a min width, so sum them all up and see if we have enough room\n    // for all the min widths\n\n    var minWidthAccumulated = 0;\n    var maxWidthAccumulated = 0;\n    var maxWidthActive = true;\n    columns.forEach(function (col) {\n      minWidthAccumulated += col.getMinWidth();\n\n      if (col.getMaxWidth() > 0) {\n        maxWidthAccumulated += col.getMaxWidth();\n      } else {\n        // if at least one columns has no max width, it means the group of columns\n        // then has no max width, as at least one column can take as much width as possible\n        maxWidthActive = false;\n      }\n    });\n    var minWidthPasses = width >= minWidthAccumulated;\n    var maxWidthPasses = !maxWidthActive || width <= maxWidthAccumulated;\n    return minWidthPasses && maxWidthPasses;\n  }; // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n  // be resized. this is used for example when user tries to resize a group and holds shift key,\n  // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n  // so that's two sets for this method.\n\n\n  ColumnController.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n    var passMinMaxCheck = !resizeSets || resizeSets.every(this.checkMinAndMaxWidthsForSet.bind(this));\n\n    if (!passMinMaxCheck) {\n      // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n      if (finished) {\n        var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n        var event_3 = {\n          type: Events.EVENT_COLUMN_RESIZED,\n          columns: columns,\n          column: columns && columns.length === 1 ? columns[0] : null,\n          finished: finished,\n          api: this.gridApi,\n          columnApi: this.columnApi,\n          source: source\n        };\n        this.eventService.dispatchEvent(event_3);\n      }\n\n      return; // don't resize!\n    }\n\n    var changedCols = [];\n    var allCols = [];\n    resizeSets.forEach(function (set) {\n      var width = set.width,\n          columns = set.columns,\n          ratios = set.ratios; // keep track of pixels used, and last column gets the remaining,\n      // to cater for rounding errors, and min width adjustments\n\n      var newWidths = {};\n      var finishedCols = {};\n      columns.forEach(function (col) {\n        return allCols.push(col);\n      }); // the loop below goes through each col. if a col exceeds it's min/max width,\n      // it then gets set to its min/max width and the column is removed marked as 'finished'\n      // and the calculation is done again leaving this column out. take for example columns\n      // {A, width: 50, maxWidth: 100}\n      // {B, width: 50}\n      // {C, width: 50}\n      // and then the set is set to width 600 - on the first pass the grid tries to set each column\n      // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n      // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n      // splitting the remaining 500 pixels.\n\n      var finishedColsGrew = true;\n      var loopCount = 0;\n\n      var _loop_2 = function () {\n        loopCount++;\n\n        if (loopCount > 1000) {\n          // this should never happen, but in the future, someone might introduce a bug here,\n          // so we stop the browser from hanging and report bug properly\n          console.error('ag-Grid: infinite loop in resizeColumnSets');\n          return \"break\";\n        }\n\n        finishedColsGrew = false;\n        var subsetCols = [];\n        var subsetRatios = [];\n        var subsetRatioTotal = 0;\n        var pixelsToDistribute = width;\n        columns.forEach(function (col, index) {\n          var thisColFinished = finishedCols[col.getId()];\n\n          if (thisColFinished) {\n            pixelsToDistribute -= newWidths[col.getId()];\n          } else {\n            subsetCols.push(col);\n            var ratioThisCol = ratios[index];\n            subsetRatioTotal += ratioThisCol;\n            subsetRatios.push(ratioThisCol);\n          }\n        }); // because we are not using all of the ratios (cols can be missing),\n        // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n        // and so the ratioScale will be 1.\n\n        var ratioScale = 1 / subsetRatioTotal;\n        subsetCols.forEach(function (col, index) {\n          var lastCol = index === subsetCols.length - 1;\n          var colNewWidth;\n\n          if (lastCol) {\n            colNewWidth = pixelsToDistribute;\n          } else {\n            colNewWidth = Math.round(ratios[index] * width * ratioScale);\n            pixelsToDistribute -= colNewWidth;\n          }\n\n          if (colNewWidth < col.getMinWidth()) {\n            colNewWidth = col.getMinWidth();\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          } else if (col.getMaxWidth() > 0 && colNewWidth > col.getMaxWidth()) {\n            colNewWidth = col.getMaxWidth();\n            finishedCols[col.getId()] = true;\n            finishedColsGrew = true;\n          }\n\n          newWidths[col.getId()] = colNewWidth;\n        });\n      };\n\n      while (finishedColsGrew) {\n        var state_1 = _loop_2();\n\n        if (state_1 === \"break\") break;\n      }\n\n      columns.forEach(function (col) {\n        var newWidth = newWidths[col.getId()];\n\n        if (col.getActualWidth() !== newWidth) {\n          col.setActualWidth(newWidth, source);\n          changedCols.push(col);\n        }\n      });\n    }); // if no cols changed, then no need to update more or send event.\n\n    var atLeastOneColChanged = changedCols.length > 0;\n\n    if (atLeastOneColChanged) {\n      this.setLeftValues(source);\n      this.updateBodyWidths();\n      this.checkDisplayedVirtualColumns();\n    } // check for change first, to avoid unnecessary firing of events\n    // however we always fire 'finished' events. this is important\n    // when groups are resized, as if the group is changing slowly,\n    // eg 1 pixel at a time, then each change will fire change events\n    // in all the columns in the group, but only one with get the pixel.\n\n\n    if (atLeastOneColChanged || finished) {\n      var event_4 = {\n        type: Events.EVENT_COLUMN_RESIZED,\n        columns: allCols,\n        column: allCols.length === 1 ? allCols[0] : null,\n        finished: finished,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_4);\n    }\n  };\n\n  ColumnController.prototype.setColumnAggFunc = function (column, aggFunc, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (!column) {\n      return;\n    }\n\n    column.setAggFunc(aggFunc);\n    var event = {\n      type: Events.EVENT_COLUMN_VALUE_CHANGED,\n      columns: [column],\n      column: column,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.rowGroupColumns[fromIndex];\n    this.rowGroupColumns.splice(fromIndex, 1);\n    this.rowGroupColumns.splice(toIndex, 0, column);\n    var event = {\n      type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n      columns: this.rowGroupColumns,\n      column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n\n    if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n      console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n      console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');\n      return;\n    } // we want to pull all the columns out first and put them into an ordered list\n\n\n    var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n    var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n\n    if (failedRules) {\n      return;\n    }\n\n    _.moveInArray(this.gridColumns, columnsToMove, toIndex);\n\n    this.updateDisplayedColumns(source);\n    var event = {\n      type: Events.EVENT_COLUMN_MOVED,\n      columns: columnsToMove,\n      column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n      toIndex: toIndex,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n    this.columnAnimationService.finish();\n  };\n\n  ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n    // make a copy of what the grid columns would look like after the move\n    var proposedColumnOrder = this.gridColumns.slice();\n\n    _.moveInArray(proposedColumnOrder, columnsToMove, toIndex); // then check that the new proposed order of the columns passes all rules\n\n\n    if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n      return false;\n    }\n\n    if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n      return false;\n    }\n\n    return true;\n  };\n\n  ColumnController.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n    var foundNonLocked = false;\n    var rulePassed = true; // go though the cols, see if any non-locked appear before any locked\n\n    proposedColumnOrder.forEach(function (col) {\n      if (col.getColDef().lockPosition) {\n        if (foundNonLocked) {\n          rulePassed = false;\n        }\n      } else {\n        foundNonLocked = true;\n      }\n    });\n    return rulePassed;\n  };\n\n  ColumnController.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n    var rulePassed = true;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n      if (!(child instanceof OriginalColumnGroup)) {\n        return;\n      }\n\n      var columnGroup = child;\n      var marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;\n\n      if (!marryChildren) {\n        return;\n      }\n\n      var newIndexes = [];\n      columnGroup.getLeafColumns().forEach(function (col) {\n        var newColIndex = allColumnsCopy.indexOf(col);\n        newIndexes.push(newColIndex);\n      });\n      var maxIndex = Math.max.apply(Math, newIndexes);\n      var minIndex = Math.min.apply(Math, newIndexes); // spread is how far the first column in this group is away from the last column\n\n      var spread = maxIndex - minIndex;\n      var maxSpread = columnGroup.getLeafColumns().length - 1; // if the columns\n\n      if (spread > maxSpread) {\n        rulePassed = false;\n      } // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n      // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n\n    });\n    return rulePassed;\n  };\n\n  ColumnController.prototype.moveColumn = function (key, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.moveColumns([key], toIndex, source);\n  };\n\n  ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var column = this.gridColumns[fromIndex];\n    this.moveColumn(column, toIndex, source);\n  }; // used by:\n  // + angularGrid -> for setting body width\n  // + rowController -> setting main row widths (when inserting and resizing)\n  // need to cache this\n\n\n  ColumnController.prototype.getBodyContainerWidth = function () {\n    return this.bodyWidth;\n  };\n\n  ColumnController.prototype.getContainerWidth = function (pinned) {\n    switch (pinned) {\n      case Constants.PINNED_LEFT:\n        return this.leftWidth;\n\n      case Constants.PINNED_RIGHT:\n        return this.rightWidth;\n\n      default:\n        return this.bodyWidth;\n    }\n  }; // after setColumnWidth or updateGroupsAndDisplayedColumns\n\n\n  ColumnController.prototype.updateBodyWidths = function () {\n    var newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);\n    var newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);\n    var newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns); // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n    // columns, due to RTL inverting the y coordinates\n\n    this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n    var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n\n    if (atLeastOneChanged) {\n      this.bodyWidth = newBodyWidth;\n      this.leftWidth = newLeftWidth;\n      this.rightWidth = newRightWidth; // when this fires, it is picked up by the gridPanel, which ends up in\n      // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()\n\n      var event_5 = {\n        type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi\n      };\n      this.eventService.dispatchEvent(event_5);\n    }\n  }; // + rowController\n\n\n  ColumnController.prototype.getValueColumns = function () {\n    return this.valueColumns ? this.valueColumns : [];\n  }; // + rowController\n\n\n  ColumnController.prototype.getPivotColumns = function () {\n    return this.pivotColumns ? this.pivotColumns : [];\n  }; // + clientSideRowModel\n\n\n  ColumnController.prototype.isPivotActive = function () {\n    return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n  }; // + toolPanel\n\n\n  ColumnController.prototype.getRowGroupColumns = function () {\n    return this.rowGroupColumns ? this.rowGroupColumns : [];\n  }; // + rowController -> while inserting rows\n\n\n  ColumnController.prototype.getDisplayedCenterColumns = function () {\n    return this.displayedCenterColumns;\n  }; // + rowController -> while inserting rows\n\n\n  ColumnController.prototype.getDisplayedLeftColumns = function () {\n    return this.displayedLeftColumns;\n  };\n\n  ColumnController.prototype.getDisplayedRightColumns = function () {\n    return this.displayedRightColumns;\n  };\n\n  ColumnController.prototype.getDisplayedColumns = function (type) {\n    switch (type) {\n      case Constants.PINNED_LEFT:\n        return this.getDisplayedLeftColumns();\n\n      case Constants.PINNED_RIGHT:\n        return this.getDisplayedRightColumns();\n\n      default:\n        return this.getDisplayedCenterColumns();\n    }\n  }; // used by:\n  // + clientSideRowController -> sorting, building quick filter text\n  // + headerRenderer -> sorting (clearing icon)\n\n\n  ColumnController.prototype.getAllPrimaryColumns = function () {\n    return this.primaryColumns ? this.primaryColumns.slice() : null;\n  };\n\n  ColumnController.prototype.getSecondaryColumns = function () {\n    return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n  };\n\n  ColumnController.prototype.getAllColumnsForQuickFilter = function () {\n    return this.columnsForQuickFilter;\n  }; // + moveColumnController\n\n\n  ColumnController.prototype.getAllGridColumns = function () {\n    return this.gridColumns;\n  };\n\n  ColumnController.prototype.isEmpty = function () {\n    return _.missingOrEmpty(this.gridColumns);\n  };\n\n  ColumnController.prototype.isRowGroupEmpty = function () {\n    return _.missingOrEmpty(this.rowGroupColumns);\n  };\n\n  ColumnController.prototype.setColumnVisible = function (key, visible, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.setColumnsVisible([key], visible, source);\n  };\n\n  ColumnController.prototype.setColumnsVisible = function (keys, visible, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    this.actionOnGridColumns(keys, function (column) {\n      if (column.isVisible() !== visible) {\n        column.setVisible(visible, source);\n        return true;\n      }\n\n      return false;\n    }, source, function () {\n      var event = {\n        type: Events.EVENT_COLUMN_VISIBLE,\n        visible: visible,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  };\n\n  ColumnController.prototype.setColumnPinned = function (key, pinned, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (key) {\n      this.setColumnsPinned([key], pinned, source);\n    }\n  };\n\n  ColumnController.prototype.setColumnsPinned = function (keys, pinned, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n      console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n      return;\n    }\n\n    this.columnAnimationService.start();\n    var actualPinned;\n\n    if (pinned === true || pinned === Constants.PINNED_LEFT) {\n      actualPinned = Constants.PINNED_LEFT;\n    } else if (pinned === Constants.PINNED_RIGHT) {\n      actualPinned = Constants.PINNED_RIGHT;\n    } else {\n      actualPinned = null;\n    }\n\n    this.actionOnGridColumns(keys, function (col) {\n      if (col.getPinned() !== actualPinned) {\n        col.setPinned(actualPinned);\n        return true;\n      }\n\n      return false;\n    }, source, function () {\n      var event = {\n        type: Events.EVENT_COLUMN_PINNED,\n        pinned: actualPinned,\n        column: null,\n        columns: null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n      return event;\n    });\n    this.columnAnimationService.finish();\n  }; // does an action on a set of columns. provides common functionality for looking up the\n  // columns based on key, getting a list of effected columns, and then updated the event\n  // with either one column (if it was just one col) or a list of columns\n  // used by: autoResize, setVisible, setPinned\n\n\n  ColumnController.prototype.actionOnGridColumns = function ( // the column keys this action will be on\n  keys, // the action to do - if this returns false, the column was skipped\n  // and won't be included in the event\n  action, // should return back a column event of the right type\n  source, createEvent) {\n    var _this = this;\n\n    if (_.missingOrEmpty(keys)) {\n      return;\n    }\n\n    var updatedColumns = [];\n    keys.forEach(function (key) {\n      var column = _this.getGridColumn(key);\n\n      if (!column) {\n        return;\n      } // need to check for false with type (ie !== instead of !=)\n      // as not returning anything (undefined) would also be false\n\n\n      var resultOfAction = action(column);\n\n      if (resultOfAction !== false) {\n        updatedColumns.push(column);\n      }\n    });\n\n    if (!updatedColumns.length) {\n      return;\n    }\n\n    this.updateDisplayedColumns(source);\n\n    if (_.exists(createEvent) && createEvent) {\n      var event_6 = createEvent();\n      event_6.columns = updatedColumns;\n      event_6.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n      this.eventService.dispatchEvent(event_6);\n    }\n  };\n\n  ColumnController.prototype.getDisplayedColBefore = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex > 0) {\n      return allDisplayedColumns[oldIndex - 1];\n    }\n\n    return null;\n  }; // used by:\n  // + rowRenderer -> for navigation\n\n\n  ColumnController.prototype.getDisplayedColAfter = function (col) {\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n    var oldIndex = allDisplayedColumns.indexOf(col);\n\n    if (oldIndex < allDisplayedColumns.length - 1) {\n      return allDisplayedColumns[oldIndex + 1];\n    }\n\n    return null;\n  };\n\n  ColumnController.prototype.getDisplayedGroupAfter = function (columnGroup) {\n    return this.getDisplayedGroupAtDirection(columnGroup, 'After');\n  };\n\n  ColumnController.prototype.getDisplayedGroupBefore = function (columnGroup) {\n    return this.getDisplayedGroupAtDirection(columnGroup, 'Before');\n  };\n\n  ColumnController.prototype.getDisplayedGroupAtDirection = function (columnGroup, direction) {\n    // pick the last displayed column in this group\n    var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel() + columnGroup.getPaddingLevel();\n    var colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();\n    var col = direction === 'After' ? _.last(colGroupLeafColumns) : colGroupLeafColumns[0];\n    var getDisplayColMethod = \"getDisplayedCol\" + direction;\n\n    while (true) {\n      // keep moving to the next col, until we get to another group\n      var column = this[getDisplayColMethod](col);\n\n      if (!column) {\n        return null;\n      }\n\n      var groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);\n\n      if (groupPointer !== columnGroup) {\n        return groupPointer;\n      }\n    }\n  };\n\n  ColumnController.prototype.getColumnGroupAtLevel = function (column, level) {\n    // get group at same level as the one we are looking for\n    var groupPointer = column.getParent();\n    var originalGroupLevel;\n    var groupPointerLevel;\n\n    while (true) {\n      var groupPointerOriginalColumnGroup = groupPointer.getOriginalColumnGroup();\n      originalGroupLevel = groupPointerOriginalColumnGroup.getLevel();\n      groupPointerLevel = groupPointer.getPaddingLevel();\n\n      if (originalGroupLevel + groupPointerLevel <= level) {\n        break;\n      }\n\n      groupPointer = groupPointer.getParent();\n    }\n\n    return groupPointer;\n  };\n\n  ColumnController.prototype.isPinningLeft = function () {\n    return this.displayedLeftColumns.length > 0;\n  };\n\n  ColumnController.prototype.isPinningRight = function () {\n    return this.displayedRightColumns.length > 0;\n  };\n\n  ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n    var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n\n    if (this.groupAutoColumns && _.exists(this.groupAutoColumns)) {\n      this.groupAutoColumns.forEach(function (col) {\n        return result.push(col);\n      });\n    }\n\n    if (this.secondaryColumnsPresent && this.secondaryColumns) {\n      this.secondaryColumns.forEach(function (column) {\n        return result.push(column);\n      });\n    }\n\n    return result;\n  };\n\n  ColumnController.prototype.createStateItemFromColumn = function (column) {\n    var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n    var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n    var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n    return {\n      colId: column.getColId(),\n      hide: !column.isVisible(),\n      aggFunc: aggFunc,\n      width: column.getActualWidth(),\n      pivotIndex: pivotIndex,\n      pinned: column.getPinned(),\n      rowGroupIndex: rowGroupIndex,\n      flex: column.getFlex()\n    };\n  };\n\n  ColumnController.prototype.getColumnState = function () {\n    if (_.missing(this.primaryColumns)) {\n      return [];\n    }\n\n    var primaryColumnState = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n    var groupAutoColumnState = this.groupAutoColumns // if groupAutoCols, then include them\n    ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this)) // otherwise no\n    : [];\n    var columnStateList = groupAutoColumnState.concat(primaryColumnState);\n\n    if (!this.pivotMode) {\n      this.orderColumnStateList(columnStateList);\n    }\n\n    return columnStateList;\n  };\n\n  ColumnController.prototype.orderColumnStateList = function (columnStateList) {\n    var gridColumnIds = this.gridColumns.map(function (column) {\n      return column.getColId();\n    });\n    columnStateList.sort(function (itemA, itemB) {\n      var posA = gridColumnIds.indexOf(itemA.colId);\n      var posB = gridColumnIds.indexOf(itemB.colId);\n      return posA - posB;\n    });\n  };\n\n  ColumnController.prototype.resetColumnState = function (suppressEverythingEvent, source) {\n    // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n    // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n    // As a work around, developers should just put lockPosition columns first in their colDef list.\n    if (suppressEverythingEvent === void 0) {\n      suppressEverythingEvent = false;\n    }\n\n    if (source === void 0) {\n      source = \"api\";\n    } // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n\n\n    var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n    var columnStates = []; // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n    // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n    // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n\n    var letRowGroupIndex = 1000;\n    var letPivotIndex = 1000;\n\n    if (primaryColumns) {\n      primaryColumns.forEach(function (column) {\n        var rowGroupIndex = column.getColDef().rowGroupIndex;\n        var rowGroup = column.getColDef().rowGroup;\n        var pivotIndex = column.getColDef().pivotIndex;\n        var pivot = column.getColDef().pivot;\n        var stateItem = {\n          colId: column.getColId(),\n          aggFunc: column.getColDef().aggFunc,\n          hide: column.getColDef().hide,\n          pinned: column.getColDef().pinned,\n          rowGroupIndex: rowGroupIndex,\n          pivotIndex: column.getColDef().pivotIndex,\n          width: column.getColDef().width\n        };\n\n        if (_.missing(rowGroupIndex) && rowGroup) {\n          stateItem.rowGroupIndex = letRowGroupIndex++;\n        }\n\n        if (_.missing(pivotIndex) && pivot) {\n          stateItem.pivotIndex = letPivotIndex++;\n        }\n\n        columnStates.push(stateItem);\n      });\n    }\n\n    this.setColumnState(columnStates, suppressEverythingEvent, source);\n  };\n\n  ColumnController.prototype.setColumnState = function (columnStates, suppressEverythingEvent, source) {\n    var _this = this;\n\n    if (suppressEverythingEvent === void 0) {\n      suppressEverythingEvent = false;\n    }\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    if (_.missingOrEmpty(this.primaryColumns)) {\n      return false;\n    }\n\n    var columnStateBefore = this.getColumnState();\n    this.autoGroupsNeedBuilding = true; // at the end below, this list will have all columns we got no state for\n\n    var columnsWithNoState = this.primaryColumns.slice();\n    this.rowGroupColumns = [];\n    this.valueColumns = [];\n    this.pivotColumns = [];\n    var success = true;\n    var rowGroupIndexes = {};\n    var pivotIndexes = {};\n    var autoGroupColumnStates = [];\n\n    if (columnStates) {\n      columnStates.forEach(function (state) {\n        // auto group columns are re-created so deferring syncing with ColumnState\n        if (_.exists(_this.getAutoColumn(state.colId))) {\n          autoGroupColumnStates.push(state);\n          return;\n        }\n\n        var column = _this.getPrimaryColumn(state.colId);\n\n        if (!column) {\n          console.warn('ag-grid: column ' + state.colId + ' not found');\n          success = false;\n        } else {\n          _this.syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, source);\n\n          _.removeFromArray(columnsWithNoState, column);\n        }\n      });\n\n      if (this.flexActive) {\n        this.refreshFlexedColumns(undefined, undefined, true);\n      }\n    } // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n\n\n    columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this)); // sort the lists according to the indexes that were provided\n\n    this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));\n    this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));\n    this.updateGridColumns(); // sync newly created auto group columns with ColumnState\n\n    autoGroupColumnStates.forEach(function (stateItem) {\n      var autoCol = _this.getAutoColumn(stateItem.colId);\n\n      _this.syncColumnWithStateItem(autoCol, stateItem, rowGroupIndexes, pivotIndexes, source);\n    });\n\n    if (columnStates) {\n      var orderOfColIds_1 = columnStates.map(function (stateItem) {\n        return stateItem.colId;\n      });\n      this.gridColumns.sort(function (colA, colB) {\n        var indexA = orderOfColIds_1.indexOf(colA.getId());\n        var indexB = orderOfColIds_1.indexOf(colB.getId());\n        return indexA - indexB;\n      });\n    } // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n    // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n    // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n    // is less sexy for the code here, but it keeps consistency.\n\n\n    this.putFixedColumnsFirst();\n    this.updateDisplayedColumns(source);\n\n    if (!suppressEverythingEvent) {\n      var event_7 = {\n        type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n        api: this.gridApi,\n        columnApi: this.columnApi,\n        source: source\n      };\n      this.eventService.dispatchEvent(event_7);\n    }\n\n    this.raiseColumnEvents(columnStateBefore, source);\n    return success;\n  };\n\n  ColumnController.prototype.raiseColumnEvents = function (columnStateBefore, source) {\n    var _this = this;\n\n    if (this.gridOptionsWrapper.isSuppressSetColumnStateEvents()) {\n      return;\n    }\n\n    var columnStateAfter = this.getColumnState(); // raises generic ColumnEvents where all columns are returned rather than what has changed\n\n    var raiseEventWithAllColumns = function (eventType, idMapper, columns) {\n      var unchanged = areEqual(columnStateBefore.map(idMapper).sort(), columnStateAfter.map(idMapper).sort());\n\n      if (unchanged) {\n        return;\n      } // returning all columns rather than what has changed!\n\n\n      var event = {\n        type: eventType,\n        columns: columns,\n        column: columns.length === 1 ? columns[0] : null,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n\n      _this.eventService.dispatchEvent(event);\n    }; // determines which columns have changed according to supplied predicate\n\n\n    var getChangedColumns = function (changedPredicate) {\n      var changedColumns = [];\n      var columnStateBeforeMap = {};\n      columnStateBefore.forEach(function (col) {\n        columnStateBeforeMap[col.colId] = col;\n      });\n\n      _this.gridColumns.forEach(function (column) {\n        var colStateBefore = columnStateBeforeMap[column.getColId()];\n\n        if (!colStateBefore || changedPredicate(colStateBefore, column)) {\n          changedColumns.push(column);\n        }\n      });\n\n      return changedColumns;\n    }; // generic ColumnEvents which return current column list\n\n\n    var valueColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.aggFunc;\n    };\n\n    raiseEventWithAllColumns(Events.EVENT_COLUMN_VALUE_CHANGED, valueColumnIdMapper, this.valueColumns);\n\n    var pivotColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.pivotIndex;\n    };\n\n    raiseEventWithAllColumns(Events.EVENT_COLUMN_PIVOT_CHANGED, pivotColumnIdMapper, this.pivotColumns);\n\n    var rowGroupColumnIdMapper = function (cs) {\n      return cs.colId + '-' + cs.rowGroupIndex;\n    };\n\n    raiseEventWithAllColumns(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, rowGroupColumnIdMapper, this.rowGroupColumns); // specific ColumnEvents which return what's changed\n\n    var pinnedChangePredicate = function (cs, c) {\n      return cs.pinned !== c.getPinned();\n    };\n\n    this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n\n    var visibilityChangePredicate = function (cs, c) {\n      return cs.hide === c.isVisible();\n    };\n\n    var cols = getChangedColumns(visibilityChangePredicate);\n    this.raiseColumnVisibleEvent(cols, source);\n\n    var resizeChangePredicate = function (cs, c) {\n      return cs.width !== c.getActualWidth();\n    };\n\n    this.raiseColumnResizeEvent(getChangedColumns(resizeChangePredicate), source); // special handling for moved column events\n\n    this.raiseColumnMovedEvent(columnStateBefore, source);\n  };\n\n  ColumnController.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n    if (!changedColumns.length) {\n      return;\n    }\n\n    var event = {\n      type: Events.EVENT_COLUMN_PINNED,\n      pinned: null,\n      columns: changedColumns,\n      column: null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n    if (!changedColumns.length) {\n      return;\n    }\n\n    var event = {\n      type: Events.EVENT_COLUMN_VISIBLE,\n      visible: undefined,\n      columns: changedColumns,\n      column: null,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.raiseColumnResizeEvent = function (changedColumns, source) {\n    if (!changedColumns.length) {\n      return;\n    }\n\n    var event = {\n      type: Events.EVENT_COLUMN_RESIZED,\n      columns: changedColumns,\n      column: null,\n      finished: true,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.raiseColumnMovedEvent = function (columnStateBefore, source) {\n    var movedColumns = [];\n    var columnStateAfter = this.getColumnState();\n\n    var _loop_3 = function (i) {\n      var before = columnStateBefore[i];\n      var after = columnStateAfter[i]; // don't consider column if reintroduced or hidden\n\n      if (!before || after.hide) {\n        return \"continue\";\n      }\n\n      if (before.colId !== after.colId) {\n        var predicate = function (column) {\n          return column.getColId() === after.colId;\n        };\n\n        var movedColumn = _.find(this_1.allDisplayedColumns, predicate);\n\n        movedColumns.push(movedColumn);\n      }\n    };\n\n    var this_1 = this;\n\n    for (var i = 0; i < columnStateAfter.length; i++) {\n      _loop_3(i);\n    }\n\n    if (!movedColumns.length) {\n      return;\n    }\n\n    var event = {\n      type: Events.EVENT_COLUMN_MOVED,\n      columns: movedColumns,\n      column: null,\n      toIndex: undefined,\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      source: source\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {\n    var indexA = indexes[colA.getId()];\n    var indexB = indexes[colB.getId()];\n    return indexA - indexB;\n  };\n\n  ColumnController.prototype.syncColumnWithNoState = function (column, source) {\n    column.setVisible(false, source);\n    column.setAggFunc(null);\n    column.setPinned(null);\n    column.setRowGroupActive(false, source);\n    column.setPivotActive(false, source);\n    column.setValueActive(false, source);\n  };\n\n  ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes, source) {\n    if (!column) {\n      return;\n    } // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n\n\n    column.setVisible(!stateItem.hide, source); // sets pinned to 'left' or 'right'\n\n    column.setPinned(stateItem.pinned); // if width provided and valid, use it, otherwise stick with the old width\n\n    var minColWidth = this.gridOptionsWrapper.getMinColWidth();\n\n    if (stateItem.flex != null) {\n      column.setFlex(stateItem.flex);\n\n      if (!this.flexActive && stateItem.flex) {\n        this.flexActive = true;\n      }\n    }\n\n    if (stateItem.width && minColWidth && stateItem.width >= minColWidth) {\n      column.setActualWidth(stateItem.width, source);\n    }\n\n    if (typeof stateItem.aggFunc === 'string') {\n      column.setAggFunc(stateItem.aggFunc);\n      column.setValueActive(true, source);\n      this.valueColumns.push(column);\n    } else {\n      if (_.exists(stateItem.aggFunc)) {\n        console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' + 'functions, register the functions first before using them in get/set state. This is because it is ' + 'intended for the column state to be stored and retrieved as simple JSON.');\n      }\n\n      column.setAggFunc(null);\n      column.setValueActive(false, source);\n    }\n\n    if (typeof stateItem.rowGroupIndex === 'number') {\n      this.rowGroupColumns.push(column);\n      column.setRowGroupActive(true, source);\n      rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;\n    } else {\n      column.setRowGroupActive(false, source);\n    }\n\n    if (typeof stateItem.pivotIndex === 'number') {\n      this.pivotColumns.push(column);\n      column.setPivotActive(true, source);\n      pivotIndexes[column.getId()] = stateItem.pivotIndex;\n    } else {\n      column.setPivotActive(false, source);\n    }\n  };\n\n  ColumnController.prototype.getGridColumns = function (keys) {\n    return this.getColumns(keys, this.getGridColumn.bind(this));\n  };\n\n  ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {\n    var foundColumns = [];\n\n    if (keys) {\n      keys.forEach(function (key) {\n        var column = columnLookupCallback(key);\n\n        if (column) {\n          foundColumns.push(column);\n        }\n      });\n    }\n\n    return foundColumns;\n  }; // used by growGroupPanel\n\n\n  ColumnController.prototype.getColumnWithValidation = function (key) {\n    if (key == null) {\n      return null;\n    }\n\n    var column = this.getGridColumn(key);\n\n    if (!column) {\n      console.warn('ag-Grid: could not find column ' + key);\n    }\n\n    return column;\n  };\n\n  ColumnController.prototype.getPrimaryColumn = function (key) {\n    return this.getColumn(key, this.primaryColumns);\n  };\n\n  ColumnController.prototype.getGridColumn = function (key) {\n    return this.getColumn(key, this.gridColumns);\n  };\n\n  ColumnController.prototype.getColumn = function (key, columnList) {\n    if (!key) {\n      return null;\n    }\n\n    for (var i = 0; i < columnList.length; i++) {\n      if (this.columnsMatch(columnList[i], key)) {\n        return columnList[i];\n      }\n    }\n\n    return this.getAutoColumn(key);\n  };\n\n  ColumnController.prototype.getAutoColumn = function (key) {\n    var _this = this;\n\n    if (!this.groupAutoColumns || !_.exists(this.groupAutoColumns) || _.missing(this.groupAutoColumns)) {\n      return null;\n    }\n\n    return _.find(this.groupAutoColumns, function (groupCol) {\n      return _this.columnsMatch(groupCol, key);\n    });\n  };\n\n  ColumnController.prototype.columnsMatch = function (column, key) {\n    var columnMatches = column === key;\n    var colDefMatches = column.getColDef() === key;\n    var idMatches = column.getColId() == key;\n    return columnMatches || colDefMatches || idMatches;\n  };\n\n  ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n    if (includeAggFunc === void 0) {\n      includeAggFunc = false;\n    }\n\n    if (!column) {\n      return null;\n    }\n\n    var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n\n    if (includeAggFunc) {\n      return this.wrapHeaderNameWithAggFunc(column, headerName);\n    }\n\n    return headerName;\n  };\n\n  ColumnController.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n    var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n\n    if (colGroupDef) {\n      return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n    }\n\n    return null;\n  };\n\n  ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n    return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n  }; // location is where the column is going to appear, ie who is calling us\n\n\n  ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n    var headerValueGetter = colDef.headerValueGetter;\n\n    if (headerValueGetter) {\n      var params = {\n        colDef: colDef,\n        column: column,\n        columnGroup: columnGroup,\n        originalColumnGroup: originalColumnGroup,\n        location: location,\n        api: this.gridOptionsWrapper.getApi(),\n        context: this.gridOptionsWrapper.getContext()\n      };\n\n      if (typeof headerValueGetter === 'function') {\n        // valueGetter is a function, so just call it\n        return headerValueGetter(params);\n      } else if (typeof headerValueGetter === 'string') {\n        // valueGetter is an expression, so execute the expression\n        return this.expressionService.evaluate(headerValueGetter, params);\n      }\n\n      console.warn('ag-grid: headerValueGetter must be a function or a string');\n      return '';\n    } else if (colDef.headerName != null) {\n      return colDef.headerName;\n    } else if (colDef.field) {\n      return _.camelCaseToHumanText(colDef.field);\n    }\n\n    return '';\n  };\n  /*\n      private getHeaderGroupName(columnGroup: ColumnGroup): string {\n          let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n          let headerValueGetter = colGroupDef.headerValueGetter;\n           if (headerValueGetter) {\n              let params = {\n                  columnGroup: columnGroup,\n                  colDef: colGroupDef,\n                  api: this.gridOptionsWrapper.getApi(),\n                  context: this.gridOptionsWrapper.getContext()\n              };\n               if (typeof headerValueGetter === 'function') {\n                  // valueGetter is a function, so just call it\n                  return headerValueGetter(params);\n              } else if (typeof headerValueGetter === 'string') {\n                  // valueGetter is an expression, so execute the expression\n                  return this.expressionService.evaluate(headerValueGetter, params);\n              } else {\n                  console.warn('ag-grid: headerValueGetter must be a function or a string');\n                  return '';\n              }\n          } else {\n              return colGroupDef.headerName;\n          }\n      }\n  */\n\n\n  ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n    if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n      return headerName;\n    } // only columns with aggregation active can have aggregations\n\n\n    var pivotValueColumn = column.getColDef().pivotValueColumn;\n\n    var pivotActiveOnThisColumn = _.exists(pivotValueColumn);\n\n    var aggFunc = null;\n    var aggFuncFound; // otherwise we have a measure that is active, and we are doing aggregation on it\n\n    if (pivotActiveOnThisColumn) {\n      aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n      aggFuncFound = true;\n    } else {\n      var measureActive = column.isValueActive();\n      var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n\n      if (measureActive && aggregationPresent) {\n        aggFunc = column.getAggFunc();\n        aggFuncFound = true;\n      } else {\n        aggFuncFound = false;\n      }\n    }\n\n    if (aggFuncFound) {\n      var aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'func';\n      var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n      var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n      return aggFuncStringTranslated + \"(\" + headerName + \")\";\n    }\n\n    return headerName;\n  }; // returns the group with matching colId and instanceId. If instanceId is missing,\n  // matches only on the colId.\n\n\n  ColumnController.prototype.getColumnGroup = function (colId, instanceId) {\n    if (!colId) {\n      return null;\n    }\n\n    if (colId instanceof ColumnGroup) {\n      return colId;\n    }\n\n    var allColumnGroups = this.getAllDisplayedColumnGroups();\n    var checkInstanceId = typeof instanceId === 'number';\n    var result = null;\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof ColumnGroup) {\n        var columnGroup = child;\n        var matched = void 0;\n\n        if (checkInstanceId) {\n          matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n        } else {\n          matched = colId === columnGroup.getGroupId();\n        }\n\n        if (matched) {\n          result = columnGroup;\n        }\n      }\n    });\n    return result;\n  };\n\n  ColumnController.prototype.isReady = function () {\n    return this.ready;\n  };\n\n  ColumnController.prototype.createValueColumns = function (source, oldPrimaryColumns) {\n    this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) {\n      return col.setValueActive(flag, source);\n    }, // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n    function () {\n      return null;\n    }, // aggFunc is a string, so return it's existence\n    function (colDef) {\n      return !!colDef.aggFunc;\n    }); // all new columns added will have aggFunc missing, so set it to what is in the colDef\n\n    this.valueColumns.forEach(function (col) {\n      if (!col.getAggFunc()) {\n        col.setAggFunc(col.getColDef().aggFunc);\n      }\n    });\n  };\n\n  ColumnController.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n    this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) {\n      return col.setRowGroupActive(flag, source);\n    }, function (colDef) {\n      return colDef.rowGroupIndex;\n    }, function (colDef) {\n      return colDef.rowGroup;\n    });\n  };\n\n  ColumnController.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getValueFunc) {\n    var _this = this;\n\n    if (!previousCols) {\n      previousCols = [];\n    } // remove cols that no longer exist\n\n\n    var colPresentInPrimaryFunc = function (col) {\n      return _this.primaryColumns.indexOf(col) >= 0;\n    };\n\n    var colMissingFromPrimaryFunc = function (col) {\n      return _this.primaryColumns.indexOf(col) < 0;\n    };\n\n    var colNewFunc = function (col) {\n      return !oldPrimaryColumns || oldPrimaryColumns.indexOf(col) < 0;\n    };\n\n    var removedCols = previousCols.filter(colMissingFromPrimaryFunc);\n    var existingCols = previousCols.filter(colPresentInPrimaryFunc);\n    var newPrimaryCols = this.primaryColumns.filter(colNewFunc);\n    removedCols.forEach(function (col) {\n      return setFlagFunc(col, false);\n    });\n    var newCols = []; // we only want to work on new columns, as old columns already got processed first time around\n    // pull out items with xxxIndex\n\n    newPrimaryCols.forEach(function (col) {\n      var index = getIndexFunc(col.getColDef());\n\n      if (typeof index === 'number') {\n        newCols.push(col);\n      }\n    }); // then sort them\n\n    newCols.sort(function (colA, colB) {\n      var indexA = getIndexFunc(colA.getColDef());\n      var indexB = getIndexFunc(colB.getColDef());\n\n      if (indexA === indexB) {\n        return 0;\n      } else if (indexA < indexB) {\n        return -1;\n      }\n\n      return 1;\n    }); // now just pull out items xxx (boolean value), they will be added at the end\n    // after the indexed ones, but in the order the columns appear\n\n    newPrimaryCols.forEach(function (col) {\n      var booleanValue = getValueFunc(col.getColDef());\n\n      if (booleanValue) {\n        // if user already specified xxxIndex then we skip it as this col already included\n        if (newCols.indexOf(col) >= 0) {\n          return;\n        }\n\n        newCols.push(col);\n      }\n    });\n    newCols.forEach(function (col) {\n      return setFlagFunc(col, true);\n    });\n    var res = existingCols.concat(newCols);\n    return res;\n  };\n\n  ColumnController.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n    this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) {\n      return col.setPivotActive(flag, source);\n    }, function (colDef) {\n      return colDef.pivotIndex;\n    }, function (colDef) {\n      return colDef.pivot;\n    });\n  };\n\n  ColumnController.prototype.resetColumnGroupState = function (source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var stateItems = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n      if (child instanceof OriginalColumnGroup) {\n        var groupState = {\n          groupId: child.getGroupId(),\n          open: child.getColGroupDef().openByDefault\n        };\n        stateItems.push(groupState);\n      }\n    });\n    this.setColumnGroupState(stateItems, source);\n  };\n\n  ColumnController.prototype.getColumnGroupState = function () {\n    var columnGroupState = [];\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof OriginalColumnGroup) {\n        var originalColumnGroup = node;\n        columnGroupState.push({\n          groupId: originalColumnGroup.getGroupId(),\n          open: originalColumnGroup.isExpanded()\n        });\n      }\n    });\n    return columnGroupState;\n  };\n\n  ColumnController.prototype.setColumnGroupState = function (stateItems, source) {\n    var _this = this;\n\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    this.columnAnimationService.start();\n    var impactedGroups = [];\n    stateItems.forEach(function (stateItem) {\n      var groupKey = stateItem.groupId;\n      var newValue = stateItem.open;\n\n      var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n\n      if (!originalColumnGroup) {\n        return;\n      }\n\n      if (originalColumnGroup.isExpanded() === newValue) {\n        return;\n      }\n\n      _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n\n      originalColumnGroup.setExpanded(newValue);\n      impactedGroups.push(originalColumnGroup);\n    });\n    this.updateGroupsAndDisplayedColumns(source);\n    this.setFirstRightAndLastLeftPinned(source);\n    impactedGroups.forEach(function (originalColumnGroup) {\n      var event = {\n        type: Events.EVENT_COLUMN_GROUP_OPENED,\n        columnGroup: originalColumnGroup,\n        api: _this.gridApi,\n        columnApi: _this.columnApi\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n    this.columnAnimationService.finish();\n  }; // called by headerRenderer - when a header is opened or closed\n\n\n  ColumnController.prototype.setColumnGroupOpened = function (key, newValue, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var keyAsString;\n\n    if (key instanceof OriginalColumnGroup) {\n      keyAsString = key.getId();\n    } else {\n      keyAsString = key;\n    }\n\n    this.setColumnGroupState([{\n      groupId: keyAsString,\n      open: newValue\n    }], source);\n  };\n\n  ColumnController.prototype.getOriginalColumnGroup = function (key) {\n    if (key instanceof OriginalColumnGroup) {\n      return key;\n    }\n\n    if (typeof key !== 'string') {\n      console.error('ag-Grid: group key must be a string');\n    } // otherwise, search for the column group by id\n\n\n    var res = null;\n    this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n      if (node instanceof OriginalColumnGroup) {\n        var originalColumnGroup = node;\n\n        if (originalColumnGroup.getId() === key) {\n          res = originalColumnGroup;\n        }\n      }\n    });\n    return res;\n  };\n\n  ColumnController.prototype.calculateColumnsForDisplay = function () {\n    var _this = this;\n\n    var columnsForDisplay;\n\n    if (this.pivotMode && !this.secondaryColumnsPresent) {\n      // pivot mode is on, but we are not pivoting, so we only\n      // show columns we are aggregating on\n      columnsForDisplay = this.gridColumns.filter(function (column) {\n        var isAutoGroupCol = _this.groupAutoColumns && _.includes(_this.groupAutoColumns, column);\n\n        var isValueCol = _this.valueColumns && _.includes(_this.valueColumns, column);\n\n        return isAutoGroupCol || isValueCol;\n      });\n    } else {\n      // otherwise continue as normal. this can be working on the primary\n      // or secondary columns, whatever the gridColumns are set to\n      columnsForDisplay = this.gridColumns.filter(function (column) {\n        // keep col if a) it's auto-group or b) it's visible\n        var isAutoGroupCol = _this.groupAutoColumns && _.includes(_this.groupAutoColumns, column);\n\n        return isAutoGroupCol || column.isVisible();\n      });\n    }\n\n    return columnsForDisplay;\n  };\n\n  ColumnController.prototype.checkColSpanActiveInCols = function (columns) {\n    var result = false;\n    columns.forEach(function (col) {\n      if (_.exists(col.getColDef().colSpan)) {\n        result = true;\n      }\n    });\n    return result;\n  };\n\n  ColumnController.prototype.calculateColumnsForGroupDisplay = function () {\n    var _this = this;\n\n    this.groupDisplayColumns = [];\n\n    var checkFunc = function (col) {\n      var colDef = col.getColDef();\n\n      if (colDef && _.exists(colDef.showRowGroup)) {\n        _this.groupDisplayColumns.push(col);\n      }\n    };\n\n    this.gridColumns.forEach(checkFunc);\n\n    if (this.groupAutoColumns) {\n      this.groupAutoColumns.forEach(checkFunc);\n    }\n  };\n\n  ColumnController.prototype.getGroupDisplayColumns = function () {\n    return this.groupDisplayColumns;\n  };\n\n  ColumnController.prototype.updateDisplayedColumns = function (source) {\n    var columnsForDisplay = this.calculateColumnsForDisplay();\n    this.buildDisplayedTrees(columnsForDisplay);\n    this.calculateColumnsForGroupDisplay(); // also called when group opened/closed\n\n    this.updateGroupsAndDisplayedColumns(source); // also called when group opened/closed\n\n    this.setFirstRightAndLastLeftPinned(source);\n  };\n\n  ColumnController.prototype.isSecondaryColumnsPresent = function () {\n    return this.secondaryColumnsPresent;\n  };\n\n  ColumnController.prototype.setSecondaryColumns = function (colDefs, source) {\n    if (source === void 0) {\n      source = \"api\";\n    }\n\n    var newColsPresent = colDefs && colDefs.length > 0; // if not cols passed, and we had to cols anyway, then do nothing\n\n    if (!newColsPresent && !this.secondaryColumnsPresent) {\n      return;\n    }\n\n    if (newColsPresent) {\n      this.processSecondaryColumnDefinitions(colDefs);\n      var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n      this.secondaryBalancedTree = balancedTreeResult.columnTree;\n      this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n      this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n      this.secondaryColumnsPresent = true;\n    } else {\n      this.secondaryBalancedTree = null;\n      this.secondaryHeaderRowCount = -1;\n      this.secondaryColumns = null;\n      this.secondaryColumnsPresent = false;\n    }\n\n    this.updateGridColumns();\n    this.updateDisplayedColumns(source);\n  };\n\n  ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n    var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n    var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n\n    if (!columnCallback && !groupCallback) {\n      return undefined;\n    }\n\n    var searchForColDefs = function (colDefs2) {\n      colDefs2.forEach(function (abstractColDef) {\n        var isGroup = _.exists(abstractColDef.children);\n\n        if (isGroup) {\n          var colGroupDef = abstractColDef;\n\n          if (groupCallback) {\n            groupCallback(colGroupDef);\n          }\n\n          searchForColDefs(colGroupDef.children);\n        } else {\n          var colDef = abstractColDef;\n\n          if (columnCallback) {\n            columnCallback(colDef);\n          }\n        }\n      });\n    };\n\n    if (colDefs) {\n      searchForColDefs(colDefs);\n    }\n  }; // called from: setColumnState, setColumnDefs, setSecondaryColumns\n\n\n  ColumnController.prototype.updateGridColumns = function () {\n    if (this.gridColsArePrimary) {\n      this.lastPrimaryOrder = this.gridColumns;\n    }\n\n    if (this.secondaryColumns && this.secondaryBalancedTree) {\n      this.gridBalancedTree = this.secondaryBalancedTree.slice();\n      this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n      this.gridColumns = this.secondaryColumns.slice();\n      this.gridColsArePrimary = false;\n    } else {\n      this.gridBalancedTree = this.primaryColumnTree.slice();\n      this.gridHeaderRowCount = this.primaryHeaderRowCount;\n      this.gridColumns = this.primaryColumns.slice();\n      this.gridColsArePrimary = true; // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n      // when this happens (eg if user moved a column) rather than revert back to the original column order.\n      // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n\n      this.orderGridColsLikeLastPrimary();\n    }\n\n    this.addAutoGroupToGridColumns();\n    this.autoRowHeightColumns = this.gridColumns.filter(function (col) {\n      return col.getColDef().autoHeight;\n    });\n    this.putFixedColumnsFirst();\n    this.setupQuickFilterColumns();\n    this.clearDisplayedColumns();\n    this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n    var event = {\n      type: Events.EVENT_GRID_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.orderGridColsLikeLastPrimary = function () {\n    var _this = this;\n\n    if (_.missing(this.lastPrimaryOrder)) {\n      return;\n    } // only do the sort if at least one column is accounted for. columns will be not accounted for\n    // if changing from secondary to primary columns\n\n\n    var noColsFound = true;\n    this.gridColumns.forEach(function (col) {\n      if (_this.lastPrimaryOrder.indexOf(col) >= 0) {\n        noColsFound = false;\n      }\n    });\n\n    if (noColsFound) {\n      return;\n    } // order cols in the same order as before. we need to make sure that all\n    // cols still exists, so filter out any that no longer exist.\n\n\n    var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) {\n      return _this.gridColumns.indexOf(col) >= 0;\n    });\n    var newColsOrdered = this.gridColumns.filter(function (col) {\n      return oldColsOrdered.indexOf(col) < 0;\n    }); // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n\n    var newGridColumns = oldColsOrdered.slice();\n    newColsOrdered.forEach(function (newCol) {\n      var parent = newCol.getOriginalParent(); // if no parent, means we are not grouping, so just add the column to the end\n\n      if (!parent) {\n        newGridColumns.push(newCol);\n        return;\n      } // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n      // own) then go up one level and look for siblings there.\n\n\n      var siblings = [];\n\n      while (!siblings.length && parent) {\n        var leafCols = parent.getLeafColumns();\n        leafCols.forEach(function (leafCol) {\n          var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n          var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n\n          if (presentInNewGriColumns && noYetInSiblings) {\n            siblings.push(leafCol);\n          }\n        });\n        parent = parent.getOriginalParent();\n      } // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n\n\n      if (!siblings.length) {\n        newGridColumns.push(newCol);\n        return;\n      } // find index of last column in the group\n\n\n      var indexes = siblings.map(function (col) {\n        return newGridColumns.indexOf(col);\n      });\n      var lastIndex = Math.max.apply(Math, indexes);\n\n      _.insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n    });\n    this.gridColumns = newGridColumns;\n  };\n\n  ColumnController.prototype.isPrimaryColumnGroupsPresent = function () {\n    return this.primaryHeaderRowCount > 1;\n  }; // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n  // following scenarios:\n  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n\n\n  ColumnController.prototype.setupQuickFilterColumns = function () {\n    if (this.groupAutoColumns) {\n      this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n    } else {\n      this.columnsForQuickFilter = this.primaryColumns;\n    }\n  };\n\n  ColumnController.prototype.putFixedColumnsFirst = function () {\n    var locked = this.gridColumns.filter(function (c) {\n      return c.getColDef().lockPosition;\n    });\n    var unlocked = this.gridColumns.filter(function (c) {\n      return !c.getColDef().lockPosition;\n    });\n    this.gridColumns = locked.concat(unlocked);\n  };\n\n  ColumnController.prototype.addAutoGroupToGridColumns = function () {\n    // add in auto-group here\n    this.createGroupAutoColumnsIfNeeded();\n\n    if (_.missing(this.groupAutoColumns)) {\n      return;\n    }\n\n    this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n    var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n    this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n  }; // gets called after we copy down grid columns, to make sure any part of the gui\n  // that tries to draw, eg the header, it will get empty lists of columns rather\n  // than stale columns. for example, the header will received gridColumnsChanged\n  // event, so will try and draw, but it will draw successfully when it acts on the\n  // virtualColumnsChanged event\n\n\n  ColumnController.prototype.clearDisplayedColumns = function () {\n    this.displayedLeftColumnTree = [];\n    this.displayedRightColumnTree = [];\n    this.displayedCentreColumnTree = [];\n    this.displayedLeftHeaderRows = {};\n    this.displayedRightHeaderRows = {};\n    this.displayedCentreHeaderRows = {};\n    this.displayedLeftColumns = [];\n    this.displayedRightColumns = [];\n    this.displayedCenterColumns = [];\n    this.allDisplayedColumns = [];\n    this.allDisplayedVirtualColumns = [];\n  };\n\n  ColumnController.prototype.updateGroupsAndDisplayedColumns = function (source) {\n    this.updateOpenClosedVisibilityInColumnGroups();\n    this.updateDisplayedColumnsFromTrees(source);\n    this.updateVirtualSets();\n    this.refreshFlexedColumns(undefined, undefined, true);\n    this.updateBodyWidths(); // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n\n    var event = {\n      type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n      api: this.gridApi,\n      columnApi: this.columnApi\n    };\n    this.eventService.dispatchEvent(event);\n  };\n\n  ColumnController.prototype.updateDisplayedColumnsFromTrees = function (source) {\n    this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);\n    this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);\n    this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);\n    this.setupAllDisplayedColumns();\n    this.setLeftValues(source);\n  };\n\n  ColumnController.prototype.setupAllDisplayedColumns = function () {\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      this.allDisplayedColumns = this.displayedRightColumns.concat(this.displayedCenterColumns).concat(this.displayedLeftColumns);\n    } else {\n      this.allDisplayedColumns = this.displayedLeftColumns.concat(this.displayedCenterColumns).concat(this.displayedRightColumns);\n    }\n  }; // sets the left pixel position of each column\n\n\n  ColumnController.prototype.setLeftValues = function (source) {\n    this.setLeftValuesOfColumns(source);\n    this.setLeftValuesOfGroups();\n  };\n\n  ColumnController.prototype.setLeftValuesOfColumns = function (source) {\n    var _this = this; // go through each list of displayed columns\n\n\n    var allColumns = this.primaryColumns.slice(0); // let totalColumnWidth = this.getWidthOfColsInList()\n\n    var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n    [this.displayedLeftColumns, this.displayedRightColumns, this.displayedCenterColumns].forEach(function (columns) {\n      if (doingRtl) {\n        // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n        var left_1 = _this.getWidthOfColsInList(columns);\n\n        columns.forEach(function (column) {\n          left_1 -= column.getActualWidth();\n          column.setLeft(left_1, source);\n        });\n      } else {\n        // otherwise normal LTR, we start at zero\n        var left_2 = 0;\n        columns.forEach(function (column) {\n          column.setLeft(left_2, source);\n          left_2 += column.getActualWidth();\n        });\n      }\n\n      _.removeAllFromArray(allColumns, columns);\n    }); // items left in allColumns are columns not displayed, so remove the left position. this is\n    // important for the rows, as if a col is made visible, then taken out, then made visible again,\n    // we don't want the animation of the cell floating in from the old position, whatever that was.\n\n    allColumns.forEach(function (column) {\n      column.setLeft(null, source);\n    });\n  };\n\n  ColumnController.prototype.setLeftValuesOfGroups = function () {\n    // a groups left value is the lest left value of it's children\n    [this.displayedLeftColumnTree, this.displayedRightColumnTree, this.displayedCentreColumnTree].forEach(function (columns) {\n      columns.forEach(function (column) {\n        if (column instanceof ColumnGroup) {\n          var columnGroup = column;\n          columnGroup.checkLeft();\n        }\n      });\n    });\n  };\n\n  ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {\n    displayedColumns.length = 0;\n    this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {\n      if (child instanceof Column) {\n        displayedColumns.push(child);\n      }\n    });\n  };\n\n  ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {\n    if (this.suppressColumnVirtualisation) {\n      // no virtualisation, so don't filter\n      this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;\n    } else {\n      // filter out what should be visible\n      this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();\n    }\n\n    this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns.concat(this.displayedLeftColumns).concat(this.displayedRightColumns); // return map of virtual col id's, for easy lookup when building the groups.\n    // the map will be colId=>true, ie col id's mapping to 'true'.\n\n    var result = {};\n    this.allDisplayedVirtualColumns.forEach(function (col) {\n      result[col.getId()] = true;\n    });\n    return result;\n  };\n\n  ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n    var result;\n\n    switch (type) {\n      case Constants.PINNED_LEFT:\n        result = this.displayedLeftHeaderRows[dept];\n        break;\n\n      case Constants.PINNED_RIGHT:\n        result = this.displayedRightHeaderRows[dept];\n        break;\n\n      default:\n        result = this.displayedCentreHeaderRows[dept];\n        break;\n    }\n\n    if (_.missing(result)) {\n      result = [];\n    }\n\n    return result;\n  };\n\n  ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {\n    // go through each group, see if any of it's cols are displayed, and if yes,\n    // then this group is included\n    this.displayedLeftHeaderRows = {};\n    this.displayedRightHeaderRows = {};\n    this.displayedCentreHeaderRows = {};\n\n    var testGroup = function (children, result, dept) {\n      var returnValue = false;\n\n      for (var i = 0; i < children.length; i++) {\n        // see if this item is within viewport\n        var child = children[i];\n        var addThisItem = void 0;\n\n        if (child instanceof Column) {\n          // for column, test if column is included\n          addThisItem = virtualColIds[child.getId()] === true;\n        } else {\n          // if group, base decision on children\n          var columnGroup = child;\n          addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);\n        }\n\n        if (addThisItem) {\n          returnValue = true;\n\n          if (!result[dept]) {\n            result[dept] = [];\n          }\n\n          result[dept].push(child);\n        }\n      }\n\n      return returnValue;\n    };\n\n    testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);\n    testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);\n    testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);\n  };\n\n  ColumnController.prototype.updateVirtualSets = function () {\n    var virtualColIds = this.updateDisplayedCenterVirtualColumns();\n    this.updateDisplayedVirtualGroups(virtualColIds);\n  };\n\n  ColumnController.prototype.filterOutColumnsWithinViewport = function () {\n    return this.displayedCenterColumns.filter(this.isColumnInViewport.bind(this));\n  };\n\n  ColumnController.prototype.refreshFlexedColumns = function (updatedFlexViewportWidth, source, silent) {\n    if (source === void 0) {\n      source = 'flex';\n    }\n\n    if (!this.flexActive) {\n      return;\n    }\n\n    this.flexViewportWidth = updatedFlexViewportWidth || this.flexViewportWidth;\n\n    if (!this.flexViewportWidth) {\n      return;\n    } // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n    // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n    // minWidth or maxWidth rules.\n\n\n    var knownWidthColumns = this.displayedCenterColumns.filter(function (col) {\n      return !col.getFlex();\n    });\n    var flexingColumns = this.displayedCenterColumns.filter(function (col) {\n      return col.getFlex();\n    });\n\n    if (!flexingColumns.length) {\n      this.flexActive = false;\n      return;\n    }\n\n    var flexingColumnSizes = [];\n    var spaceForFlexingColumns;\n\n    outer: while (true) {\n      var totalFlex = flexingColumns.reduce(function (count, col) {\n        return count + col.getFlex();\n      }, 0);\n      spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n\n      for (var i = 0; i < flexingColumns.length; i++) {\n        var col = flexingColumns[i];\n        var widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n        var constrainedWidth = void 0;\n\n        if (widthByFlexRule < col.getMinWidth()) {\n          constrainedWidth = col.getMinWidth();\n        } else if (col.getMaxWidth() != null && widthByFlexRule > col.getMaxWidth()) {\n          constrainedWidth = col.getMaxWidth();\n        }\n\n        if (constrainedWidth) {\n          // This column is not in fact flexing as it is being constrained to a specific size\n          // so remove it from the list of flexing columns and start again\n          col.setActualWidth(constrainedWidth, source);\n\n          _.removeFromArray(flexingColumns, col);\n\n          knownWidthColumns.push(col);\n          continue outer;\n        }\n\n        flexingColumnSizes[i] = Math.round(widthByFlexRule);\n      }\n\n      break;\n    }\n\n    var remainingSpace = spaceForFlexingColumns;\n    flexingColumns.forEach(function (col, i) {\n      col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n      remainingSpace -= flexingColumnSizes[i];\n    });\n    this.setLeftValues(source);\n\n    if (!silent) {\n      this.updateBodyWidths();\n      this.fireResizedEventForColumns(flexingColumns, source);\n    }\n  }; // called from api\n\n\n  ColumnController.prototype.sizeColumnsToFit = function (gridWidth, source, silent) {\n    if (source === void 0) {\n      source = \"sizeColumnsToFit\";\n    } // avoid divide by zero\n\n\n    var allDisplayedColumns = this.getAllDisplayedColumns();\n\n    if (gridWidth <= 0 || !allDisplayedColumns.length) {\n      return;\n    }\n\n    var colsToSpread = [];\n    var colsToNotSpread = [];\n    allDisplayedColumns.forEach(function (column) {\n      if (column.getColDef().suppressSizeToFit === true) {\n        colsToNotSpread.push(column);\n      } else {\n        colsToSpread.push(column);\n      }\n    }); // make a copy of the cols that are going to be resized\n\n    var colsToFireEventFor = colsToSpread.slice(0);\n    var finishedResizing = false;\n\n    var moveToNotSpread = function (column) {\n      _.removeFromArray(colsToSpread, column);\n\n      colsToNotSpread.push(column);\n    }; // resetting cols to their original width makes the sizeColumnsToFit more deterministic,\n    // rather than depending on the current size of the columns. most users call sizeColumnsToFit\n    // immediately after grid is created, so will make no difference. however if application is calling\n    // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want\n    // the columns to start shrinking / growing over time.\n\n\n    colsToSpread.forEach(function (column) {\n      return column.resetActualWidth();\n    });\n\n    while (!finishedResizing) {\n      finishedResizing = true;\n      var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n\n      if (availablePixels <= 0) {\n        // no width, set everything to minimum\n        colsToSpread.forEach(function (column) {\n          column.setMinimum(source);\n        });\n      } else {\n        var scale = availablePixels / this.getWidthOfColsInList(colsToSpread); // we set the pixels for the last col based on what's left, as otherwise\n        // we could be a pixel or two short or extra because of rounding errors.\n\n        var pixelsForLastCol = availablePixels; // backwards through loop, as we are removing items as we go\n\n        for (var i = colsToSpread.length - 1; i >= 0; i--) {\n          var column = colsToSpread[i];\n          var newWidth = Math.round(column.getActualWidth() * scale);\n\n          if (newWidth < column.getMinWidth()) {\n            column.setMinimum(source);\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else if (column.isGreaterThanMax(newWidth)) {\n            column.setActualWidth(column.getMaxWidth(), source);\n            moveToNotSpread(column);\n            finishedResizing = false;\n          } else {\n            var onLastCol = i === 0;\n\n            if (onLastCol) {\n              column.setActualWidth(pixelsForLastCol, source);\n            } else {\n              column.setActualWidth(newWidth, source);\n            }\n          }\n\n          pixelsForLastCol -= newWidth;\n        }\n      }\n    }\n\n    this.setLeftValues(source);\n    this.updateBodyWidths();\n\n    if (silent) {\n      return;\n    }\n\n    this.fireResizedEventForColumns(colsToFireEventFor, source);\n  };\n\n  ColumnController.prototype.fireResizedEventForColumns = function (columns, source) {\n    var _this = this;\n\n    columns.forEach(function (column) {\n      var event = {\n        type: Events.EVENT_COLUMN_RESIZED,\n        column: column,\n        columns: [column],\n        finished: true,\n        api: _this.gridApi,\n        columnApi: _this.columnApi,\n        source: source\n      };\n\n      _this.eventService.dispatchEvent(event);\n    });\n  };\n\n  ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {\n    var leftVisibleColumns = [];\n    var rightVisibleColumns = [];\n    var centerVisibleColumns = [];\n    visibleColumns.forEach(function (column) {\n      switch (column.getPinned()) {\n        case \"left\":\n          leftVisibleColumns.push(column);\n          break;\n\n        case \"right\":\n          rightVisibleColumns.push(column);\n          break;\n\n        default:\n          centerVisibleColumns.push(column);\n          break;\n      }\n    });\n    var groupInstanceIdCreator = new GroupInstanceIdCreator();\n    this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedLeftColumnTree);\n    this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedRightColumnTree);\n    this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedCentreColumnTree);\n  };\n\n  ColumnController.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n    var allColumnGroups = this.getAllDisplayedColumnGroups();\n    this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n      if (child instanceof ColumnGroup) {\n        var columnGroup = child;\n        columnGroup.calculateDisplayedColumns();\n      }\n    });\n  };\n\n  ColumnController.prototype.getGroupAutoColumns = function () {\n    return this.groupAutoColumns;\n  };\n\n  ColumnController.prototype.createGroupAutoColumnsIfNeeded = function () {\n    if (!this.autoGroupsNeedBuilding) {\n      return;\n    }\n\n    this.autoGroupsNeedBuilding = false;\n    var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode); // we need to allow suppressing auto-column separately for group and pivot as the normal situation\n    // is CSRM and user provides group column themselves for normal view, but when they go into pivot the\n    // columns are generated by the grid so no opportunity for user to provide group column. so need a way\n    // to suppress auto-col for grouping only, and not pivot.\n    // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control\n    // of the group column in this instance.\n\n    var suppressAutoColumn = this.pivotMode ? this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn(); // const groupSuppressAutoColumn = this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.pivotMode;\n\n    var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n    var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n    var needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow && !groupSuppressRow;\n\n    if (needAutoColumns) {\n      var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n      var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns); // we force recreate when suppressSetColumnStateEvents changes, so new group cols pick up the new\n      // definitions. otherwise we could ignore the new cols becasue they appear to be the same.\n\n      if (autoColsDifferent || this.forceRecreateAutoGroups) {\n        this.groupAutoColumns = newAutoGroupCols;\n      }\n    } else {\n      this.groupAutoColumns = null;\n    }\n  };\n\n  ColumnController.prototype.autoColsEqual = function (colsA, colsB) {\n    return areEqual(colsA, colsB, function (a, b) {\n      return a.getColId() === b.getColId();\n    });\n  };\n\n  ColumnController.prototype.getWidthOfColsInList = function (columnList) {\n    return columnList.reduce(function (width, col) {\n      return width + col.getActualWidth();\n    }, 0);\n  };\n\n  ColumnController.prototype.getGridBalancedTree = function () {\n    return this.gridBalancedTree;\n  };\n\n  ColumnController.prototype.hasFloatingFilters = function () {\n    var defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n    return defaultColDef != null && defaultColDef.floatingFilter === true || this.columnDefs != null && this.columnDefs.some(function (c) {\n      return c.floatingFilter === true;\n    });\n  };\n\n  ColumnController.prototype.getFirstDisplayedColumn = function () {\n    var isRtl = this.gridOptionsWrapper.isEnableRtl();\n    var queryOrder = ['getDisplayedLeftColumns', 'getDisplayedCenterColumns', 'getDisplayedRightColumns'];\n\n    if (isRtl) {\n      queryOrder.reverse();\n    }\n\n    for (var i = 0; i < queryOrder.length; i++) {\n      var container = this[queryOrder[i]]();\n\n      if (container.length) {\n        return isRtl ? _.last(container) : container[0];\n      }\n    }\n\n    return null;\n  };\n\n  __decorate([Autowired('gridOptionsWrapper')], ColumnController.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([Autowired('expressionService')], ColumnController.prototype, \"expressionService\", void 0);\n\n  __decorate([Autowired('columnFactory')], ColumnController.prototype, \"columnFactory\", void 0);\n\n  __decorate([Autowired('displayedGroupCreator')], ColumnController.prototype, \"displayedGroupCreator\", void 0);\n\n  __decorate([Autowired('autoWidthCalculator')], ColumnController.prototype, \"autoWidthCalculator\", void 0);\n\n  __decorate([Autowired('columnUtils')], ColumnController.prototype, \"columnUtils\", void 0);\n\n  __decorate([Autowired('columnAnimationService')], ColumnController.prototype, \"columnAnimationService\", void 0);\n\n  __decorate([Autowired('autoGroupColService')], ColumnController.prototype, \"autoGroupColService\", void 0);\n\n  __decorate([Optional('aggFuncService')], ColumnController.prototype, \"aggFuncService\", void 0);\n\n  __decorate([Optional('valueCache')], ColumnController.prototype, \"valueCache\", void 0);\n\n  __decorate([Optional('animationFrameService')], ColumnController.prototype, \"animationFrameService\", void 0);\n\n  __decorate([Autowired('columnApi')], ColumnController.prototype, \"columnApi\", void 0);\n\n  __decorate([Autowired('gridApi')], ColumnController.prototype, \"gridApi\", void 0);\n\n  __decorate([PostConstruct], ColumnController.prototype, \"init\", null);\n\n  __decorate([__param(0, Qualifier('loggerFactory'))], ColumnController.prototype, \"setBeans\", null);\n\n  ColumnController = __decorate([Bean('columnController')], ColumnController);\n  return ColumnController;\n}(BeanStub);\n\nexport { ColumnController };","map":{"version":3,"sources":["/Users/fouaddakhel/Projects/Nana/ReactJS/supermarket_dashboard/supermarket_dashboard/node_modules/@ag-grid-community/core/dist/es6/columnController/columnController.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","ColumnGroup","Column","Events","BeanStub","OriginalColumnGroup","GroupInstanceIdCreator","Autowired","Bean","Optional","PostConstruct","Qualifier","Constants","areEqual","_","ColumnController","_super","_this","apply","primaryHeaderRowCount","secondaryHeaderRowCount","secondaryColumnsPresent","gridHeaderRowCount","displayedLeftColumns","displayedRightColumns","displayedCenterColumns","allDisplayedColumns","allDisplayedVirtualColumns","allDisplayedCenterVirtualColumns","rowGroupColumns","valueColumns","pivotColumns","ready","autoGroupsNeedBuilding","forceRecreateAutoGroups","pivotMode","bodyWidth","leftWidth","rightWidth","bodyWidthDirty","flexActive","init","suppressColumnVirtualisation","gridOptionsWrapper","isSuppressColumnVirtualisation","isPivotMode","isPivotSettingAllowed","usingTreeData","isTreeData","addManagedListener","onAutoGroupColumnDefChanged","bind","updateGridColumns","updateDisplayedColumns","setColumnDefs","columnDefs","source","colsPreviouslyExisted","valueCache","expire","oldPrimaryColumns","primaryColumns","balancedTreeResult","columnFactory","createColumnTree","primaryColumnTree","columnTree","treeDept","getColumnsFromTree","extractRowGroupColumns","extractPivotColumns","createValueColumns","checkDisplayedVirtualColumns","isImmutableColumns","resetColumnState","eventEverythingChanged","type","EVENT_COLUMN_EVERYTHING_CHANGED","api","gridApi","columnApi","eventService","dispatchEvent","newColumnsLoadedEvent","EVENT_NEW_COLUMNS_LOADED","getDisplayedCenterColumns","some","col","getFlex","isAutoRowHeightActive","autoRowHeightColumns","getAllAutoRowHeightCols","setVirtualViewportLeftAndRight","isEnableRtl","viewportLeft","scrollPosition","scrollWidth","viewportRight","getDisplayedColumnsStartingAt","column","currentColumn","columns","push","getDisplayedColAfter","hashBefore","map","getId","join","updateVirtualSets","hashAfter","event_1","EVENT_VIRTUAL_COLUMNS_CHANGED","setVirtualViewportPosition","pivot","console","warn","setPivotMode","event","EVENT_COLUMN_PIVOT_MODE_CHANGED","getSecondaryPivotColumn","pivotKeys","valueColKey","secondaryColumns","valueColumnToFind","getPrimaryColumn","foundColumn","forEach","thisPivotKeys","getColDef","pivotValueColumn","pivotKeyMatches","pivotValueMatches","setBeans","loggerFactory","logger","setFirstRightAndLastLeftPinned","lastLeft","firstRight","last","gridColumns","setLastLeftPinned","setFirstRightPinned","autoSizeColumns","keys","skipHeader","animationFrameService","flushAllFrames","columnsAutosized","changesThisTimeAround","isSkipHeaderOnAutoSize","actionOnGridColumns","indexOf","preferredWidth","autoWidthCalculator","getPreferredWidthForColumn","newWidth","normaliseColumnWidth","setActualWidth","event_2","EVENT_COLUMN_RESIZED","finished","autoSizeColumn","autoSizeAllColumns","getAllDisplayedColumns","rootColumns","result","recursiveFindColumns","childColumns","child","getChildren","getAllDisplayedColumnGroups","displayedLeftColumnTree","displayedRightColumnTree","displayedCentreColumnTree","concat","getPrimaryColumnTree","getHeaderRowCount","getLeftDisplayedColumnGroups","getRightDisplayedColumnGroups","getCenterDisplayedColumnGroups","getDisplayedColumnGroups","PINNED_LEFT","PINNED_RIGHT","isColumnDisplayed","getAllDisplayedVirtualColumns","getDisplayedLeftColumnsForRow","rowNode","colSpanActive","getDisplayedColumnsForRow","getDisplayedRightColumnsForRow","displayedColumns","filterCallback","emptySpaceBeforeColumn","lastConsideredCol","_loop_1","maxAllowedColSpan","colSpan","Math","min","getColSpan","columnsToCheckFilter","colsToRemove","j","filterPasses","colForFilter","gapBeforeColumn","out_i_1","getAllDisplayedCenterVirtualColumnsForRow","getLeft","isColumnInViewport","columnLeft","columnRight","getActualWidth","leftBounds","rightBounds","columnToMuchLeft","columnToMuchRight","getPinnedLeftContainerWidth","getWidthOfColsInList","getPinnedRightContainerWidth","updatePrimaryColumnList","masterList","actionIsAdd","columnCallback","eventType","missingOrEmpty","atLeastOne","columnToAdd","removeFromArray","setRowGroupColumns","colKeys","setPrimaryColumnList","EVENT_COLUMN_ROW_GROUP_CHANGED","setRowGroupActive","active","isRowGroupActive","isSuppressMakeColumnVisibleAfterUnGroup","setVisible","addRowGroupColumn","addRowGroupColumns","removeRowGroupColumns","removeRowGroupColumn","addPivotColumns","setPivotActive","EVENT_COLUMN_PIVOT_CHANGED","setPivotColumns","added","addPivotColumn","removePivotColumns","removePivotColumn","eventName","exists","setValueColumns","EVENT_COLUMN_VALUE_CHANGED","setValueActive","isValueActive","getAggFunc","defaultAggFunc","aggFuncService","getDefaultAggFunc","setAggFunc","addValueColumns","addValueColumn","colKey","removeValueColumn","removeValueColumns","getMinWidth","isGreaterThanMax","getMaxWidth","getPrimaryOrGridColumn","getGridColumn","setColumnWidths","columnWidths","shiftKey","sets","columnWidth","width","ratios","defaultIsShift","getColResizeDefault","otherCol","widthDiff","otherColWidth","resizeColumnSets","refreshFlexedColumns","checkMinAndMaxWidthsForSet","columnResizeSet","minWidthAccumulated","maxWidthAccumulated","maxWidthActive","minWidthPasses","maxWidthPasses","resizeSets","passMinMaxCheck","every","event_3","changedCols","allCols","set","newWidths","finishedCols","finishedColsGrew","loopCount","_loop_2","error","subsetCols","subsetRatios","subsetRatioTotal","pixelsToDistribute","index","thisColFinished","ratioThisCol","ratioScale","lastCol","colNewWidth","round","state_1","atLeastOneColChanged","setLeftValues","updateBodyWidths","event_4","setColumnAggFunc","aggFunc","moveRowGroupColumn","fromIndex","toIndex","splice","moveColumns","columnsToMoveKeys","columnAnimationService","start","columnsToMove","getGridColumns","failedRules","doesMovePassRules","moveInArray","EVENT_COLUMN_MOVED","finish","proposedColumnOrder","slice","doesMovePassMarryChildren","doesMovePassLockedPositions","foundNonLocked","rulePassed","lockPosition","allColumnsCopy","columnUtils","depthFirstOriginalTreeSearch","gridBalancedTree","columnGroup","marryChildren","getColGroupDef","newIndexes","getLeafColumns","newColIndex","maxIndex","max","minIndex","spread","maxSpread","moveColumn","moveColumnByIndex","getBodyContainerWidth","getContainerWidth","pinned","newBodyWidth","newLeftWidth","newRightWidth","atLeastOneChanged","event_5","EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED","getValueColumns","getPivotColumns","isPivotActive","getRowGroupColumns","getDisplayedLeftColumns","getDisplayedRightColumns","getDisplayedColumns","getAllPrimaryColumns","getSecondaryColumns","getAllColumnsForQuickFilter","columnsForQuickFilter","getAllGridColumns","isEmpty","isRowGroupEmpty","setColumnVisible","visible","setColumnsVisible","isVisible","EVENT_COLUMN_VISIBLE","setColumnPinned","setColumnsPinned","getDomLayout","actualPinned","getPinned","setPinned","EVENT_COLUMN_PINNED","action","createEvent","updatedColumns","resultOfAction","event_6","getDisplayedColBefore","oldIndex","getDisplayedGroupAfter","getDisplayedGroupAtDirection","getDisplayedGroupBefore","direction","requiredLevel","getOriginalColumnGroup","getLevel","getPaddingLevel","colGroupLeafColumns","getDisplayedLeafColumns","getDisplayColMethod","groupPointer","getColumnGroupAtLevel","level","getParent","originalGroupLevel","groupPointerLevel","groupPointerOriginalColumnGroup","isPinningLeft","isPinningRight","getPrimaryAndSecondaryAndAutoColumns","groupAutoColumns","createStateItemFromColumn","rowGroupIndex","pivotIndex","colId","getColId","hide","flex","getColumnState","missing","primaryColumnState","groupAutoColumnState","columnStateList","orderColumnStateList","gridColumnIds","sort","itemA","itemB","posA","posB","suppressEverythingEvent","columnStates","letRowGroupIndex","letPivotIndex","rowGroup","stateItem","setColumnState","columnStateBefore","columnsWithNoState","success","rowGroupIndexes","pivotIndexes","autoGroupColumnStates","state","getAutoColumn","syncColumnWithStateItem","undefined","syncColumnWithNoState","sortColumnListUsingIndexes","autoCol","orderOfColIds_1","colA","colB","indexA","indexB","putFixedColumnsFirst","event_7","raiseColumnEvents","isSuppressSetColumnStateEvents","columnStateAfter","raiseEventWithAllColumns","idMapper","unchanged","getChangedColumns","changedPredicate","changedColumns","columnStateBeforeMap","colStateBefore","valueColumnIdMapper","cs","pivotColumnIdMapper","rowGroupColumnIdMapper","pinnedChangePredicate","raiseColumnPinnedEvent","visibilityChangePredicate","cols","raiseColumnVisibleEvent","resizeChangePredicate","raiseColumnResizeEvent","raiseColumnMovedEvent","movedColumns","_loop_3","before","after","predicate","movedColumn","find","this_1","indexes","minColWidth","getMinColWidth","setFlex","getColumns","columnLookupCallback","foundColumns","getColumnWithValidation","getColumn","columnList","columnsMatch","groupCol","columnMatches","colDefMatches","idMatches","getDisplayNameForColumn","location","includeAggFunc","headerName","getHeaderName","wrapHeaderNameWithAggFunc","getDisplayNameForOriginalColumnGroup","originalColumnGroup","colGroupDef","getDisplayNameForColumnGroup","colDef","headerValueGetter","params","getApi","context","getContext","expressionService","evaluate","field","camelCaseToHumanText","isSuppressAggFuncInHeader","pivotActiveOnThisColumn","aggFuncFound","measureActive","aggregationPresent","aggFuncString","localeTextFunc","getLocaleTextFunc","aggFuncStringTranslated","getColumnGroup","instanceId","allColumnGroups","checkInstanceId","depthFirstAllColumnTreeSearch","matched","getGroupId","getInstanceId","isReady","extractColumns","flag","previousCols","setFlagFunc","getIndexFunc","getValueFunc","colPresentInPrimaryFunc","colMissingFromPrimaryFunc","colNewFunc","removedCols","filter","existingCols","newPrimaryCols","newCols","booleanValue","res","resetColumnGroupState","stateItems","groupState","groupId","open","openByDefault","setColumnGroupState","getColumnGroupState","columnGroupState","node","isExpanded","impactedGroups","groupKey","newValue","log","setExpanded","updateGroupsAndDisplayedColumns","EVENT_COLUMN_GROUP_OPENED","setColumnGroupOpened","keyAsString","calculateColumnsForDisplay","columnsForDisplay","isAutoGroupCol","includes","isValueCol","checkColSpanActiveInCols","calculateColumnsForGroupDisplay","groupDisplayColumns","checkFunc","showRowGroup","getGroupDisplayColumns","buildDisplayedTrees","isSecondaryColumnsPresent","setSecondaryColumns","colDefs","newColsPresent","processSecondaryColumnDefinitions","secondaryBalancedTree","getProcessSecondaryColDefFunc","groupCallback","getProcessSecondaryColGroupDefFunc","searchForColDefs","colDefs2","abstractColDef","isGroup","children","gridColsArePrimary","lastPrimaryOrder","orderGridColsLikeLastPrimary","addAutoGroupToGridColumns","autoHeight","setupQuickFilterColumns","clearDisplayedColumns","EVENT_GRID_COLUMNS_CHANGED","noColsFound","oldColsOrdered","newColsOrdered","newGridColumns","newCol","parent","getOriginalParent","siblings","leafCols","leafCol","presentInNewGriColumns","noYetInSiblings","lastIndex","insertIntoArray","isPrimaryColumnGroupsPresent","locked","unlocked","createGroupAutoColumnsIfNeeded","autoColBalancedTree","createForAutoGroups","displayedLeftHeaderRows","displayedRightHeaderRows","displayedCentreHeaderRows","updateOpenClosedVisibilityInColumnGroups","updateDisplayedColumnsFromTrees","EVENT_DISPLAYED_COLUMNS_CHANGED","addToDisplayedColumns","setupAllDisplayedColumns","setLeftValuesOfColumns","setLeftValuesOfGroups","allColumns","doingRtl","left_1","setLeft","left_2","removeAllFromArray","checkLeft","displayedColumnTree","depthFirstDisplayedColumnTreeSearch","updateDisplayedCenterVirtualColumns","filterOutColumnsWithinViewport","getVirtualHeaderGroupRow","dept","updateDisplayedVirtualGroups","virtualColIds","testGroup","returnValue","addThisItem","getDisplayedChildren","updatedFlexViewportWidth","silent","flexViewportWidth","knownWidthColumns","flexingColumns","flexingColumnSizes","spaceForFlexingColumns","outer","totalFlex","reduce","count","widthByFlexRule","constrainedWidth","remainingSpace","fireResizedEventForColumns","sizeColumnsToFit","gridWidth","colsToSpread","colsToNotSpread","suppressSizeToFit","colsToFireEventFor","finishedResizing","moveToNotSpread","resetActualWidth","availablePixels","setMinimum","scale","pixelsForLastCol","onLastCol","visibleColumns","leftVisibleColumns","rightVisibleColumns","centerVisibleColumns","groupInstanceIdCreator","displayedGroupCreator","createDisplayedGroups","calculateDisplayedColumns","getGroupAutoColumns","groupFullWidthRow","isGroupUseEntireRow","suppressAutoColumn","isPivotSuppressAutoColumn","isGroupSuppressAutoColumn","groupSuppressRow","isGroupSuppressRow","groupingActive","needAutoColumns","newAutoGroupCols","autoGroupColService","createAutoGroupColumns","autoColsDifferent","autoColsEqual","colsA","colsB","a","getGridBalancedTree","hasFloatingFilters","defaultColDef","getDefaultColDef","floatingFilter","getFirstDisplayedColumn","isRtl","queryOrder","reverse","container"],"mappings":"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","sourcesContent":["/**\n * @ag-grid-community/core - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v23.2.1\n * @link http://www.ag-grid.com/\n * @license MIT\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { ColumnGroup } from '../entities/columnGroup';\nimport { Column } from '../entities/column';\nimport { Events } from '../events';\nimport { BeanStub } from \"../context/beanStub\";\nimport { OriginalColumnGroup } from '../entities/originalColumnGroup';\nimport { GroupInstanceIdCreator } from './groupInstanceIdCreator';\nimport { Autowired, Bean, Optional, PostConstruct, Qualifier } from '../context/context';\nimport { Constants } from '../constants';\nimport { areEqual } from '../utils/array';\nimport { _ } from '../utils';\nvar ColumnController = /** @class */ (function (_super) {\n    __extends(ColumnController, _super);\n    function ColumnController() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // header row count, based on user provided columns\n        _this.primaryHeaderRowCount = 0;\n        _this.secondaryHeaderRowCount = 0;\n        _this.secondaryColumnsPresent = false;\n        // header row count, either above, or based on pivoting if we are pivoting\n        _this.gridHeaderRowCount = 0;\n        // these are the lists used by the rowRenderer to render nodes. almost the leaf nodes of the above\n        // displayed trees, however it also takes into account if the groups are open or not.\n        _this.displayedLeftColumns = [];\n        _this.displayedRightColumns = [];\n        _this.displayedCenterColumns = [];\n        // all three lists above combined\n        _this.allDisplayedColumns = [];\n        // same as above, except trimmed down to only columns within the viewport\n        _this.allDisplayedVirtualColumns = [];\n        _this.allDisplayedCenterVirtualColumns = [];\n        _this.rowGroupColumns = [];\n        _this.valueColumns = [];\n        _this.pivotColumns = [];\n        _this.ready = false;\n        _this.autoGroupsNeedBuilding = false;\n        _this.forceRecreateAutoGroups = false;\n        _this.pivotMode = false;\n        _this.bodyWidth = 0;\n        _this.leftWidth = 0;\n        _this.rightWidth = 0;\n        _this.bodyWidthDirty = true;\n        _this.flexActive = false;\n        return _this;\n    }\n    ColumnController.prototype.init = function () {\n        this.suppressColumnVirtualisation = this.gridOptionsWrapper.isSuppressColumnVirtualisation();\n        var pivotMode = this.gridOptionsWrapper.isPivotMode();\n        if (this.isPivotSettingAllowed(pivotMode)) {\n            this.pivotMode = pivotMode;\n        }\n        this.usingTreeData = this.gridOptionsWrapper.isTreeData();\n        this.addManagedListener(this.gridOptionsWrapper, 'autoGroupColumnDef', this.onAutoGroupColumnDefChanged.bind(this));\n    };\n    ColumnController.prototype.onAutoGroupColumnDefChanged = function () {\n        this.autoGroupsNeedBuilding = true;\n        this.forceRecreateAutoGroups = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns('gridOptionsChanged');\n    };\n    ColumnController.prototype.setColumnDefs = function (columnDefs, source) {\n        if (source === void 0) { source = 'api'; }\n        var colsPreviouslyExisted = !!this.columnDefs;\n        this.columnDefs = columnDefs;\n        // always invalidate cache on changing columns, as the column id's for the new columns\n        // could overlap with the old id's, so the cache would return old values for new columns.\n        this.valueCache.expire();\n        // NOTE ==================\n        // we should be destroying the existing columns and groups if they exist, for example, the original column\n        // group adds a listener to the columns, it should be also removing the listeners\n        this.autoGroupsNeedBuilding = true;\n        var oldPrimaryColumns = this.primaryColumns;\n        var balancedTreeResult = this.columnFactory.createColumnTree(columnDefs, true, oldPrimaryColumns);\n        this.primaryColumnTree = balancedTreeResult.columnTree;\n        this.primaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n        this.primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        this.extractRowGroupColumns(source, oldPrimaryColumns);\n        this.extractPivotColumns(source, oldPrimaryColumns);\n        this.createValueColumns(source, oldPrimaryColumns);\n        this.ready = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        this.checkDisplayedVirtualColumns();\n        if (this.gridOptionsWrapper.isImmutableColumns() && colsPreviouslyExisted) {\n            this.resetColumnState(true, source);\n        }\n        var eventEverythingChanged = {\n            type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(eventEverythingChanged);\n        var newColumnsLoadedEvent = {\n            type: Events.EVENT_NEW_COLUMNS_LOADED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(newColumnsLoadedEvent);\n        this.flexActive = this.getDisplayedCenterColumns().some(function (col) { return !!col.getFlex(); });\n    };\n    ColumnController.prototype.isAutoRowHeightActive = function () {\n        return this.autoRowHeightColumns && this.autoRowHeightColumns.length > 0;\n    };\n    ColumnController.prototype.getAllAutoRowHeightCols = function () {\n        return this.autoRowHeightColumns;\n    };\n    ColumnController.prototype.setVirtualViewportLeftAndRight = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.viewportLeft = this.bodyWidth - this.scrollPosition - this.scrollWidth;\n            this.viewportRight = this.bodyWidth - this.scrollPosition;\n        }\n        else {\n            this.viewportLeft = this.scrollPosition;\n            this.viewportRight = this.scrollWidth + this.scrollPosition;\n        }\n    };\n    // used by clipboard service, to know what columns to paste into\n    ColumnController.prototype.getDisplayedColumnsStartingAt = function (column) {\n        var currentColumn = column;\n        var columns = [];\n        while (currentColumn != null) {\n            columns.push(currentColumn);\n            currentColumn = this.getDisplayedColAfter(currentColumn);\n        }\n        return columns;\n    };\n    // checks what columns are currently displayed due to column virtualisation. fires an event\n    // if the list of columns has changed.\n    // + setColumnWidth(), setVirtualViewportPosition(), setColumnDefs(), sizeColumnsToFit()\n    ColumnController.prototype.checkDisplayedVirtualColumns = function () {\n        // check displayCenterColumnTree exists first, as it won't exist when grid is initialising\n        if (this.displayedCenterColumns == null) {\n            return;\n        }\n        var hashBefore = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');\n        this.updateVirtualSets();\n        var hashAfter = this.allDisplayedVirtualColumns.map(function (column) { return column.getId(); }).join('#');\n        if (hashBefore !== hashAfter) {\n            var event_1 = {\n                type: Events.EVENT_VIRTUAL_COLUMNS_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_1);\n        }\n    };\n    ColumnController.prototype.setVirtualViewportPosition = function (scrollWidth, scrollPosition) {\n        if (scrollWidth !== this.scrollWidth || scrollPosition !== this.scrollPosition || this.bodyWidthDirty) {\n            this.scrollWidth = scrollWidth;\n            this.scrollPosition = scrollPosition;\n            // we need to call setVirtualViewportLeftAndRight() at least once after the body width changes,\n            // as the viewport can stay the same, but in RTL, if body width changes, we need to work out the\n            // virtual columns again\n            this.bodyWidthDirty = true;\n            this.setVirtualViewportLeftAndRight();\n            if (this.ready) {\n                this.checkDisplayedVirtualColumns();\n            }\n        }\n    };\n    ColumnController.prototype.isPivotMode = function () {\n        return this.pivotMode;\n    };\n    ColumnController.prototype.isPivotSettingAllowed = function (pivot) {\n        if (pivot && this.gridOptionsWrapper.isTreeData()) {\n            console.warn(\"ag-Grid: Pivot mode not available in conjunction Tree Data i.e. 'gridOptions.treeData: true'\");\n            return false;\n        }\n        return true;\n    };\n    ColumnController.prototype.setPivotMode = function (pivotMode, source) {\n        if (source === void 0) { source = 'api'; }\n        if (pivotMode === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode)) {\n            return;\n        }\n        this.pivotMode = pivotMode;\n        // we need to update grid columns to cover the scenario where user has groupSuppressAutoColumn=true, as\n        // this means we don't use auto group column UNLESS we are in pivot mode (it's mandatory in pivot mode),\n        // so need to updateGridColumn() to check it autoGroupCol needs to be added / removed\n        this.autoGroupsNeedBuilding = true;\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: Events.EVENT_COLUMN_PIVOT_MODE_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.getSecondaryPivotColumn = function (pivotKeys, valueColKey) {\n        if (!this.secondaryColumnsPresent || !this.secondaryColumns) {\n            return null;\n        }\n        var valueColumnToFind = this.getPrimaryColumn(valueColKey);\n        var foundColumn = null;\n        this.secondaryColumns.forEach(function (column) {\n            var thisPivotKeys = column.getColDef().pivotKeys;\n            var pivotValueColumn = column.getColDef().pivotValueColumn;\n            var pivotKeyMatches = areEqual(thisPivotKeys, pivotKeys);\n            var pivotValueMatches = pivotValueColumn === valueColumnToFind;\n            if (pivotKeyMatches && pivotValueMatches) {\n                foundColumn = column;\n            }\n        });\n        return foundColumn;\n    };\n    ColumnController.prototype.setBeans = function (loggerFactory) {\n        this.logger = loggerFactory.create('ColumnController');\n    };\n    ColumnController.prototype.setFirstRightAndLastLeftPinned = function (source) {\n        var lastLeft;\n        var firstRight;\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            lastLeft = this.displayedLeftColumns ? this.displayedLeftColumns[0] : null;\n            firstRight = this.displayedRightColumns ? _.last(this.displayedRightColumns) : null;\n        }\n        else {\n            lastLeft = this.displayedLeftColumns ? _.last(this.displayedLeftColumns) : null;\n            firstRight = this.displayedRightColumns ? this.displayedRightColumns[0] : null;\n        }\n        this.gridColumns.forEach(function (column) {\n            column.setLastLeftPinned(column === lastLeft, source);\n            column.setFirstRightPinned(column === firstRight, source);\n        });\n    };\n    ColumnController.prototype.autoSizeColumns = function (keys, skipHeader, source) {\n        // because of column virtualisation, we can only do this function on columns that are\n        // actually rendered, as non-rendered columns (outside the viewport and not rendered\n        // due to column virtualisation) are not present. this can result in all rendered columns\n        // getting narrowed, which in turn introduces more rendered columns on the RHS which\n        // did not get autosized in the original run, leaving the visible grid with columns on\n        // the LHS sized, but RHS no. so we keep looping through the visible columns until\n        // no more cols are available (rendered) to be resized\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        // we autosize after animation frames finish in case any cell renderers need to complete first. this can\n        // happen eg if client code is calling api.autoSizeAllColumns() straight after grid is initialised, but grid\n        // hasn't fully drawn out all the cells yet (due to cell renderers in animation frames).\n        this.animationFrameService.flushAllFrames();\n        // keep track of which cols we have resized in here\n        var columnsAutosized = [];\n        // initialise with anything except 0 so that while loop executes at least once\n        var changesThisTimeAround = -1;\n        if (skipHeader == null) {\n            skipHeader = this.gridOptionsWrapper.isSkipHeaderOnAutoSize();\n        }\n        while (changesThisTimeAround !== 0) {\n            changesThisTimeAround = 0;\n            this.actionOnGridColumns(keys, function (column) {\n                // if already autosized, skip it\n                if (columnsAutosized.indexOf(column) >= 0) {\n                    return false;\n                }\n                // get how wide this col should be\n                var preferredWidth = _this.autoWidthCalculator.getPreferredWidthForColumn(column, skipHeader);\n                // preferredWidth = -1 if this col is not on the screen\n                if (preferredWidth > 0) {\n                    var newWidth = _this.normaliseColumnWidth(column, preferredWidth);\n                    column.setActualWidth(newWidth, source);\n                    columnsAutosized.push(column);\n                    changesThisTimeAround++;\n                }\n                return true;\n            }, source);\n        }\n        if (columnsAutosized.length) {\n            var event_2 = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: columnsAutosized,\n                column: columnsAutosized.length === 1 ? columnsAutosized[0] : null,\n                finished: true,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: \"autosizeColumns\"\n            };\n            this.eventService.dispatchEvent(event_2);\n        }\n    };\n    ColumnController.prototype.autoSizeColumn = function (key, skipHeader, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.autoSizeColumns([key], skipHeader, source);\n        }\n    };\n    ColumnController.prototype.autoSizeAllColumns = function (skipHeader, source) {\n        if (source === void 0) { source = \"api\"; }\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        this.autoSizeColumns(allDisplayedColumns, skipHeader, source);\n    };\n    ColumnController.prototype.getColumnsFromTree = function (rootColumns) {\n        var result = [];\n        var recursiveFindColumns = function (childColumns) {\n            for (var i = 0; i < childColumns.length; i++) {\n                var child = childColumns[i];\n                if (child instanceof Column) {\n                    result.push(child);\n                }\n                else if (child instanceof OriginalColumnGroup) {\n                    recursiveFindColumns(child.getChildren());\n                }\n            }\n        };\n        recursiveFindColumns(rootColumns);\n        return result;\n    };\n    ColumnController.prototype.getAllDisplayedColumnGroups = function () {\n        if (this.displayedLeftColumnTree && this.displayedRightColumnTree && this.displayedCentreColumnTree) {\n            return this.displayedLeftColumnTree\n                .concat(this.displayedCentreColumnTree)\n                .concat(this.displayedRightColumnTree);\n        }\n        return null;\n    };\n    // + columnSelectPanel\n    ColumnController.prototype.getPrimaryColumnTree = function () {\n        return this.primaryColumnTree;\n    };\n    // + gridPanel -> for resizing the body and setting top margin\n    ColumnController.prototype.getHeaderRowCount = function () {\n        return this.gridHeaderRowCount;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getLeftDisplayedColumnGroups = function () {\n        return this.displayedLeftColumnTree;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getRightDisplayedColumnGroups = function () {\n        return this.displayedRightColumnTree;\n    };\n    // + headerRenderer -> setting pinned body width\n    ColumnController.prototype.getCenterDisplayedColumnGroups = function () {\n        return this.displayedCentreColumnTree;\n    };\n    ColumnController.prototype.getDisplayedColumnGroups = function (type) {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getLeftDisplayedColumnGroups();\n            case Constants.PINNED_RIGHT:\n                return this.getRightDisplayedColumnGroups();\n            default:\n                return this.getCenterDisplayedColumnGroups();\n        }\n    };\n    // gridPanel -> ensureColumnVisible\n    ColumnController.prototype.isColumnDisplayed = function (column) {\n        return this.getAllDisplayedColumns().indexOf(column) >= 0;\n    };\n    // + csvCreator\n    ColumnController.prototype.getAllDisplayedColumns = function () {\n        return this.allDisplayedColumns;\n    };\n    ColumnController.prototype.getAllDisplayedVirtualColumns = function () {\n        return this.allDisplayedVirtualColumns;\n    };\n    ColumnController.prototype.getDisplayedLeftColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedLeftColumns;\n        }\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedLeftColumns);\n    };\n    ColumnController.prototype.getDisplayedRightColumnsForRow = function (rowNode) {\n        if (!this.colSpanActive) {\n            return this.displayedRightColumns;\n        }\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedRightColumns);\n    };\n    ColumnController.prototype.getDisplayedColumnsForRow = function (rowNode, displayedColumns, filterCallback, emptySpaceBeforeColumn) {\n        var result = [];\n        var lastConsideredCol = null;\n        var _loop_1 = function (i) {\n            var col = displayedColumns[i];\n            var maxAllowedColSpan = displayedColumns.length - i;\n            var colSpan = Math.min(col.getColSpan(rowNode), maxAllowedColSpan);\n            var columnsToCheckFilter = [col];\n            if (colSpan > 1) {\n                var colsToRemove = colSpan - 1;\n                for (var j = 1; j <= colsToRemove; j++) {\n                    columnsToCheckFilter.push(displayedColumns[i + j]);\n                }\n                i += colsToRemove;\n            }\n            // see which cols we should take out for column virtualisation\n            var filterPasses;\n            if (filterCallback) {\n                // if user provided a callback, means some columns may not be in the viewport.\n                // the user will NOT provide a callback if we are talking about pinned areas,\n                // as pinned areas have no horizontal scroll and do not virtualise the columns.\n                // if lots of columns, that means column spanning, and we set filterPasses = true\n                // if one or more of the columns spanned pass the filter.\n                filterPasses = false;\n                columnsToCheckFilter.forEach(function (colForFilter) {\n                    if (filterCallback(colForFilter)) {\n                        filterPasses = true;\n                    }\n                });\n            }\n            else {\n                filterPasses = true;\n            }\n            if (filterPasses) {\n                if (result.length === 0 && lastConsideredCol) {\n                    var gapBeforeColumn = emptySpaceBeforeColumn ? emptySpaceBeforeColumn(col) : false;\n                    if (gapBeforeColumn) {\n                        result.push(lastConsideredCol);\n                    }\n                }\n                result.push(col);\n            }\n            lastConsideredCol = col;\n            out_i_1 = i;\n        };\n        var out_i_1;\n        for (var i = 0; i < displayedColumns.length; i++) {\n            _loop_1(i);\n            i = out_i_1;\n        }\n        return result;\n    };\n    // + rowRenderer\n    // if we are not column spanning, this just returns back the virtual centre columns,\n    // however if we are column spanning, then different rows can have different virtual\n    // columns, so we have to work out the list for each individual row.\n    ColumnController.prototype.getAllDisplayedCenterVirtualColumnsForRow = function (rowNode) {\n        var _this = this;\n        if (!this.colSpanActive) {\n            return this.allDisplayedCenterVirtualColumns;\n        }\n        var emptySpaceBeforeColumn = function (col) { return col.getLeft() > _this.viewportLeft; };\n        // if doing column virtualisation, then we filter based on the viewport.\n        var filterCallback = this.suppressColumnVirtualisation ? null : this.isColumnInViewport.bind(this);\n        return this.getDisplayedColumnsForRow(rowNode, this.displayedCenterColumns, filterCallback, emptySpaceBeforeColumn);\n    };\n    ColumnController.prototype.isColumnInViewport = function (col) {\n        var columnLeft = col.getLeft();\n        var columnRight = col.getLeft() + col.getActualWidth();\n        // adding 200 for buffer size, so some cols off viewport are rendered.\n        // this helps horizontal scrolling so user rarely sees white space (unless\n        // they scroll horizontally fast). however we are conservative, as the more\n        // buffer the slower the vertical redraw speed\n        var leftBounds = this.viewportLeft - 200;\n        var rightBounds = this.viewportRight + 200;\n        var columnToMuchLeft = columnLeft < leftBounds && columnRight < leftBounds;\n        var columnToMuchRight = columnLeft > rightBounds && columnRight > rightBounds;\n        return !columnToMuchLeft && !columnToMuchRight;\n    };\n    // used by:\n    // + angularGrid -> setting pinned body width\n    // note: this should be cached\n    ColumnController.prototype.getPinnedLeftContainerWidth = function () {\n        return this.getWidthOfColsInList(this.displayedLeftColumns);\n    };\n    // note: this should be cached\n    ColumnController.prototype.getPinnedRightContainerWidth = function () {\n        return this.getWidthOfColsInList(this.displayedRightColumns);\n    };\n    ColumnController.prototype.updatePrimaryColumnList = function (keys, masterList, actionIsAdd, columnCallback, eventType, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (!keys || _.missingOrEmpty(keys)) {\n            return;\n        }\n        var atLeastOne = false;\n        keys.forEach(function (key) {\n            var columnToAdd = _this.getPrimaryColumn(key);\n            if (!columnToAdd) {\n                return;\n            }\n            if (actionIsAdd) {\n                if (masterList.indexOf(columnToAdd) >= 0) {\n                    return;\n                }\n                masterList.push(columnToAdd);\n            }\n            else {\n                if (masterList.indexOf(columnToAdd) < 0) {\n                    return;\n                }\n                _.removeFromArray(masterList, columnToAdd);\n            }\n            columnCallback(columnToAdd);\n            atLeastOne = true;\n        });\n        if (!atLeastOne) {\n            return;\n        }\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: eventType,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.setRowGroupColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.setPrimaryColumnList(colKeys, this.rowGroupColumns, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.setRowGroupActive.bind(this), source);\n    };\n    ColumnController.prototype.setRowGroupActive = function (active, column, source) {\n        if (active === column.isRowGroupActive()) {\n            return;\n        }\n        column.setRowGroupActive(active, source);\n        if (!active && !this.gridOptionsWrapper.isSuppressMakeColumnVisibleAfterUnGroup()) {\n            column.setVisible(true, source);\n        }\n    };\n    ColumnController.prototype.addRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.addRowGroupColumns([key], source);\n        }\n    };\n    ColumnController.prototype.addRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, true, this.setRowGroupActive.bind(this, true), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnController.prototype.removeRowGroupColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.autoGroupsNeedBuilding = true;\n        this.updatePrimaryColumnList(keys, this.rowGroupColumns, false, this.setRowGroupActive.bind(this, false), Events.EVENT_COLUMN_ROW_GROUP_CHANGED, source);\n    };\n    ColumnController.prototype.removeRowGroupColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.removeRowGroupColumns([key], source);\n        }\n    };\n    ColumnController.prototype.addPivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, true, function (column) { return column.setPivotActive(true, source); }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnController.prototype.setPivotColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.pivotColumns, Events.EVENT_COLUMN_PIVOT_CHANGED, function (added, column) {\n            column.setPivotActive(added, source);\n        }, source);\n    };\n    ColumnController.prototype.addPivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.addPivotColumns([key], source);\n    };\n    ColumnController.prototype.removePivotColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.pivotColumns, false, function (column) { return column.setPivotActive(false, source); }, Events.EVENT_COLUMN_PIVOT_CHANGED, source);\n    };\n    ColumnController.prototype.removePivotColumn = function (key, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removePivotColumns([key], source);\n    };\n    ColumnController.prototype.setPrimaryColumnList = function (colKeys, masterList, eventName, columnCallback, source) {\n        var _this = this;\n        masterList.length = 0;\n        if (_.exists(colKeys)) {\n            colKeys.forEach(function (key) {\n                var column = _this.getPrimaryColumn(key);\n                if (column) {\n                    masterList.push(column);\n                }\n            });\n        }\n        this.primaryColumns.forEach(function (column) {\n            var added = masterList.indexOf(column) >= 0;\n            columnCallback(added, column);\n        });\n        if (this.autoGroupsNeedBuilding) {\n            this.updateGridColumns();\n        }\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: eventName,\n            columns: masterList,\n            column: masterList.length === 1 ? masterList[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.setValueColumns = function (colKeys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setPrimaryColumnList(colKeys, this.valueColumns, Events.EVENT_COLUMN_VALUE_CHANGED, this.setValueActive.bind(this), source);\n    };\n    ColumnController.prototype.setValueActive = function (active, column, source) {\n        if (active === column.isValueActive()) {\n            return;\n        }\n        column.setValueActive(active, source);\n        if (active && !column.getAggFunc()) {\n            var defaultAggFunc = this.aggFuncService.getDefaultAggFunc(column);\n            column.setAggFunc(defaultAggFunc);\n        }\n    };\n    ColumnController.prototype.addValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, true, this.setValueActive.bind(this, true), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    ColumnController.prototype.addValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (colKey) {\n            this.addValueColumns([colKey], source);\n        }\n    };\n    ColumnController.prototype.removeValueColumn = function (colKey, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.removeValueColumns([colKey], source);\n    };\n    ColumnController.prototype.removeValueColumns = function (keys, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.updatePrimaryColumnList(keys, this.valueColumns, false, this.setValueActive.bind(this, false), Events.EVENT_COLUMN_VALUE_CHANGED, source);\n    };\n    // returns the width we can set to this col, taking into consideration min and max widths\n    ColumnController.prototype.normaliseColumnWidth = function (column, newWidth) {\n        if (newWidth < column.getMinWidth()) {\n            newWidth = column.getMinWidth();\n        }\n        if (column.isGreaterThanMax(newWidth)) {\n            newWidth = column.getMaxWidth();\n        }\n        return newWidth;\n    };\n    ColumnController.prototype.getPrimaryOrGridColumn = function (key) {\n        var column = this.getPrimaryColumn(key);\n        return column || this.getGridColumn(key);\n    };\n    ColumnController.prototype.setColumnWidths = function (columnWidths, shiftKey, // @takeFromAdjacent - if user has 'shift' pressed, then pixels are taken from adjacent column\n    finished, // @finished - ends up in the event, tells the user if more events are to come\n    source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        var sets = [];\n        columnWidths.forEach(function (columnWidth) {\n            var col = _this.getPrimaryOrGridColumn(columnWidth.key);\n            if (!col) {\n                return;\n            }\n            sets.push({\n                width: columnWidth.newWidth,\n                ratios: [1],\n                columns: [col]\n            });\n            // if user wants to do shift resize by default, then we invert the shift operation\n            var defaultIsShift = _this.gridOptionsWrapper.getColResizeDefault() === 'shift';\n            if (defaultIsShift) {\n                shiftKey = !shiftKey;\n            }\n            if (shiftKey) {\n                var otherCol = _this.getDisplayedColAfter(col);\n                if (!otherCol) {\n                    return;\n                }\n                var widthDiff = col.getActualWidth() - columnWidth.newWidth;\n                var otherColWidth = otherCol.getActualWidth() + widthDiff;\n                sets.push({\n                    width: otherColWidth,\n                    ratios: [1],\n                    columns: [otherCol]\n                });\n            }\n        });\n        if (sets.length === 0) {\n            return;\n        }\n        this.resizeColumnSets(sets, finished, source);\n        if (this.flexActive) {\n            this.refreshFlexedColumns();\n        }\n    };\n    ColumnController.prototype.checkMinAndMaxWidthsForSet = function (columnResizeSet) {\n        var columns = columnResizeSet.columns, width = columnResizeSet.width;\n        // every col has a min width, so sum them all up and see if we have enough room\n        // for all the min widths\n        var minWidthAccumulated = 0;\n        var maxWidthAccumulated = 0;\n        var maxWidthActive = true;\n        columns.forEach(function (col) {\n            minWidthAccumulated += col.getMinWidth();\n            if (col.getMaxWidth() > 0) {\n                maxWidthAccumulated += col.getMaxWidth();\n            }\n            else {\n                // if at least one columns has no max width, it means the group of columns\n                // then has no max width, as at least one column can take as much width as possible\n                maxWidthActive = false;\n            }\n        });\n        var minWidthPasses = width >= minWidthAccumulated;\n        var maxWidthPasses = !maxWidthActive || (width <= maxWidthAccumulated);\n        return minWidthPasses && maxWidthPasses;\n    };\n    // method takes sets of columns and resizes them. either all sets will be resized, or nothing\n    // be resized. this is used for example when user tries to resize a group and holds shift key,\n    // then both the current group (grows), and the adjacent group (shrinks), will get resized,\n    // so that's two sets for this method.\n    ColumnController.prototype.resizeColumnSets = function (resizeSets, finished, source) {\n        var passMinMaxCheck = !resizeSets || resizeSets.every(this.checkMinAndMaxWidthsForSet.bind(this));\n        if (!passMinMaxCheck) {\n            // even though we are not going to resize beyond min/max size, we still need to raise event when finished\n            if (finished) {\n                var columns = resizeSets && resizeSets.length > 0 ? resizeSets[0].columns : null;\n                var event_3 = {\n                    type: Events.EVENT_COLUMN_RESIZED,\n                    columns: columns,\n                    column: columns && columns.length === 1 ? columns[0] : null,\n                    finished: finished,\n                    api: this.gridApi,\n                    columnApi: this.columnApi,\n                    source: source\n                };\n                this.eventService.dispatchEvent(event_3);\n            }\n            return; // don't resize!\n        }\n        var changedCols = [];\n        var allCols = [];\n        resizeSets.forEach(function (set) {\n            var width = set.width, columns = set.columns, ratios = set.ratios;\n            // keep track of pixels used, and last column gets the remaining,\n            // to cater for rounding errors, and min width adjustments\n            var newWidths = {};\n            var finishedCols = {};\n            columns.forEach(function (col) { return allCols.push(col); });\n            // the loop below goes through each col. if a col exceeds it's min/max width,\n            // it then gets set to its min/max width and the column is removed marked as 'finished'\n            // and the calculation is done again leaving this column out. take for example columns\n            // {A, width: 50, maxWidth: 100}\n            // {B, width: 50}\n            // {C, width: 50}\n            // and then the set is set to width 600 - on the first pass the grid tries to set each column\n            // to 200. it checks A and sees 200 > 100 and so sets the width to 100. col A is then marked\n            // as 'finished' and the calculation is done again with the remaining cols B and C, which end up\n            // splitting the remaining 500 pixels.\n            var finishedColsGrew = true;\n            var loopCount = 0;\n            var _loop_2 = function () {\n                loopCount++;\n                if (loopCount > 1000) {\n                    // this should never happen, but in the future, someone might introduce a bug here,\n                    // so we stop the browser from hanging and report bug properly\n                    console.error('ag-Grid: infinite loop in resizeColumnSets');\n                    return \"break\";\n                }\n                finishedColsGrew = false;\n                var subsetCols = [];\n                var subsetRatios = [];\n                var subsetRatioTotal = 0;\n                var pixelsToDistribute = width;\n                columns.forEach(function (col, index) {\n                    var thisColFinished = finishedCols[col.getId()];\n                    if (thisColFinished) {\n                        pixelsToDistribute -= newWidths[col.getId()];\n                    }\n                    else {\n                        subsetCols.push(col);\n                        var ratioThisCol = ratios[index];\n                        subsetRatioTotal += ratioThisCol;\n                        subsetRatios.push(ratioThisCol);\n                    }\n                });\n                // because we are not using all of the ratios (cols can be missing),\n                // we scale the ratio. if all columns are included, then subsetRatioTotal=1,\n                // and so the ratioScale will be 1.\n                var ratioScale = 1 / subsetRatioTotal;\n                subsetCols.forEach(function (col, index) {\n                    var lastCol = index === (subsetCols.length - 1);\n                    var colNewWidth;\n                    if (lastCol) {\n                        colNewWidth = pixelsToDistribute;\n                    }\n                    else {\n                        colNewWidth = Math.round(ratios[index] * width * ratioScale);\n                        pixelsToDistribute -= colNewWidth;\n                    }\n                    if (colNewWidth < col.getMinWidth()) {\n                        colNewWidth = col.getMinWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    else if (col.getMaxWidth() > 0 && colNewWidth > col.getMaxWidth()) {\n                        colNewWidth = col.getMaxWidth();\n                        finishedCols[col.getId()] = true;\n                        finishedColsGrew = true;\n                    }\n                    newWidths[col.getId()] = colNewWidth;\n                });\n            };\n            while (finishedColsGrew) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            columns.forEach(function (col) {\n                var newWidth = newWidths[col.getId()];\n                if (col.getActualWidth() !== newWidth) {\n                    col.setActualWidth(newWidth, source);\n                    changedCols.push(col);\n                }\n            });\n        });\n        // if no cols changed, then no need to update more or send event.\n        var atLeastOneColChanged = changedCols.length > 0;\n        if (atLeastOneColChanged) {\n            this.setLeftValues(source);\n            this.updateBodyWidths();\n            this.checkDisplayedVirtualColumns();\n        }\n        // check for change first, to avoid unnecessary firing of events\n        // however we always fire 'finished' events. this is important\n        // when groups are resized, as if the group is changing slowly,\n        // eg 1 pixel at a time, then each change will fire change events\n        // in all the columns in the group, but only one with get the pixel.\n        if (atLeastOneColChanged || finished) {\n            var event_4 = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                columns: allCols,\n                column: allCols.length === 1 ? allCols[0] : null,\n                finished: finished,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_4);\n        }\n    };\n    ColumnController.prototype.setColumnAggFunc = function (column, aggFunc, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (!column) {\n            return;\n        }\n        column.setAggFunc(aggFunc);\n        var event = {\n            type: Events.EVENT_COLUMN_VALUE_CHANGED,\n            columns: [column],\n            column: column,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.moveRowGroupColumn = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.rowGroupColumns[fromIndex];\n        this.rowGroupColumns.splice(fromIndex, 1);\n        this.rowGroupColumns.splice(toIndex, 0, column);\n        var event = {\n            type: Events.EVENT_COLUMN_ROW_GROUP_CHANGED,\n            columns: this.rowGroupColumns,\n            column: this.rowGroupColumns.length === 1 ? this.rowGroupColumns[0] : null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.moveColumns = function (columnsToMoveKeys, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        if (toIndex > this.gridColumns.length - columnsToMoveKeys.length) {\n            console.warn('ag-Grid: tried to insert columns in invalid location, toIndex = ' + toIndex);\n            console.warn('ag-Grid: remember that you should not count the moving columns when calculating the new index');\n            return;\n        }\n        // we want to pull all the columns out first and put them into an ordered list\n        var columnsToMove = this.getGridColumns(columnsToMoveKeys);\n        var failedRules = !this.doesMovePassRules(columnsToMove, toIndex);\n        if (failedRules) {\n            return;\n        }\n        _.moveInArray(this.gridColumns, columnsToMove, toIndex);\n        this.updateDisplayedColumns(source);\n        var event = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: columnsToMove,\n            column: columnsToMove.length === 1 ? columnsToMove[0] : null,\n            toIndex: toIndex,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n        this.columnAnimationService.finish();\n    };\n    ColumnController.prototype.doesMovePassRules = function (columnsToMove, toIndex) {\n        // make a copy of what the grid columns would look like after the move\n        var proposedColumnOrder = this.gridColumns.slice();\n        _.moveInArray(proposedColumnOrder, columnsToMove, toIndex);\n        // then check that the new proposed order of the columns passes all rules\n        if (!this.doesMovePassMarryChildren(proposedColumnOrder)) {\n            return false;\n        }\n        if (!this.doesMovePassLockedPositions(proposedColumnOrder)) {\n            return false;\n        }\n        return true;\n    };\n    ColumnController.prototype.doesMovePassLockedPositions = function (proposedColumnOrder) {\n        var foundNonLocked = false;\n        var rulePassed = true;\n        // go though the cols, see if any non-locked appear before any locked\n        proposedColumnOrder.forEach(function (col) {\n            if (col.getColDef().lockPosition) {\n                if (foundNonLocked) {\n                    rulePassed = false;\n                }\n            }\n            else {\n                foundNonLocked = true;\n            }\n        });\n        return rulePassed;\n    };\n    ColumnController.prototype.doesMovePassMarryChildren = function (allColumnsCopy) {\n        var rulePassed = true;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (child) {\n            if (!(child instanceof OriginalColumnGroup)) {\n                return;\n            }\n            var columnGroup = child;\n            var marryChildren = columnGroup.getColGroupDef() && columnGroup.getColGroupDef().marryChildren;\n            if (!marryChildren) {\n                return;\n            }\n            var newIndexes = [];\n            columnGroup.getLeafColumns().forEach(function (col) {\n                var newColIndex = allColumnsCopy.indexOf(col);\n                newIndexes.push(newColIndex);\n            });\n            var maxIndex = Math.max.apply(Math, newIndexes);\n            var minIndex = Math.min.apply(Math, newIndexes);\n            // spread is how far the first column in this group is away from the last column\n            var spread = maxIndex - minIndex;\n            var maxSpread = columnGroup.getLeafColumns().length - 1;\n            // if the columns\n            if (spread > maxSpread) {\n                rulePassed = false;\n            }\n            // console.log(`maxIndex = ${maxIndex}, minIndex = ${minIndex}, spread = ${spread}, maxSpread = ${maxSpread}, fail = ${spread > (count-1)}`)\n            // console.log(allColumnsCopy.map( col => col.getColDef().field).join(','));\n        });\n        return rulePassed;\n    };\n    ColumnController.prototype.moveColumn = function (key, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.moveColumns([key], toIndex, source);\n    };\n    ColumnController.prototype.moveColumnByIndex = function (fromIndex, toIndex, source) {\n        if (source === void 0) { source = \"api\"; }\n        var column = this.gridColumns[fromIndex];\n        this.moveColumn(column, toIndex, source);\n    };\n    // used by:\n    // + angularGrid -> for setting body width\n    // + rowController -> setting main row widths (when inserting and resizing)\n    // need to cache this\n    ColumnController.prototype.getBodyContainerWidth = function () {\n        return this.bodyWidth;\n    };\n    ColumnController.prototype.getContainerWidth = function (pinned) {\n        switch (pinned) {\n            case Constants.PINNED_LEFT:\n                return this.leftWidth;\n            case Constants.PINNED_RIGHT:\n                return this.rightWidth;\n            default:\n                return this.bodyWidth;\n        }\n    };\n    // after setColumnWidth or updateGroupsAndDisplayedColumns\n    ColumnController.prototype.updateBodyWidths = function () {\n        var newBodyWidth = this.getWidthOfColsInList(this.displayedCenterColumns);\n        var newLeftWidth = this.getWidthOfColsInList(this.displayedLeftColumns);\n        var newRightWidth = this.getWidthOfColsInList(this.displayedRightColumns);\n        // this is used by virtual col calculation, for RTL only, as a change to body width can impact displayed\n        // columns, due to RTL inverting the y coordinates\n        this.bodyWidthDirty = this.bodyWidth !== newBodyWidth;\n        var atLeastOneChanged = this.bodyWidth !== newBodyWidth || this.leftWidth !== newLeftWidth || this.rightWidth !== newRightWidth;\n        if (atLeastOneChanged) {\n            this.bodyWidth = newBodyWidth;\n            this.leftWidth = newLeftWidth;\n            this.rightWidth = newRightWidth;\n            // when this fires, it is picked up by the gridPanel, which ends up in\n            // gridPanel calling setWidthAndScrollPosition(), which in turn calls setVirtualViewportPosition()\n            var event_5 = {\n                type: Events.EVENT_DISPLAYED_COLUMNS_WIDTH_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi\n            };\n            this.eventService.dispatchEvent(event_5);\n        }\n    };\n    // + rowController\n    ColumnController.prototype.getValueColumns = function () {\n        return this.valueColumns ? this.valueColumns : [];\n    };\n    // + rowController\n    ColumnController.prototype.getPivotColumns = function () {\n        return this.pivotColumns ? this.pivotColumns : [];\n    };\n    // + clientSideRowModel\n    ColumnController.prototype.isPivotActive = function () {\n        return this.pivotColumns && this.pivotColumns.length > 0 && this.pivotMode;\n    };\n    // + toolPanel\n    ColumnController.prototype.getRowGroupColumns = function () {\n        return this.rowGroupColumns ? this.rowGroupColumns : [];\n    };\n    // + rowController -> while inserting rows\n    ColumnController.prototype.getDisplayedCenterColumns = function () {\n        return this.displayedCenterColumns;\n    };\n    // + rowController -> while inserting rows\n    ColumnController.prototype.getDisplayedLeftColumns = function () {\n        return this.displayedLeftColumns;\n    };\n    ColumnController.prototype.getDisplayedRightColumns = function () {\n        return this.displayedRightColumns;\n    };\n    ColumnController.prototype.getDisplayedColumns = function (type) {\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                return this.getDisplayedLeftColumns();\n            case Constants.PINNED_RIGHT:\n                return this.getDisplayedRightColumns();\n            default:\n                return this.getDisplayedCenterColumns();\n        }\n    };\n    // used by:\n    // + clientSideRowController -> sorting, building quick filter text\n    // + headerRenderer -> sorting (clearing icon)\n    ColumnController.prototype.getAllPrimaryColumns = function () {\n        return this.primaryColumns ? this.primaryColumns.slice() : null;\n    };\n    ColumnController.prototype.getSecondaryColumns = function () {\n        return this.secondaryColumns ? this.secondaryColumns.slice() : null;\n    };\n    ColumnController.prototype.getAllColumnsForQuickFilter = function () {\n        return this.columnsForQuickFilter;\n    };\n    // + moveColumnController\n    ColumnController.prototype.getAllGridColumns = function () {\n        return this.gridColumns;\n    };\n    ColumnController.prototype.isEmpty = function () {\n        return _.missingOrEmpty(this.gridColumns);\n    };\n    ColumnController.prototype.isRowGroupEmpty = function () {\n        return _.missingOrEmpty(this.rowGroupColumns);\n    };\n    ColumnController.prototype.setColumnVisible = function (key, visible, source) {\n        if (source === void 0) { source = \"api\"; }\n        this.setColumnsVisible([key], visible, source);\n    };\n    ColumnController.prototype.setColumnsVisible = function (keys, visible, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        this.actionOnGridColumns(keys, function (column) {\n            if (column.isVisible() !== visible) {\n                column.setVisible(visible, source);\n                return true;\n            }\n            return false;\n        }, source, function () {\n            var event = {\n                type: Events.EVENT_COLUMN_VISIBLE,\n                visible: visible,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    ColumnController.prototype.setColumnPinned = function (key, pinned, source) {\n        if (source === void 0) { source = \"api\"; }\n        if (key) {\n            this.setColumnsPinned([key], pinned, source);\n        }\n    };\n    ColumnController.prototype.setColumnsPinned = function (keys, pinned, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        if (this.gridOptionsWrapper.getDomLayout() === 'print') {\n            console.warn(\"Changing the column pinning status is not allowed with domLayout='print'\");\n            return;\n        }\n        this.columnAnimationService.start();\n        var actualPinned;\n        if (pinned === true || pinned === Constants.PINNED_LEFT) {\n            actualPinned = Constants.PINNED_LEFT;\n        }\n        else if (pinned === Constants.PINNED_RIGHT) {\n            actualPinned = Constants.PINNED_RIGHT;\n        }\n        else {\n            actualPinned = null;\n        }\n        this.actionOnGridColumns(keys, function (col) {\n            if (col.getPinned() !== actualPinned) {\n                col.setPinned(actualPinned);\n                return true;\n            }\n            return false;\n        }, source, function () {\n            var event = {\n                type: Events.EVENT_COLUMN_PINNED,\n                pinned: actualPinned,\n                column: null,\n                columns: null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            return event;\n        });\n        this.columnAnimationService.finish();\n    };\n    // does an action on a set of columns. provides common functionality for looking up the\n    // columns based on key, getting a list of effected columns, and then updated the event\n    // with either one column (if it was just one col) or a list of columns\n    // used by: autoResize, setVisible, setPinned\n    ColumnController.prototype.actionOnGridColumns = function (// the column keys this action will be on\n    keys, \n    // the action to do - if this returns false, the column was skipped\n    // and won't be included in the event\n    action, \n    // should return back a column event of the right type\n    source, createEvent) {\n        var _this = this;\n        if (_.missingOrEmpty(keys)) {\n            return;\n        }\n        var updatedColumns = [];\n        keys.forEach(function (key) {\n            var column = _this.getGridColumn(key);\n            if (!column) {\n                return;\n            }\n            // need to check for false with type (ie !== instead of !=)\n            // as not returning anything (undefined) would also be false\n            var resultOfAction = action(column);\n            if (resultOfAction !== false) {\n                updatedColumns.push(column);\n            }\n        });\n        if (!updatedColumns.length) {\n            return;\n        }\n        this.updateDisplayedColumns(source);\n        if (_.exists(createEvent) && createEvent) {\n            var event_6 = createEvent();\n            event_6.columns = updatedColumns;\n            event_6.column = updatedColumns.length === 1 ? updatedColumns[0] : null;\n            this.eventService.dispatchEvent(event_6);\n        }\n    };\n    ColumnController.prototype.getDisplayedColBefore = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex > 0) {\n            return allDisplayedColumns[oldIndex - 1];\n        }\n        return null;\n    };\n    // used by:\n    // + rowRenderer -> for navigation\n    ColumnController.prototype.getDisplayedColAfter = function (col) {\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        var oldIndex = allDisplayedColumns.indexOf(col);\n        if (oldIndex < (allDisplayedColumns.length - 1)) {\n            return allDisplayedColumns[oldIndex + 1];\n        }\n        return null;\n    };\n    ColumnController.prototype.getDisplayedGroupAfter = function (columnGroup) {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'After');\n    };\n    ColumnController.prototype.getDisplayedGroupBefore = function (columnGroup) {\n        return this.getDisplayedGroupAtDirection(columnGroup, 'Before');\n    };\n    ColumnController.prototype.getDisplayedGroupAtDirection = function (columnGroup, direction) {\n        // pick the last displayed column in this group\n        var requiredLevel = columnGroup.getOriginalColumnGroup().getLevel() + columnGroup.getPaddingLevel();\n        var colGroupLeafColumns = columnGroup.getDisplayedLeafColumns();\n        var col = direction === 'After' ? _.last(colGroupLeafColumns) : colGroupLeafColumns[0];\n        var getDisplayColMethod = \"getDisplayedCol\" + direction;\n        while (true) {\n            // keep moving to the next col, until we get to another group\n            var column = this[getDisplayColMethod](col);\n            if (!column) {\n                return null;\n            }\n            var groupPointer = this.getColumnGroupAtLevel(column, requiredLevel);\n            if (groupPointer !== columnGroup) {\n                return groupPointer;\n            }\n        }\n    };\n    ColumnController.prototype.getColumnGroupAtLevel = function (column, level) {\n        // get group at same level as the one we are looking for\n        var groupPointer = column.getParent();\n        var originalGroupLevel;\n        var groupPointerLevel;\n        while (true) {\n            var groupPointerOriginalColumnGroup = groupPointer.getOriginalColumnGroup();\n            originalGroupLevel = groupPointerOriginalColumnGroup.getLevel();\n            groupPointerLevel = groupPointer.getPaddingLevel();\n            if (originalGroupLevel + groupPointerLevel <= level) {\n                break;\n            }\n            groupPointer = groupPointer.getParent();\n        }\n        return groupPointer;\n    };\n    ColumnController.prototype.isPinningLeft = function () {\n        return this.displayedLeftColumns.length > 0;\n    };\n    ColumnController.prototype.isPinningRight = function () {\n        return this.displayedRightColumns.length > 0;\n    };\n    ColumnController.prototype.getPrimaryAndSecondaryAndAutoColumns = function () {\n        var result = this.primaryColumns ? this.primaryColumns.slice(0) : [];\n        if (this.groupAutoColumns && _.exists(this.groupAutoColumns)) {\n            this.groupAutoColumns.forEach(function (col) { return result.push(col); });\n        }\n        if (this.secondaryColumnsPresent && this.secondaryColumns) {\n            this.secondaryColumns.forEach(function (column) { return result.push(column); });\n        }\n        return result;\n    };\n    ColumnController.prototype.createStateItemFromColumn = function (column) {\n        var rowGroupIndex = column.isRowGroupActive() ? this.rowGroupColumns.indexOf(column) : null;\n        var pivotIndex = column.isPivotActive() ? this.pivotColumns.indexOf(column) : null;\n        var aggFunc = column.isValueActive() ? column.getAggFunc() : null;\n        return {\n            colId: column.getColId(),\n            hide: !column.isVisible(),\n            aggFunc: aggFunc,\n            width: column.getActualWidth(),\n            pivotIndex: pivotIndex,\n            pinned: column.getPinned(),\n            rowGroupIndex: rowGroupIndex,\n            flex: column.getFlex()\n        };\n    };\n    ColumnController.prototype.getColumnState = function () {\n        if (_.missing(this.primaryColumns)) {\n            return [];\n        }\n        var primaryColumnState = this.primaryColumns.map(this.createStateItemFromColumn.bind(this));\n        var groupAutoColumnState = this.groupAutoColumns\n            // if groupAutoCols, then include them\n            ? this.groupAutoColumns.map(this.createStateItemFromColumn.bind(this))\n            // otherwise no\n            : [];\n        var columnStateList = groupAutoColumnState.concat(primaryColumnState);\n        if (!this.pivotMode) {\n            this.orderColumnStateList(columnStateList);\n        }\n        return columnStateList;\n    };\n    ColumnController.prototype.orderColumnStateList = function (columnStateList) {\n        var gridColumnIds = this.gridColumns.map(function (column) { return column.getColId(); });\n        columnStateList.sort(function (itemA, itemB) {\n            var posA = gridColumnIds.indexOf(itemA.colId);\n            var posB = gridColumnIds.indexOf(itemB.colId);\n            return posA - posB;\n        });\n    };\n    ColumnController.prototype.resetColumnState = function (suppressEverythingEvent, source) {\n        // NOTE = there is one bug here that no customer has noticed - if a column has colDef.lockPosition,\n        // this is ignored  below when ordering the cols. to work, we should always put lockPosition cols first.\n        // As a work around, developers should just put lockPosition columns first in their colDef list.\n        if (suppressEverythingEvent === void 0) { suppressEverythingEvent = false; }\n        if (source === void 0) { source = \"api\"; }\n        // we can't use 'allColumns' as the order might of messed up, so get the primary ordered list\n        var primaryColumns = this.getColumnsFromTree(this.primaryColumnTree);\n        var columnStates = [];\n        // we start at 1000, so if user has mix of rowGroup and group specified, it will work with both.\n        // eg IF user has ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=true,\n        // THEN result will be ColA.rowGroupIndex=0, ColB.rowGroupIndex=1, ColC.rowGroup=1000\n        var letRowGroupIndex = 1000;\n        var letPivotIndex = 1000;\n        if (primaryColumns) {\n            primaryColumns.forEach(function (column) {\n                var rowGroupIndex = column.getColDef().rowGroupIndex;\n                var rowGroup = column.getColDef().rowGroup;\n                var pivotIndex = column.getColDef().pivotIndex;\n                var pivot = column.getColDef().pivot;\n                var stateItem = {\n                    colId: column.getColId(),\n                    aggFunc: column.getColDef().aggFunc,\n                    hide: column.getColDef().hide,\n                    pinned: column.getColDef().pinned,\n                    rowGroupIndex: rowGroupIndex,\n                    pivotIndex: column.getColDef().pivotIndex,\n                    width: column.getColDef().width\n                };\n                if (_.missing(rowGroupIndex) && rowGroup) {\n                    stateItem.rowGroupIndex = letRowGroupIndex++;\n                }\n                if (_.missing(pivotIndex) && pivot) {\n                    stateItem.pivotIndex = letPivotIndex++;\n                }\n                columnStates.push(stateItem);\n            });\n        }\n        this.setColumnState(columnStates, suppressEverythingEvent, source);\n    };\n    ColumnController.prototype.setColumnState = function (columnStates, suppressEverythingEvent, source) {\n        var _this = this;\n        if (suppressEverythingEvent === void 0) { suppressEverythingEvent = false; }\n        if (source === void 0) { source = \"api\"; }\n        if (_.missingOrEmpty(this.primaryColumns)) {\n            return false;\n        }\n        var columnStateBefore = this.getColumnState();\n        this.autoGroupsNeedBuilding = true;\n        // at the end below, this list will have all columns we got no state for\n        var columnsWithNoState = this.primaryColumns.slice();\n        this.rowGroupColumns = [];\n        this.valueColumns = [];\n        this.pivotColumns = [];\n        var success = true;\n        var rowGroupIndexes = {};\n        var pivotIndexes = {};\n        var autoGroupColumnStates = [];\n        if (columnStates) {\n            columnStates.forEach(function (state) {\n                // auto group columns are re-created so deferring syncing with ColumnState\n                if (_.exists(_this.getAutoColumn(state.colId))) {\n                    autoGroupColumnStates.push(state);\n                    return;\n                }\n                var column = _this.getPrimaryColumn(state.colId);\n                if (!column) {\n                    console.warn('ag-grid: column ' + state.colId + ' not found');\n                    success = false;\n                }\n                else {\n                    _this.syncColumnWithStateItem(column, state, rowGroupIndexes, pivotIndexes, source);\n                    _.removeFromArray(columnsWithNoState, column);\n                }\n            });\n            if (this.flexActive) {\n                this.refreshFlexedColumns(undefined, undefined, true);\n            }\n        }\n        // anything left over, we got no data for, so add in the column as non-value, non-rowGroup and hidden\n        columnsWithNoState.forEach(this.syncColumnWithNoState.bind(this));\n        // sort the lists according to the indexes that were provided\n        this.rowGroupColumns.sort(this.sortColumnListUsingIndexes.bind(this, rowGroupIndexes));\n        this.pivotColumns.sort(this.sortColumnListUsingIndexes.bind(this, pivotIndexes));\n        this.updateGridColumns();\n        // sync newly created auto group columns with ColumnState\n        autoGroupColumnStates.forEach(function (stateItem) {\n            var autoCol = _this.getAutoColumn(stateItem.colId);\n            _this.syncColumnWithStateItem(autoCol, stateItem, rowGroupIndexes, pivotIndexes, source);\n        });\n        if (columnStates) {\n            var orderOfColIds_1 = columnStates.map(function (stateItem) { return stateItem.colId; });\n            this.gridColumns.sort(function (colA, colB) {\n                var indexA = orderOfColIds_1.indexOf(colA.getId());\n                var indexB = orderOfColIds_1.indexOf(colB.getId());\n                return indexA - indexB;\n            });\n        }\n        // this is already done in updateGridColumns, however we changed the order above (to match the order of the state\n        // columns) so we need to do it again. we could of put logic into the order above to take into account fixed\n        // columns, however if we did then we would have logic for updating fixed columns twice. reusing the logic here\n        // is less sexy for the code here, but it keeps consistency.\n        this.putFixedColumnsFirst();\n        this.updateDisplayedColumns(source);\n        if (!suppressEverythingEvent) {\n            var event_7 = {\n                type: Events.EVENT_COLUMN_EVERYTHING_CHANGED,\n                api: this.gridApi,\n                columnApi: this.columnApi,\n                source: source\n            };\n            this.eventService.dispatchEvent(event_7);\n        }\n        this.raiseColumnEvents(columnStateBefore, source);\n        return success;\n    };\n    ColumnController.prototype.raiseColumnEvents = function (columnStateBefore, source) {\n        var _this = this;\n        if (this.gridOptionsWrapper.isSuppressSetColumnStateEvents()) {\n            return;\n        }\n        var columnStateAfter = this.getColumnState();\n        // raises generic ColumnEvents where all columns are returned rather than what has changed\n        var raiseEventWithAllColumns = function (eventType, idMapper, columns) {\n            var unchanged = areEqual(columnStateBefore.map(idMapper).sort(), columnStateAfter.map(idMapper).sort());\n            if (unchanged) {\n                return;\n            }\n            // returning all columns rather than what has changed!\n            var event = {\n                type: eventType,\n                columns: columns,\n                column: columns.length === 1 ? columns[0] : null,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            _this.eventService.dispatchEvent(event);\n        };\n        // determines which columns have changed according to supplied predicate\n        var getChangedColumns = function (changedPredicate) {\n            var changedColumns = [];\n            var columnStateBeforeMap = {};\n            columnStateBefore.forEach(function (col) {\n                columnStateBeforeMap[col.colId] = col;\n            });\n            _this.gridColumns.forEach(function (column) {\n                var colStateBefore = columnStateBeforeMap[column.getColId()];\n                if (!colStateBefore || changedPredicate(colStateBefore, column)) {\n                    changedColumns.push(column);\n                }\n            });\n            return changedColumns;\n        };\n        // generic ColumnEvents which return current column list\n        var valueColumnIdMapper = function (cs) { return cs.colId + '-' + cs.aggFunc; };\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_VALUE_CHANGED, valueColumnIdMapper, this.valueColumns);\n        var pivotColumnIdMapper = function (cs) { return cs.colId + '-' + cs.pivotIndex; };\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_PIVOT_CHANGED, pivotColumnIdMapper, this.pivotColumns);\n        var rowGroupColumnIdMapper = function (cs) { return cs.colId + '-' + cs.rowGroupIndex; };\n        raiseEventWithAllColumns(Events.EVENT_COLUMN_ROW_GROUP_CHANGED, rowGroupColumnIdMapper, this.rowGroupColumns);\n        // specific ColumnEvents which return what's changed\n        var pinnedChangePredicate = function (cs, c) { return cs.pinned !== c.getPinned(); };\n        this.raiseColumnPinnedEvent(getChangedColumns(pinnedChangePredicate), source);\n        var visibilityChangePredicate = function (cs, c) { return cs.hide === c.isVisible(); };\n        var cols = getChangedColumns(visibilityChangePredicate);\n        this.raiseColumnVisibleEvent(cols, source);\n        var resizeChangePredicate = function (cs, c) { return cs.width !== c.getActualWidth(); };\n        this.raiseColumnResizeEvent(getChangedColumns(resizeChangePredicate), source);\n        // special handling for moved column events\n        this.raiseColumnMovedEvent(columnStateBefore, source);\n    };\n    ColumnController.prototype.raiseColumnPinnedEvent = function (changedColumns, source) {\n        if (!changedColumns.length) {\n            return;\n        }\n        var event = {\n            type: Events.EVENT_COLUMN_PINNED,\n            pinned: null,\n            columns: changedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.raiseColumnVisibleEvent = function (changedColumns, source) {\n        if (!changedColumns.length) {\n            return;\n        }\n        var event = {\n            type: Events.EVENT_COLUMN_VISIBLE,\n            visible: undefined,\n            columns: changedColumns,\n            column: null,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.raiseColumnResizeEvent = function (changedColumns, source) {\n        if (!changedColumns.length) {\n            return;\n        }\n        var event = {\n            type: Events.EVENT_COLUMN_RESIZED,\n            columns: changedColumns,\n            column: null,\n            finished: true,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.raiseColumnMovedEvent = function (columnStateBefore, source) {\n        var movedColumns = [];\n        var columnStateAfter = this.getColumnState();\n        var _loop_3 = function (i) {\n            var before = columnStateBefore[i];\n            var after = columnStateAfter[i];\n            // don't consider column if reintroduced or hidden\n            if (!before || after.hide) {\n                return \"continue\";\n            }\n            if (before.colId !== after.colId) {\n                var predicate = function (column) { return column.getColId() === after.colId; };\n                var movedColumn = _.find(this_1.allDisplayedColumns, predicate);\n                movedColumns.push(movedColumn);\n            }\n        };\n        var this_1 = this;\n        for (var i = 0; i < columnStateAfter.length; i++) {\n            _loop_3(i);\n        }\n        if (!movedColumns.length) {\n            return;\n        }\n        var event = {\n            type: Events.EVENT_COLUMN_MOVED,\n            columns: movedColumns,\n            column: null,\n            toIndex: undefined,\n            api: this.gridApi,\n            columnApi: this.columnApi,\n            source: source\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.sortColumnListUsingIndexes = function (indexes, colA, colB) {\n        var indexA = indexes[colA.getId()];\n        var indexB = indexes[colB.getId()];\n        return indexA - indexB;\n    };\n    ColumnController.prototype.syncColumnWithNoState = function (column, source) {\n        column.setVisible(false, source);\n        column.setAggFunc(null);\n        column.setPinned(null);\n        column.setRowGroupActive(false, source);\n        column.setPivotActive(false, source);\n        column.setValueActive(false, source);\n    };\n    ColumnController.prototype.syncColumnWithStateItem = function (column, stateItem, rowGroupIndexes, pivotIndexes, source) {\n        if (!column) {\n            return;\n        }\n        // following ensures we are left with boolean true or false, eg converts (null, undefined, 0) all to true\n        column.setVisible(!stateItem.hide, source);\n        // sets pinned to 'left' or 'right'\n        column.setPinned(stateItem.pinned);\n        // if width provided and valid, use it, otherwise stick with the old width\n        var minColWidth = this.gridOptionsWrapper.getMinColWidth();\n        if (stateItem.flex != null) {\n            column.setFlex(stateItem.flex);\n            if (!this.flexActive && stateItem.flex) {\n                this.flexActive = true;\n            }\n        }\n        if (stateItem.width && minColWidth &&\n            (stateItem.width >= minColWidth)) {\n            column.setActualWidth(stateItem.width, source);\n        }\n        if (typeof stateItem.aggFunc === 'string') {\n            column.setAggFunc(stateItem.aggFunc);\n            column.setValueActive(true, source);\n            this.valueColumns.push(column);\n        }\n        else {\n            if (_.exists(stateItem.aggFunc)) {\n                console.warn('ag-Grid: stateItem.aggFunc must be a string. if using your own aggregation ' +\n                    'functions, register the functions first before using them in get/set state. This is because it is ' +\n                    'intended for the column state to be stored and retrieved as simple JSON.');\n            }\n            column.setAggFunc(null);\n            column.setValueActive(false, source);\n        }\n        if (typeof stateItem.rowGroupIndex === 'number') {\n            this.rowGroupColumns.push(column);\n            column.setRowGroupActive(true, source);\n            rowGroupIndexes[column.getId()] = stateItem.rowGroupIndex;\n        }\n        else {\n            column.setRowGroupActive(false, source);\n        }\n        if (typeof stateItem.pivotIndex === 'number') {\n            this.pivotColumns.push(column);\n            column.setPivotActive(true, source);\n            pivotIndexes[column.getId()] = stateItem.pivotIndex;\n        }\n        else {\n            column.setPivotActive(false, source);\n        }\n    };\n    ColumnController.prototype.getGridColumns = function (keys) {\n        return this.getColumns(keys, this.getGridColumn.bind(this));\n    };\n    ColumnController.prototype.getColumns = function (keys, columnLookupCallback) {\n        var foundColumns = [];\n        if (keys) {\n            keys.forEach(function (key) {\n                var column = columnLookupCallback(key);\n                if (column) {\n                    foundColumns.push(column);\n                }\n            });\n        }\n        return foundColumns;\n    };\n    // used by growGroupPanel\n    ColumnController.prototype.getColumnWithValidation = function (key) {\n        if (key == null) {\n            return null;\n        }\n        var column = this.getGridColumn(key);\n        if (!column) {\n            console.warn('ag-Grid: could not find column ' + key);\n        }\n        return column;\n    };\n    ColumnController.prototype.getPrimaryColumn = function (key) {\n        return this.getColumn(key, this.primaryColumns);\n    };\n    ColumnController.prototype.getGridColumn = function (key) {\n        return this.getColumn(key, this.gridColumns);\n    };\n    ColumnController.prototype.getColumn = function (key, columnList) {\n        if (!key) {\n            return null;\n        }\n        for (var i = 0; i < columnList.length; i++) {\n            if (this.columnsMatch(columnList[i], key)) {\n                return columnList[i];\n            }\n        }\n        return this.getAutoColumn(key);\n    };\n    ColumnController.prototype.getAutoColumn = function (key) {\n        var _this = this;\n        if (!this.groupAutoColumns ||\n            !_.exists(this.groupAutoColumns) ||\n            _.missing(this.groupAutoColumns)) {\n            return null;\n        }\n        return _.find(this.groupAutoColumns, function (groupCol) { return _this.columnsMatch(groupCol, key); });\n    };\n    ColumnController.prototype.columnsMatch = function (column, key) {\n        var columnMatches = column === key;\n        var colDefMatches = column.getColDef() === key;\n        var idMatches = column.getColId() == key;\n        return columnMatches || colDefMatches || idMatches;\n    };\n    ColumnController.prototype.getDisplayNameForColumn = function (column, location, includeAggFunc) {\n        if (includeAggFunc === void 0) { includeAggFunc = false; }\n        if (!column) {\n            return null;\n        }\n        var headerName = this.getHeaderName(column.getColDef(), column, null, null, location);\n        if (includeAggFunc) {\n            return this.wrapHeaderNameWithAggFunc(column, headerName);\n        }\n        return headerName;\n    };\n    ColumnController.prototype.getDisplayNameForOriginalColumnGroup = function (columnGroup, originalColumnGroup, location) {\n        var colGroupDef = originalColumnGroup ? originalColumnGroup.getColGroupDef() : null;\n        if (colGroupDef) {\n            return this.getHeaderName(colGroupDef, null, columnGroup, originalColumnGroup, location);\n        }\n        return null;\n    };\n    ColumnController.prototype.getDisplayNameForColumnGroup = function (columnGroup, location) {\n        return this.getDisplayNameForOriginalColumnGroup(columnGroup, columnGroup.getOriginalColumnGroup(), location);\n    };\n    // location is where the column is going to appear, ie who is calling us\n    ColumnController.prototype.getHeaderName = function (colDef, column, columnGroup, originalColumnGroup, location) {\n        var headerValueGetter = colDef.headerValueGetter;\n        if (headerValueGetter) {\n            var params = {\n                colDef: colDef,\n                column: column,\n                columnGroup: columnGroup,\n                originalColumnGroup: originalColumnGroup,\n                location: location,\n                api: this.gridOptionsWrapper.getApi(),\n                context: this.gridOptionsWrapper.getContext()\n            };\n            if (typeof headerValueGetter === 'function') {\n                // valueGetter is a function, so just call it\n                return headerValueGetter(params);\n            }\n            else if (typeof headerValueGetter === 'string') {\n                // valueGetter is an expression, so execute the expression\n                return this.expressionService.evaluate(headerValueGetter, params);\n            }\n            console.warn('ag-grid: headerValueGetter must be a function or a string');\n            return '';\n        }\n        else if (colDef.headerName != null) {\n            return colDef.headerName;\n        }\n        else if (colDef.field) {\n            return _.camelCaseToHumanText(colDef.field);\n        }\n        return '';\n    };\n    /*\n        private getHeaderGroupName(columnGroup: ColumnGroup): string {\n            let colGroupDef = columnGroup.getOriginalColumnGroup().getColGroupDef();\n            let headerValueGetter = colGroupDef.headerValueGetter;\n\n            if (headerValueGetter) {\n                let params = {\n                    columnGroup: columnGroup,\n                    colDef: colGroupDef,\n                    api: this.gridOptionsWrapper.getApi(),\n                    context: this.gridOptionsWrapper.getContext()\n                };\n\n                if (typeof headerValueGetter === 'function') {\n                    // valueGetter is a function, so just call it\n                    return headerValueGetter(params);\n                } else if (typeof headerValueGetter === 'string') {\n                    // valueGetter is an expression, so execute the expression\n                    return this.expressionService.evaluate(headerValueGetter, params);\n                } else {\n                    console.warn('ag-grid: headerValueGetter must be a function or a string');\n                    return '';\n                }\n            } else {\n                return colGroupDef.headerName;\n            }\n        }\n    */\n    ColumnController.prototype.wrapHeaderNameWithAggFunc = function (column, headerName) {\n        if (this.gridOptionsWrapper.isSuppressAggFuncInHeader()) {\n            return headerName;\n        }\n        // only columns with aggregation active can have aggregations\n        var pivotValueColumn = column.getColDef().pivotValueColumn;\n        var pivotActiveOnThisColumn = _.exists(pivotValueColumn);\n        var aggFunc = null;\n        var aggFuncFound;\n        // otherwise we have a measure that is active, and we are doing aggregation on it\n        if (pivotActiveOnThisColumn) {\n            aggFunc = pivotValueColumn ? pivotValueColumn.getAggFunc() : null;\n            aggFuncFound = true;\n        }\n        else {\n            var measureActive = column.isValueActive();\n            var aggregationPresent = this.pivotMode || !this.isRowGroupEmpty();\n            if (measureActive && aggregationPresent) {\n                aggFunc = column.getAggFunc();\n                aggFuncFound = true;\n            }\n            else {\n                aggFuncFound = false;\n            }\n        }\n        if (aggFuncFound) {\n            var aggFuncString = (typeof aggFunc === 'string') ? aggFunc : 'func';\n            var localeTextFunc = this.gridOptionsWrapper.getLocaleTextFunc();\n            var aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n            return aggFuncStringTranslated + \"(\" + headerName + \")\";\n        }\n        return headerName;\n    };\n    // returns the group with matching colId and instanceId. If instanceId is missing,\n    // matches only on the colId.\n    ColumnController.prototype.getColumnGroup = function (colId, instanceId) {\n        if (!colId) {\n            return null;\n        }\n        if (colId instanceof ColumnGroup) {\n            return colId;\n        }\n        var allColumnGroups = this.getAllDisplayedColumnGroups();\n        var checkInstanceId = typeof instanceId === 'number';\n        var result = null;\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof ColumnGroup) {\n                var columnGroup = child;\n                var matched = void 0;\n                if (checkInstanceId) {\n                    matched = colId === columnGroup.getGroupId() && instanceId === columnGroup.getInstanceId();\n                }\n                else {\n                    matched = colId === columnGroup.getGroupId();\n                }\n                if (matched) {\n                    result = columnGroup;\n                }\n            }\n        });\n        return result;\n    };\n    ColumnController.prototype.isReady = function () {\n        return this.ready;\n    };\n    ColumnController.prototype.createValueColumns = function (source, oldPrimaryColumns) {\n        this.valueColumns = this.extractColumns(oldPrimaryColumns, this.valueColumns, function (col, flag) { return col.setValueActive(flag, source); }, \n        // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null\n        function () { return null; }, \n        // aggFunc is a string, so return it's existence\n        function (colDef) { return !!colDef.aggFunc; });\n        // all new columns added will have aggFunc missing, so set it to what is in the colDef\n        this.valueColumns.forEach(function (col) {\n            if (!col.getAggFunc()) {\n                col.setAggFunc(col.getColDef().aggFunc);\n            }\n        });\n    };\n    ColumnController.prototype.extractRowGroupColumns = function (source, oldPrimaryColumns) {\n        this.rowGroupColumns = this.extractColumns(oldPrimaryColumns, this.rowGroupColumns, function (col, flag) { return col.setRowGroupActive(flag, source); }, function (colDef) { return colDef.rowGroupIndex; }, function (colDef) { return colDef.rowGroup; });\n    };\n    ColumnController.prototype.extractColumns = function (oldPrimaryColumns, previousCols, setFlagFunc, getIndexFunc, getValueFunc) {\n        var _this = this;\n        if (!previousCols) {\n            previousCols = [];\n        }\n        // remove cols that no longer exist\n        var colPresentInPrimaryFunc = function (col) { return _this.primaryColumns.indexOf(col) >= 0; };\n        var colMissingFromPrimaryFunc = function (col) { return _this.primaryColumns.indexOf(col) < 0; };\n        var colNewFunc = function (col) { return !oldPrimaryColumns || oldPrimaryColumns.indexOf(col) < 0; };\n        var removedCols = previousCols.filter(colMissingFromPrimaryFunc);\n        var existingCols = previousCols.filter(colPresentInPrimaryFunc);\n        var newPrimaryCols = this.primaryColumns.filter(colNewFunc);\n        removedCols.forEach(function (col) { return setFlagFunc(col, false); });\n        var newCols = [];\n        // we only want to work on new columns, as old columns already got processed first time around\n        // pull out items with xxxIndex\n        newPrimaryCols.forEach(function (col) {\n            var index = getIndexFunc(col.getColDef());\n            if (typeof index === 'number') {\n                newCols.push(col);\n            }\n        });\n        // then sort them\n        newCols.sort(function (colA, colB) {\n            var indexA = getIndexFunc(colA.getColDef());\n            var indexB = getIndexFunc(colB.getColDef());\n            if (indexA === indexB) {\n                return 0;\n            }\n            else if (indexA < indexB) {\n                return -1;\n            }\n            return 1;\n        });\n        // now just pull out items xxx (boolean value), they will be added at the end\n        // after the indexed ones, but in the order the columns appear\n        newPrimaryCols.forEach(function (col) {\n            var booleanValue = getValueFunc(col.getColDef());\n            if (booleanValue) {\n                // if user already specified xxxIndex then we skip it as this col already included\n                if (newCols.indexOf(col) >= 0) {\n                    return;\n                }\n                newCols.push(col);\n            }\n        });\n        newCols.forEach(function (col) { return setFlagFunc(col, true); });\n        var res = existingCols.concat(newCols);\n        return res;\n    };\n    ColumnController.prototype.extractPivotColumns = function (source, oldPrimaryColumns) {\n        this.pivotColumns = this.extractColumns(oldPrimaryColumns, this.pivotColumns, function (col, flag) { return col.setPivotActive(flag, source); }, function (colDef) { return colDef.pivotIndex; }, function (colDef) { return colDef.pivot; });\n    };\n    ColumnController.prototype.resetColumnGroupState = function (source) {\n        if (source === void 0) { source = \"api\"; }\n        var stateItems = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.primaryColumnTree, function (child) {\n            if (child instanceof OriginalColumnGroup) {\n                var groupState = {\n                    groupId: child.getGroupId(),\n                    open: child.getColGroupDef().openByDefault\n                };\n                stateItems.push(groupState);\n            }\n        });\n        this.setColumnGroupState(stateItems, source);\n    };\n    ColumnController.prototype.getColumnGroupState = function () {\n        var columnGroupState = [];\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof OriginalColumnGroup) {\n                var originalColumnGroup = node;\n                columnGroupState.push({\n                    groupId: originalColumnGroup.getGroupId(),\n                    open: originalColumnGroup.isExpanded()\n                });\n            }\n        });\n        return columnGroupState;\n    };\n    ColumnController.prototype.setColumnGroupState = function (stateItems, source) {\n        var _this = this;\n        if (source === void 0) { source = \"api\"; }\n        this.columnAnimationService.start();\n        var impactedGroups = [];\n        stateItems.forEach(function (stateItem) {\n            var groupKey = stateItem.groupId;\n            var newValue = stateItem.open;\n            var originalColumnGroup = _this.getOriginalColumnGroup(groupKey);\n            if (!originalColumnGroup) {\n                return;\n            }\n            if (originalColumnGroup.isExpanded() === newValue) {\n                return;\n            }\n            _this.logger.log('columnGroupOpened(' + originalColumnGroup.getGroupId() + ',' + newValue + ')');\n            originalColumnGroup.setExpanded(newValue);\n            impactedGroups.push(originalColumnGroup);\n        });\n        this.updateGroupsAndDisplayedColumns(source);\n        this.setFirstRightAndLastLeftPinned(source);\n        impactedGroups.forEach(function (originalColumnGroup) {\n            var event = {\n                type: Events.EVENT_COLUMN_GROUP_OPENED,\n                columnGroup: originalColumnGroup,\n                api: _this.gridApi,\n                columnApi: _this.columnApi\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n        this.columnAnimationService.finish();\n    };\n    // called by headerRenderer - when a header is opened or closed\n    ColumnController.prototype.setColumnGroupOpened = function (key, newValue, source) {\n        if (source === void 0) { source = \"api\"; }\n        var keyAsString;\n        if (key instanceof OriginalColumnGroup) {\n            keyAsString = key.getId();\n        }\n        else {\n            keyAsString = key;\n        }\n        this.setColumnGroupState([{ groupId: keyAsString, open: newValue }], source);\n    };\n    ColumnController.prototype.getOriginalColumnGroup = function (key) {\n        if (key instanceof OriginalColumnGroup) {\n            return key;\n        }\n        if (typeof key !== 'string') {\n            console.error('ag-Grid: group key must be a string');\n        }\n        // otherwise, search for the column group by id\n        var res = null;\n        this.columnUtils.depthFirstOriginalTreeSearch(null, this.gridBalancedTree, function (node) {\n            if (node instanceof OriginalColumnGroup) {\n                var originalColumnGroup = node;\n                if (originalColumnGroup.getId() === key) {\n                    res = originalColumnGroup;\n                }\n            }\n        });\n        return res;\n    };\n    ColumnController.prototype.calculateColumnsForDisplay = function () {\n        var _this = this;\n        var columnsForDisplay;\n        if (this.pivotMode && !this.secondaryColumnsPresent) {\n            // pivot mode is on, but we are not pivoting, so we only\n            // show columns we are aggregating on\n            columnsForDisplay = this.gridColumns.filter(function (column) {\n                var isAutoGroupCol = _this.groupAutoColumns && _.includes(_this.groupAutoColumns, column);\n                var isValueCol = _this.valueColumns && _.includes(_this.valueColumns, column);\n                return isAutoGroupCol || isValueCol;\n            });\n        }\n        else {\n            // otherwise continue as normal. this can be working on the primary\n            // or secondary columns, whatever the gridColumns are set to\n            columnsForDisplay = this.gridColumns.filter(function (column) {\n                // keep col if a) it's auto-group or b) it's visible\n                var isAutoGroupCol = _this.groupAutoColumns && _.includes(_this.groupAutoColumns, column);\n                return isAutoGroupCol || column.isVisible();\n            });\n        }\n        return columnsForDisplay;\n    };\n    ColumnController.prototype.checkColSpanActiveInCols = function (columns) {\n        var result = false;\n        columns.forEach(function (col) {\n            if (_.exists(col.getColDef().colSpan)) {\n                result = true;\n            }\n        });\n        return result;\n    };\n    ColumnController.prototype.calculateColumnsForGroupDisplay = function () {\n        var _this = this;\n        this.groupDisplayColumns = [];\n        var checkFunc = function (col) {\n            var colDef = col.getColDef();\n            if (colDef && _.exists(colDef.showRowGroup)) {\n                _this.groupDisplayColumns.push(col);\n            }\n        };\n        this.gridColumns.forEach(checkFunc);\n        if (this.groupAutoColumns) {\n            this.groupAutoColumns.forEach(checkFunc);\n        }\n    };\n    ColumnController.prototype.getGroupDisplayColumns = function () {\n        return this.groupDisplayColumns;\n    };\n    ColumnController.prototype.updateDisplayedColumns = function (source) {\n        var columnsForDisplay = this.calculateColumnsForDisplay();\n        this.buildDisplayedTrees(columnsForDisplay);\n        this.calculateColumnsForGroupDisplay();\n        // also called when group opened/closed\n        this.updateGroupsAndDisplayedColumns(source);\n        // also called when group opened/closed\n        this.setFirstRightAndLastLeftPinned(source);\n    };\n    ColumnController.prototype.isSecondaryColumnsPresent = function () {\n        return this.secondaryColumnsPresent;\n    };\n    ColumnController.prototype.setSecondaryColumns = function (colDefs, source) {\n        if (source === void 0) { source = \"api\"; }\n        var newColsPresent = colDefs && colDefs.length > 0;\n        // if not cols passed, and we had to cols anyway, then do nothing\n        if (!newColsPresent && !this.secondaryColumnsPresent) {\n            return;\n        }\n        if (newColsPresent) {\n            this.processSecondaryColumnDefinitions(colDefs);\n            var balancedTreeResult = this.columnFactory.createColumnTree(colDefs, false);\n            this.secondaryBalancedTree = balancedTreeResult.columnTree;\n            this.secondaryHeaderRowCount = balancedTreeResult.treeDept + 1;\n            this.secondaryColumns = this.getColumnsFromTree(this.secondaryBalancedTree);\n            this.secondaryColumnsPresent = true;\n        }\n        else {\n            this.secondaryBalancedTree = null;\n            this.secondaryHeaderRowCount = -1;\n            this.secondaryColumns = null;\n            this.secondaryColumnsPresent = false;\n        }\n        this.updateGridColumns();\n        this.updateDisplayedColumns(source);\n    };\n    ColumnController.prototype.processSecondaryColumnDefinitions = function (colDefs) {\n        var columnCallback = this.gridOptionsWrapper.getProcessSecondaryColDefFunc();\n        var groupCallback = this.gridOptionsWrapper.getProcessSecondaryColGroupDefFunc();\n        if (!columnCallback && !groupCallback) {\n            return undefined;\n        }\n        var searchForColDefs = function (colDefs2) {\n            colDefs2.forEach(function (abstractColDef) {\n                var isGroup = _.exists(abstractColDef.children);\n                if (isGroup) {\n                    var colGroupDef = abstractColDef;\n                    if (groupCallback) {\n                        groupCallback(colGroupDef);\n                    }\n                    searchForColDefs(colGroupDef.children);\n                }\n                else {\n                    var colDef = abstractColDef;\n                    if (columnCallback) {\n                        columnCallback(colDef);\n                    }\n                }\n            });\n        };\n        if (colDefs) {\n            searchForColDefs(colDefs);\n        }\n    };\n    // called from: setColumnState, setColumnDefs, setSecondaryColumns\n    ColumnController.prototype.updateGridColumns = function () {\n        if (this.gridColsArePrimary) {\n            this.lastPrimaryOrder = this.gridColumns;\n        }\n        if (this.secondaryColumns && this.secondaryBalancedTree) {\n            this.gridBalancedTree = this.secondaryBalancedTree.slice();\n            this.gridHeaderRowCount = this.secondaryHeaderRowCount;\n            this.gridColumns = this.secondaryColumns.slice();\n            this.gridColsArePrimary = false;\n        }\n        else {\n            this.gridBalancedTree = this.primaryColumnTree.slice();\n            this.gridHeaderRowCount = this.primaryHeaderRowCount;\n            this.gridColumns = this.primaryColumns.slice();\n            this.gridColsArePrimary = true;\n            // updateGridColumns gets called after user adds a row group. we want to maintain the order of the columns\n            // when this happens (eg if user moved a column) rather than revert back to the original column order.\n            // likewise if changing in/out of pivot mode, we want to maintain the order of the primary cols\n            this.orderGridColsLikeLastPrimary();\n        }\n        this.addAutoGroupToGridColumns();\n        this.autoRowHeightColumns = this.gridColumns.filter(function (col) { return col.getColDef().autoHeight; });\n        this.putFixedColumnsFirst();\n        this.setupQuickFilterColumns();\n        this.clearDisplayedColumns();\n        this.colSpanActive = this.checkColSpanActiveInCols(this.gridColumns);\n        var event = {\n            type: Events.EVENT_GRID_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.orderGridColsLikeLastPrimary = function () {\n        var _this = this;\n        if (_.missing(this.lastPrimaryOrder)) {\n            return;\n        }\n        // only do the sort if at least one column is accounted for. columns will be not accounted for\n        // if changing from secondary to primary columns\n        var noColsFound = true;\n        this.gridColumns.forEach(function (col) {\n            if (_this.lastPrimaryOrder.indexOf(col) >= 0) {\n                noColsFound = false;\n            }\n        });\n        if (noColsFound) {\n            return;\n        }\n        // order cols in the same order as before. we need to make sure that all\n        // cols still exists, so filter out any that no longer exist.\n        var oldColsOrdered = this.lastPrimaryOrder.filter(function (col) { return _this.gridColumns.indexOf(col) >= 0; });\n        var newColsOrdered = this.gridColumns.filter(function (col) { return oldColsOrdered.indexOf(col) < 0; });\n        // add in the new columns, at the end (if no group), or at the end of the group (if a group)\n        var newGridColumns = oldColsOrdered.slice();\n        newColsOrdered.forEach(function (newCol) {\n            var parent = newCol.getOriginalParent();\n            // if no parent, means we are not grouping, so just add the column to the end\n            if (!parent) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find the group the column belongs to. if no siblings at the current level (eg col in group on it's\n            // own) then go up one level and look for siblings there.\n            var siblings = [];\n            while (!siblings.length && parent) {\n                var leafCols = parent.getLeafColumns();\n                leafCols.forEach(function (leafCol) {\n                    var presentInNewGriColumns = newGridColumns.indexOf(leafCol) >= 0;\n                    var noYetInSiblings = siblings.indexOf(leafCol) < 0;\n                    if (presentInNewGriColumns && noYetInSiblings) {\n                        siblings.push(leafCol);\n                    }\n                });\n                parent = parent.getOriginalParent();\n            }\n            // if no siblings exist at any level, this means the col is in a group (or parent groups) on it's own\n            if (!siblings.length) {\n                newGridColumns.push(newCol);\n                return;\n            }\n            // find index of last column in the group\n            var indexes = siblings.map(function (col) { return newGridColumns.indexOf(col); });\n            var lastIndex = Math.max.apply(Math, indexes);\n            _.insertIntoArray(newGridColumns, newCol, lastIndex + 1);\n        });\n        this.gridColumns = newGridColumns;\n    };\n    ColumnController.prototype.isPrimaryColumnGroupsPresent = function () {\n        return this.primaryHeaderRowCount > 1;\n    };\n    // if we are using autoGroupCols, then they should be included for quick filter. this covers the\n    // following scenarios:\n    // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on\n    // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this\n    //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)\n    ColumnController.prototype.setupQuickFilterColumns = function () {\n        if (this.groupAutoColumns) {\n            this.columnsForQuickFilter = this.primaryColumns.concat(this.groupAutoColumns);\n        }\n        else {\n            this.columnsForQuickFilter = this.primaryColumns;\n        }\n    };\n    ColumnController.prototype.putFixedColumnsFirst = function () {\n        var locked = this.gridColumns.filter(function (c) { return c.getColDef().lockPosition; });\n        var unlocked = this.gridColumns.filter(function (c) { return !c.getColDef().lockPosition; });\n        this.gridColumns = locked.concat(unlocked);\n    };\n    ColumnController.prototype.addAutoGroupToGridColumns = function () {\n        // add in auto-group here\n        this.createGroupAutoColumnsIfNeeded();\n        if (_.missing(this.groupAutoColumns)) {\n            return;\n        }\n        this.gridColumns = this.groupAutoColumns ? this.groupAutoColumns.concat(this.gridColumns) : this.gridColumns;\n        var autoColBalancedTree = this.columnFactory.createForAutoGroups(this.groupAutoColumns, this.gridBalancedTree);\n        this.gridBalancedTree = autoColBalancedTree.concat(this.gridBalancedTree);\n    };\n    // gets called after we copy down grid columns, to make sure any part of the gui\n    // that tries to draw, eg the header, it will get empty lists of columns rather\n    // than stale columns. for example, the header will received gridColumnsChanged\n    // event, so will try and draw, but it will draw successfully when it acts on the\n    // virtualColumnsChanged event\n    ColumnController.prototype.clearDisplayedColumns = function () {\n        this.displayedLeftColumnTree = [];\n        this.displayedRightColumnTree = [];\n        this.displayedCentreColumnTree = [];\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n        this.displayedLeftColumns = [];\n        this.displayedRightColumns = [];\n        this.displayedCenterColumns = [];\n        this.allDisplayedColumns = [];\n        this.allDisplayedVirtualColumns = [];\n    };\n    ColumnController.prototype.updateGroupsAndDisplayedColumns = function (source) {\n        this.updateOpenClosedVisibilityInColumnGroups();\n        this.updateDisplayedColumnsFromTrees(source);\n        this.updateVirtualSets();\n        this.refreshFlexedColumns(undefined, undefined, true);\n        this.updateBodyWidths();\n        // this event is picked up by the gui, headerRenderer and rowRenderer, to recalculate what columns to display\n        var event = {\n            type: Events.EVENT_DISPLAYED_COLUMNS_CHANGED,\n            api: this.gridApi,\n            columnApi: this.columnApi\n        };\n        this.eventService.dispatchEvent(event);\n    };\n    ColumnController.prototype.updateDisplayedColumnsFromTrees = function (source) {\n        this.addToDisplayedColumns(this.displayedLeftColumnTree, this.displayedLeftColumns);\n        this.addToDisplayedColumns(this.displayedCentreColumnTree, this.displayedCenterColumns);\n        this.addToDisplayedColumns(this.displayedRightColumnTree, this.displayedRightColumns);\n        this.setupAllDisplayedColumns();\n        this.setLeftValues(source);\n    };\n    ColumnController.prototype.setupAllDisplayedColumns = function () {\n        if (this.gridOptionsWrapper.isEnableRtl()) {\n            this.allDisplayedColumns = this.displayedRightColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedLeftColumns);\n        }\n        else {\n            this.allDisplayedColumns = this.displayedLeftColumns\n                .concat(this.displayedCenterColumns)\n                .concat(this.displayedRightColumns);\n        }\n    };\n    // sets the left pixel position of each column\n    ColumnController.prototype.setLeftValues = function (source) {\n        this.setLeftValuesOfColumns(source);\n        this.setLeftValuesOfGroups();\n    };\n    ColumnController.prototype.setLeftValuesOfColumns = function (source) {\n        var _this = this;\n        // go through each list of displayed columns\n        var allColumns = this.primaryColumns.slice(0);\n        // let totalColumnWidth = this.getWidthOfColsInList()\n        var doingRtl = this.gridOptionsWrapper.isEnableRtl();\n        [\n            this.displayedLeftColumns,\n            this.displayedRightColumns,\n            this.displayedCenterColumns\n        ].forEach(function (columns) {\n            if (doingRtl) {\n                // when doing RTL, we start at the top most pixel (ie RHS) and work backwards\n                var left_1 = _this.getWidthOfColsInList(columns);\n                columns.forEach(function (column) {\n                    left_1 -= column.getActualWidth();\n                    column.setLeft(left_1, source);\n                });\n            }\n            else {\n                // otherwise normal LTR, we start at zero\n                var left_2 = 0;\n                columns.forEach(function (column) {\n                    column.setLeft(left_2, source);\n                    left_2 += column.getActualWidth();\n                });\n            }\n            _.removeAllFromArray(allColumns, columns);\n        });\n        // items left in allColumns are columns not displayed, so remove the left position. this is\n        // important for the rows, as if a col is made visible, then taken out, then made visible again,\n        // we don't want the animation of the cell floating in from the old position, whatever that was.\n        allColumns.forEach(function (column) {\n            column.setLeft(null, source);\n        });\n    };\n    ColumnController.prototype.setLeftValuesOfGroups = function () {\n        // a groups left value is the lest left value of it's children\n        [\n            this.displayedLeftColumnTree,\n            this.displayedRightColumnTree,\n            this.displayedCentreColumnTree\n        ].forEach(function (columns) {\n            columns.forEach(function (column) {\n                if (column instanceof ColumnGroup) {\n                    var columnGroup = column;\n                    columnGroup.checkLeft();\n                }\n            });\n        });\n    };\n    ColumnController.prototype.addToDisplayedColumns = function (displayedColumnTree, displayedColumns) {\n        displayedColumns.length = 0;\n        this.columnUtils.depthFirstDisplayedColumnTreeSearch(displayedColumnTree, function (child) {\n            if (child instanceof Column) {\n                displayedColumns.push(child);\n            }\n        });\n    };\n    ColumnController.prototype.updateDisplayedCenterVirtualColumns = function () {\n        if (this.suppressColumnVirtualisation) {\n            // no virtualisation, so don't filter\n            this.allDisplayedCenterVirtualColumns = this.displayedCenterColumns;\n        }\n        else {\n            // filter out what should be visible\n            this.allDisplayedCenterVirtualColumns = this.filterOutColumnsWithinViewport();\n        }\n        this.allDisplayedVirtualColumns = this.allDisplayedCenterVirtualColumns\n            .concat(this.displayedLeftColumns)\n            .concat(this.displayedRightColumns);\n        // return map of virtual col id's, for easy lookup when building the groups.\n        // the map will be colId=>true, ie col id's mapping to 'true'.\n        var result = {};\n        this.allDisplayedVirtualColumns.forEach(function (col) {\n            result[col.getId()] = true;\n        });\n        return result;\n    };\n    ColumnController.prototype.getVirtualHeaderGroupRow = function (type, dept) {\n        var result;\n        switch (type) {\n            case Constants.PINNED_LEFT:\n                result = this.displayedLeftHeaderRows[dept];\n                break;\n            case Constants.PINNED_RIGHT:\n                result = this.displayedRightHeaderRows[dept];\n                break;\n            default:\n                result = this.displayedCentreHeaderRows[dept];\n                break;\n        }\n        if (_.missing(result)) {\n            result = [];\n        }\n        return result;\n    };\n    ColumnController.prototype.updateDisplayedVirtualGroups = function (virtualColIds) {\n        // go through each group, see if any of it's cols are displayed, and if yes,\n        // then this group is included\n        this.displayedLeftHeaderRows = {};\n        this.displayedRightHeaderRows = {};\n        this.displayedCentreHeaderRows = {};\n        var testGroup = function (children, result, dept) {\n            var returnValue = false;\n            for (var i = 0; i < children.length; i++) {\n                // see if this item is within viewport\n                var child = children[i];\n                var addThisItem = void 0;\n                if (child instanceof Column) {\n                    // for column, test if column is included\n                    addThisItem = virtualColIds[child.getId()] === true;\n                }\n                else {\n                    // if group, base decision on children\n                    var columnGroup = child;\n                    addThisItem = testGroup(columnGroup.getDisplayedChildren(), result, dept + 1);\n                }\n                if (addThisItem) {\n                    returnValue = true;\n                    if (!result[dept]) {\n                        result[dept] = [];\n                    }\n                    result[dept].push(child);\n                }\n            }\n            return returnValue;\n        };\n        testGroup(this.displayedLeftColumnTree, this.displayedLeftHeaderRows, 0);\n        testGroup(this.displayedRightColumnTree, this.displayedRightHeaderRows, 0);\n        testGroup(this.displayedCentreColumnTree, this.displayedCentreHeaderRows, 0);\n    };\n    ColumnController.prototype.updateVirtualSets = function () {\n        var virtualColIds = this.updateDisplayedCenterVirtualColumns();\n        this.updateDisplayedVirtualGroups(virtualColIds);\n    };\n    ColumnController.prototype.filterOutColumnsWithinViewport = function () {\n        return this.displayedCenterColumns.filter(this.isColumnInViewport.bind(this));\n    };\n    ColumnController.prototype.refreshFlexedColumns = function (updatedFlexViewportWidth, source, silent) {\n        if (source === void 0) { source = 'flex'; }\n        if (!this.flexActive) {\n            return;\n        }\n        this.flexViewportWidth = updatedFlexViewportWidth || this.flexViewportWidth;\n        if (!this.flexViewportWidth) {\n            return;\n        }\n        // If the grid has left-over space, divide it between flexing columns in proportion to their flex value.\n        // A \"flexing column\" is one that has a 'flex' value set and is not currently being constrained by its\n        // minWidth or maxWidth rules.\n        var knownWidthColumns = this.displayedCenterColumns.filter(function (col) { return !col.getFlex(); });\n        var flexingColumns = this.displayedCenterColumns.filter(function (col) { return col.getFlex(); });\n        if (!flexingColumns.length) {\n            this.flexActive = false;\n            return;\n        }\n        var flexingColumnSizes = [];\n        var spaceForFlexingColumns;\n        outer: while (true) {\n            var totalFlex = flexingColumns.reduce(function (count, col) { return count + col.getFlex(); }, 0);\n            spaceForFlexingColumns = this.flexViewportWidth - this.getWidthOfColsInList(knownWidthColumns);\n            for (var i = 0; i < flexingColumns.length; i++) {\n                var col = flexingColumns[i];\n                var widthByFlexRule = spaceForFlexingColumns * col.getFlex() / totalFlex;\n                var constrainedWidth = void 0;\n                if (widthByFlexRule < col.getMinWidth()) {\n                    constrainedWidth = col.getMinWidth();\n                }\n                else if (col.getMaxWidth() != null && widthByFlexRule > col.getMaxWidth()) {\n                    constrainedWidth = col.getMaxWidth();\n                }\n                if (constrainedWidth) {\n                    // This column is not in fact flexing as it is being constrained to a specific size\n                    // so remove it from the list of flexing columns and start again\n                    col.setActualWidth(constrainedWidth, source);\n                    _.removeFromArray(flexingColumns, col);\n                    knownWidthColumns.push(col);\n                    continue outer;\n                }\n                flexingColumnSizes[i] = Math.round(widthByFlexRule);\n            }\n            break;\n        }\n        var remainingSpace = spaceForFlexingColumns;\n        flexingColumns.forEach(function (col, i) {\n            col.setActualWidth(Math.min(flexingColumnSizes[i], remainingSpace), source);\n            remainingSpace -= flexingColumnSizes[i];\n        });\n        this.setLeftValues(source);\n        if (!silent) {\n            this.updateBodyWidths();\n            this.fireResizedEventForColumns(flexingColumns, source);\n        }\n    };\n    // called from api\n    ColumnController.prototype.sizeColumnsToFit = function (gridWidth, source, silent) {\n        if (source === void 0) { source = \"sizeColumnsToFit\"; }\n        // avoid divide by zero\n        var allDisplayedColumns = this.getAllDisplayedColumns();\n        if (gridWidth <= 0 || !allDisplayedColumns.length) {\n            return;\n        }\n        var colsToSpread = [];\n        var colsToNotSpread = [];\n        allDisplayedColumns.forEach(function (column) {\n            if (column.getColDef().suppressSizeToFit === true) {\n                colsToNotSpread.push(column);\n            }\n            else {\n                colsToSpread.push(column);\n            }\n        });\n        // make a copy of the cols that are going to be resized\n        var colsToFireEventFor = colsToSpread.slice(0);\n        var finishedResizing = false;\n        var moveToNotSpread = function (column) {\n            _.removeFromArray(colsToSpread, column);\n            colsToNotSpread.push(column);\n        };\n        // resetting cols to their original width makes the sizeColumnsToFit more deterministic,\n        // rather than depending on the current size of the columns. most users call sizeColumnsToFit\n        // immediately after grid is created, so will make no difference. however if application is calling\n        // sizeColumnsToFit repeatedly (eg after column group is opened / closed repeatedly) we don't want\n        // the columns to start shrinking / growing over time.\n        colsToSpread.forEach(function (column) { return column.resetActualWidth(); });\n        while (!finishedResizing) {\n            finishedResizing = true;\n            var availablePixels = gridWidth - this.getWidthOfColsInList(colsToNotSpread);\n            if (availablePixels <= 0) {\n                // no width, set everything to minimum\n                colsToSpread.forEach(function (column) {\n                    column.setMinimum(source);\n                });\n            }\n            else {\n                var scale = availablePixels / this.getWidthOfColsInList(colsToSpread);\n                // we set the pixels for the last col based on what's left, as otherwise\n                // we could be a pixel or two short or extra because of rounding errors.\n                var pixelsForLastCol = availablePixels;\n                // backwards through loop, as we are removing items as we go\n                for (var i = colsToSpread.length - 1; i >= 0; i--) {\n                    var column = colsToSpread[i];\n                    var newWidth = Math.round(column.getActualWidth() * scale);\n                    if (newWidth < column.getMinWidth()) {\n                        column.setMinimum(source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else if (column.isGreaterThanMax(newWidth)) {\n                        column.setActualWidth(column.getMaxWidth(), source);\n                        moveToNotSpread(column);\n                        finishedResizing = false;\n                    }\n                    else {\n                        var onLastCol = i === 0;\n                        if (onLastCol) {\n                            column.setActualWidth(pixelsForLastCol, source);\n                        }\n                        else {\n                            column.setActualWidth(newWidth, source);\n                        }\n                    }\n                    pixelsForLastCol -= newWidth;\n                }\n            }\n        }\n        this.setLeftValues(source);\n        this.updateBodyWidths();\n        if (silent) {\n            return;\n        }\n        this.fireResizedEventForColumns(colsToFireEventFor, source);\n    };\n    ColumnController.prototype.fireResizedEventForColumns = function (columns, source) {\n        var _this = this;\n        columns.forEach(function (column) {\n            var event = {\n                type: Events.EVENT_COLUMN_RESIZED,\n                column: column,\n                columns: [column],\n                finished: true,\n                api: _this.gridApi,\n                columnApi: _this.columnApi,\n                source: source\n            };\n            _this.eventService.dispatchEvent(event);\n        });\n    };\n    ColumnController.prototype.buildDisplayedTrees = function (visibleColumns) {\n        var leftVisibleColumns = [];\n        var rightVisibleColumns = [];\n        var centerVisibleColumns = [];\n        visibleColumns.forEach(function (column) {\n            switch (column.getPinned()) {\n                case \"left\":\n                    leftVisibleColumns.push(column);\n                    break;\n                case \"right\":\n                    rightVisibleColumns.push(column);\n                    break;\n                default:\n                    centerVisibleColumns.push(column);\n                    break;\n            }\n        });\n        var groupInstanceIdCreator = new GroupInstanceIdCreator();\n        this.displayedLeftColumnTree = this.displayedGroupCreator.createDisplayedGroups(leftVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_LEFT, this.displayedLeftColumnTree);\n        this.displayedRightColumnTree = this.displayedGroupCreator.createDisplayedGroups(rightVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, Constants.PINNED_RIGHT, this.displayedRightColumnTree);\n        this.displayedCentreColumnTree = this.displayedGroupCreator.createDisplayedGroups(centerVisibleColumns, this.gridBalancedTree, groupInstanceIdCreator, null, this.displayedCentreColumnTree);\n    };\n    ColumnController.prototype.updateOpenClosedVisibilityInColumnGroups = function () {\n        var allColumnGroups = this.getAllDisplayedColumnGroups();\n        this.columnUtils.depthFirstAllColumnTreeSearch(allColumnGroups, function (child) {\n            if (child instanceof ColumnGroup) {\n                var columnGroup = child;\n                columnGroup.calculateDisplayedColumns();\n            }\n        });\n    };\n    ColumnController.prototype.getGroupAutoColumns = function () {\n        return this.groupAutoColumns;\n    };\n    ColumnController.prototype.createGroupAutoColumnsIfNeeded = function () {\n        if (!this.autoGroupsNeedBuilding) {\n            return;\n        }\n        this.autoGroupsNeedBuilding = false;\n        var groupFullWidthRow = this.gridOptionsWrapper.isGroupUseEntireRow(this.pivotMode);\n        // we need to allow suppressing auto-column separately for group and pivot as the normal situation\n        // is CSRM and user provides group column themselves for normal view, but when they go into pivot the\n        // columns are generated by the grid so no opportunity for user to provide group column. so need a way\n        // to suppress auto-col for grouping only, and not pivot.\n        // however if using Viewport RM or SSRM and user is providing the columns, the user may wish full control\n        // of the group column in this instance.\n        var suppressAutoColumn = this.pivotMode ?\n            this.gridOptionsWrapper.isPivotSuppressAutoColumn() : this.gridOptionsWrapper.isGroupSuppressAutoColumn();\n        // const groupSuppressAutoColumn = this.gridOptionsWrapper.isGroupSuppressAutoColumn() && !this.pivotMode;\n        var groupSuppressRow = this.gridOptionsWrapper.isGroupSuppressRow();\n        var groupingActive = this.rowGroupColumns.length > 0 || this.usingTreeData;\n        var needAutoColumns = groupingActive && !suppressAutoColumn && !groupFullWidthRow && !groupSuppressRow;\n        if (needAutoColumns) {\n            var newAutoGroupCols = this.autoGroupColService.createAutoGroupColumns(this.rowGroupColumns);\n            var autoColsDifferent = !this.autoColsEqual(newAutoGroupCols, this.groupAutoColumns);\n            // we force recreate when suppressSetColumnStateEvents changes, so new group cols pick up the new\n            // definitions. otherwise we could ignore the new cols becasue they appear to be the same.\n            if (autoColsDifferent || this.forceRecreateAutoGroups) {\n                this.groupAutoColumns = newAutoGroupCols;\n            }\n        }\n        else {\n            this.groupAutoColumns = null;\n        }\n    };\n    ColumnController.prototype.autoColsEqual = function (colsA, colsB) {\n        return areEqual(colsA, colsB, function (a, b) { return a.getColId() === b.getColId(); });\n    };\n    ColumnController.prototype.getWidthOfColsInList = function (columnList) {\n        return columnList.reduce(function (width, col) { return width + col.getActualWidth(); }, 0);\n    };\n    ColumnController.prototype.getGridBalancedTree = function () {\n        return this.gridBalancedTree;\n    };\n    ColumnController.prototype.hasFloatingFilters = function () {\n        var defaultColDef = this.gridOptionsWrapper.getDefaultColDef();\n        return (defaultColDef != null && defaultColDef.floatingFilter === true) ||\n            (this.columnDefs != null && this.columnDefs.some(function (c) { return c.floatingFilter === true; }));\n    };\n    ColumnController.prototype.getFirstDisplayedColumn = function () {\n        var isRtl = this.gridOptionsWrapper.isEnableRtl();\n        var queryOrder = [\n            'getDisplayedLeftColumns',\n            'getDisplayedCenterColumns',\n            'getDisplayedRightColumns'\n        ];\n        if (isRtl) {\n            queryOrder.reverse();\n        }\n        for (var i = 0; i < queryOrder.length; i++) {\n            var container = this[queryOrder[i]]();\n            if (container.length) {\n                return isRtl ? _.last(container) : container[0];\n            }\n        }\n        return null;\n    };\n    __decorate([\n        Autowired('gridOptionsWrapper')\n    ], ColumnController.prototype, \"gridOptionsWrapper\", void 0);\n    __decorate([\n        Autowired('expressionService')\n    ], ColumnController.prototype, \"expressionService\", void 0);\n    __decorate([\n        Autowired('columnFactory')\n    ], ColumnController.prototype, \"columnFactory\", void 0);\n    __decorate([\n        Autowired('displayedGroupCreator')\n    ], ColumnController.prototype, \"displayedGroupCreator\", void 0);\n    __decorate([\n        Autowired('autoWidthCalculator')\n    ], ColumnController.prototype, \"autoWidthCalculator\", void 0);\n    __decorate([\n        Autowired('columnUtils')\n    ], ColumnController.prototype, \"columnUtils\", void 0);\n    __decorate([\n        Autowired('columnAnimationService')\n    ], ColumnController.prototype, \"columnAnimationService\", void 0);\n    __decorate([\n        Autowired('autoGroupColService')\n    ], ColumnController.prototype, \"autoGroupColService\", void 0);\n    __decorate([\n        Optional('aggFuncService')\n    ], ColumnController.prototype, \"aggFuncService\", void 0);\n    __decorate([\n        Optional('valueCache')\n    ], ColumnController.prototype, \"valueCache\", void 0);\n    __decorate([\n        Optional('animationFrameService')\n    ], ColumnController.prototype, \"animationFrameService\", void 0);\n    __decorate([\n        Autowired('columnApi')\n    ], ColumnController.prototype, \"columnApi\", void 0);\n    __decorate([\n        Autowired('gridApi')\n    ], ColumnController.prototype, \"gridApi\", void 0);\n    __decorate([\n        PostConstruct\n    ], ColumnController.prototype, \"init\", null);\n    __decorate([\n        __param(0, Qualifier('loggerFactory'))\n    ], ColumnController.prototype, \"setBeans\", null);\n    ColumnController = __decorate([\n        Bean('columnController')\n    ], ColumnController);\n    return ColumnController;\n}(BeanStub));\nexport { ColumnController };\n"]},"metadata":{},"sourceType":"module"}